diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/scripts/config.sub glibc-2.14.1/scripts/config.sub
--- ../glibc-2.14.1-orig/scripts/config.sub	2011-10-25 02:50:25.000000000 -0700
+++ glibc-2.14.1/scripts/config.sub	2011-10-25 02:46:03.000000000 -0700
@@ -290,6 +290,7 @@
 	| pdp10 | pdp11 | pj | pjl \
 	| powerpc | powerpc64 | powerpc64le | powerpcle | ppcbe \
 	| pyramid \
+	| riscv \
 	| rx \
 	| score \
 	| sh | sh[1234] | sh[24]a | sh[24]aeb | sh[23]e | sh[34]eb | sheb | shbe | shle | sh[1234]le | sh3ele \
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/abort-instr.h glibc-2.14.1/sysdeps/riscv/abort-instr.h
--- ../glibc-2.14.1-orig/sysdeps/riscv/abort-instr.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/abort-instr.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,2 @@
+/* An instruction which should crash any program is a breakpoint.  */
+#define ABORT_INSTRUCTION asm ("unimp")
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/bits/atomic.h glibc-2.14.1/sysdeps/riscv/bits/atomic.h
--- ../glibc-2.14.1-orig/sysdeps/riscv/bits/atomic.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/bits/atomic.h	2011-11-01 23:44:42.000000000 -0700
@@ -0,0 +1,177 @@
+/* Low-level functions for atomic operations. Mips version.
+   Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _MIPS_BITS_ATOMIC_H
+#define _MIPS_BITS_ATOMIC_H 1
+
+#include <inttypes.h>
+#include <sgidefs.h>
+
+typedef int32_t atomic32_t;
+typedef uint32_t uatomic32_t;
+typedef int_fast32_t atomic_fast32_t;
+typedef uint_fast32_t uatomic_fast32_t;
+
+typedef int64_t atomic64_t;
+typedef uint64_t uatomic64_t;
+typedef int_fast64_t atomic_fast64_t;
+typedef uint_fast64_t uatomic_fast64_t;
+
+typedef intptr_t atomicptr_t;
+typedef uintptr_t uatomicptr_t;
+typedef intmax_t atomic_max_t;
+typedef uintmax_t uatomic_max_t;
+
+/* We have no compare and swap, so we acquire a global lock to emulate it.
+   We assume no variable will be accessed using atomic.h macros from two
+   different libraries.  */
+
+__make_section_unallocated
+  (".gnu.linkonce.b.__riscv_atomic_lock, \"aw\", %nobits");
+
+volatile int __riscv_atomic_lock
+  __attribute__ ((nocommon, section(".gnu.linkonce.b.__riscv_atomic_lock\n\t#"),
+		  visibility ("hidden")));
+
+#define __riscv_atomic_do_lock(addr) ({ \
+  extern volatile int __riscv_atomic_lock;				      \
+  __riscv_atomic_do_lock24(&__riscv_atomic_lock);       	      \
+  __sync_synchronize(); })
+
+#define __riscv_atomic_do_unlock(addr) ({ \
+  extern volatile int __riscv_atomic_lock;				      \
+  __sync_synchronize();                                        	      \
+  __riscv_atomic_lock = 0; })
+
+#define __riscv_atomic_do_lock24(addr) ({ \
+  int __locked_val;                                                     \
+  int __mask = 0xFF000000;                                              \
+  while ((__locked_val = __sync_fetch_and_or(addr, __mask)) & __mask)   \
+    while (*(volatile int*)(addr) & __mask)      	                \
+      ;                                     		                \
+  __locked_val; })
+
+/* The only basic operation needed is compare and exchange.  */
+#define atomic_compare_and_exchange_val_acq(mem, newval, oldval) \
+  ({ __typeof (mem) __acev_memp = (mem);			      \
+     __typeof (*mem) __acev_ret;				      \
+     __typeof (*mem) __acev_newval = (newval);			      \
+								      \
+     __riscv_atomic_do_lock (__acev_memp);			      \
+     __acev_ret = *__acev_memp;					      \
+     if (__acev_ret == (oldval))				      \
+       *__acev_memp = __acev_newval;				      \
+     __riscv_atomic_do_unlock (__acev_memp);			      \
+     __acev_ret; })
+
+#define atomic_compare_and_exchange_bool_acq(mem, newval, oldval) \
+  (atomic_compare_and_exchange_val_acq(mem, newval, oldval) != (oldval))
+
+/* Special versions, which guarantee that top 8 bits of all values
+   are cleared and use those bits as the lock.  */
+#define atomic_compare_and_exchange_val_24_acq(mem, newval, oldval) \
+  ({ __typeof (mem) __acev_memp = (mem);			      \
+     __typeof (*mem) __acev_ret;				      \
+     __typeof (*mem) __acev_newval = (newval);			      \
+								      \
+     __acev_ret = __riscv_atomic_do_lock24 (__acev_memp);	      \
+     if (__acev_ret == (oldval))				      \
+       *__acev_memp = __acev_newval & 0x00FFFFFF;		      \
+     else							      \
+       *__acev_memp = __acev_ret;	                	      \
+     __sync_synchronize();              			      \
+     __acev_ret; })
+
+#define atomic_exchange_24_rel(mem, newval) \
+  ({ __typeof (mem) __acev_memp = (mem);			      \
+     __typeof (*mem) __acev_ret;				      \
+     __typeof (*mem) __acev_newval = (newval);			      \
+								      \
+     __sync_synchronize();              			      \
+     __acev_ret = __riscv_atomic_do_lock24 (__acev_memp);	      \
+     *__acev_memp = __acev_newval & 0x00FFFFFF;                       \
+     __acev_ret; })
+
+/* Atomic exchange (without compare).  */
+
+#define atomic_exchange_acq(mem, value)         \
+  ({ __sync_synchronize();                      \
+     __sync_lock_test_and_set(mem, value); })
+
+#define atomic_exchange_rel(mem, value)         \
+  ({ typeof(*mem) __prev;                       \
+     __prev = __sync_lock_test_and_set(mem, value);  \
+     __sync_synchronize();                      \
+     __prev; })
+
+
+/* Atomically add value and return the previous (unincremented) value.  */
+
+/* ??? Barrier semantics for atomic_exchange_and_add appear to be 
+   undefined.  Use full barrier for now, as that's safe.  */
+#define atomic_exchange_and_add(mem, value)             \
+  ({ typeof(*mem) __prev;                               \
+     __sync_synchronize();                              \
+     __prev = __sync_fetch_and_add(mem, value);         \
+     __sync_synchronize();                              \
+     __prev; })
+
+#define catomic_exchange_and_add(mem, value)		\
+  atomic_exchange_and_add(mem, value)
+
+#define atomic_bit_test_set(mem, bit)                   \
+  ({ typeof(*mem) __prev;                               \
+     typeof(*mem) __mask = (typeof(*mem))1 << (bit);    \
+     __sync_synchronize();                              \
+     __prev = __sync_fetch_and_or(mem, __mask);         \
+     __sync_synchronize();                              \
+     __prev & __mask; })
+
+#define asm_maxmin(which, size, res, mem, value) \
+  asm ("amo" which "." size "\t%0, %1, 0(%2)" : "=r"(res) : "r"(value), "r"(mem) : "memory")
+
+#define atomic_max(mem, value)		        	\
+  ({  typeof(*mem) __prev;                    		\
+      __sync_synchronize();                            	\
+      if (sizeof(*mem) == 4)				\
+	asm_maxmin("maxu", "s", __prev, mem, value);	\
+      else if(sizeof(*mem) == 8)			\
+	asm_maxmin("maxu", "d", __prev, mem, value);	\
+      else						\
+	abort();					\
+     __sync_synchronize();                              \
+     __prev; })
+
+#define catomic_max(mem, value) atomic_max(mem, value)
+
+#define atomic_min(mem, value)		        	\
+  ({  typeof(*mem) __prev;                    		\
+      __sync_synchronize();                            	\
+      if (sizeof(*mem) == 4)				\
+	asm_maxmin("minu", "s", __prev, mem, value);	\
+      else if(sizeof(*mem) == 8)			\
+	asm_maxmin("minu", "d", __prev, mem, value);	\
+      else						\
+	abort();					\
+     __sync_synchronize();                              \
+     __prev; })
+
+#define atomic_full_barrier() __sync_synchronize()
+
+#endif /* bits/atomic.h */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/bits/dlfcn.h glibc-2.14.1/sysdeps/riscv/bits/dlfcn.h
--- ../glibc-2.14.1-orig/sysdeps/riscv/bits/dlfcn.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/bits/dlfcn.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,66 @@
+/* System dependent definitions for run-time dynamic loading.
+   Copyright (C) 1996, 1997, 1999, 2000, 2001, 2004
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _DLFCN_H
+# error "Never use <bits/dlfcn.h> directly; include <dlfcn.h> instead."
+#endif
+
+/* The MODE argument to `dlopen' contains one of the following: */
+#define RTLD_LAZY	0x0001	/* Lazy function call binding.  */
+#define RTLD_NOW	0x0002	/* Immediate function call binding.  */
+#define RTLD_BINDING_MASK  0x3	/* Mask of binding time value.  */
+#define RTLD_NOLOAD	0x00008	/* Do not load the object.  */
+#define RTLD_DEEPBIND	0x00010	/* Use deep binding.  */
+
+/* If the following bit is set in the MODE argument to `dlopen',
+   the symbols of the loaded object and its dependencies are made
+   visible as if the object were linked directly into the program.  */
+#define RTLD_GLOBAL	0x0004
+
+/* Unix98 demands the following flag which is the inverse to RTLD_GLOBAL.
+   The implementation does this by default and so we can define the
+   value to zero.  */
+#define RTLD_LOCAL      0
+
+/* Do not delete object when closed.  */
+#define RTLD_NODELETE	0x01000
+
+#ifdef __USE_GNU
+/* To support profiling of shared objects it is a good idea to call
+   the function found using `dlsym' using the following macro since
+   these calls do not use the PLT.  But this would mean the dynamic
+   loader has no chance to find out when the function is called.  The
+   macro applies the necessary magic so that profiling is possible.
+   Rewrite
+	foo = (*fctp) (arg1, arg2);
+   into
+        foo = DL_CALL_FCT (fctp, (arg1, arg2));
+*/
+# define DL_CALL_FCT(fctp, args) \
+  (_dl_mcount_wrapper_check ((void *) (fctp)), (*(fctp)) args)
+
+__BEGIN_DECLS
+
+/* This function calls the profiling functions.  */
+extern void _dl_mcount_wrapper_check (void *__selfpc) __THROW;
+
+__END_DECLS
+
+#endif
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/bits/endian.h glibc-2.14.1/sysdeps/riscv/bits/endian.h
--- ../glibc-2.14.1-orig/sysdeps/riscv/bits/endian.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/bits/endian.h	2011-10-27 21:55:31.000000000 -0700
@@ -0,0 +1,13 @@
+/* The MIPS architecture has selectable endianness.
+   This file is for a machine using big-endian mode.  */
+
+#ifndef _ENDIAN_H
+# error "Never use <bits/endian.h> directly; include <endian.h> instead."
+#endif
+
+#if __RISCVEB
+# define __BYTE_ORDER __BIG_ENDIAN
+#endif
+#if __RISCVEL
+# define __BYTE_ORDER __LITTLE_ENDIAN
+#endif
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/bits/fenv.h glibc-2.14.1/sysdeps/riscv/bits/fenv.h
--- ../glibc-2.14.1-orig/sysdeps/riscv/bits/fenv.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/bits/fenv.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,77 @@
+/* Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _FENV_H
+# error "Never use <bits/fenv.h> directly; include <fenv.h> instead."
+#endif
+
+
+/* Define bits representing the exception.  We use the bit positions
+   of the appropriate bits in the FPU control word.  */
+enum
+  {
+    FE_INEXACT = 0x04,
+#define FE_INEXACT	FE_INEXACT
+    FE_UNDERFLOW = 0x08,
+#define FE_UNDERFLOW	FE_UNDERFLOW
+    FE_OVERFLOW = 0x10,
+#define FE_OVERFLOW	FE_OVERFLOW
+    FE_DIVBYZERO = 0x20,
+#define FE_DIVBYZERO	FE_DIVBYZERO
+    FE_INVALID = 0x40,
+#define FE_INVALID	FE_INVALID
+  };
+
+#define FE_ALL_EXCEPT \
+	(FE_INEXACT | FE_DIVBYZERO | FE_UNDERFLOW | FE_OVERFLOW | FE_INVALID)
+
+/* The MIPS FPU supports all of the four defined rounding modes.  We
+   use again the bit positions in the FPU control word as the values
+   for the appropriate macros.  */
+enum
+  {
+    FE_TONEAREST = 0x0,
+#define FE_TONEAREST	FE_TONEAREST
+    FE_TOWARDZERO = 0x1,
+#define FE_TOWARDZERO	FE_TOWARDZERO
+    FE_UPWARD = 0x2,
+#define FE_UPWARD	FE_UPWARD
+    FE_DOWNWARD = 0x3
+#define FE_DOWNWARD	FE_DOWNWARD
+  };
+
+
+/* Type representing exception flags.  */
+typedef unsigned short int fexcept_t;
+
+
+/* Type representing floating-point environment.  This function corresponds
+   to the layout of the block written by the `fstenv'.  */
+typedef struct
+  {
+    unsigned int __fp_control_register;
+  }
+fenv_t;
+
+/* If the default argument is used we use this value.  */
+#define FE_DFL_ENV	((__const fenv_t *) -1)
+
+#ifdef __USE_GNU
+/* Floating-point environment where none of the exception is masked.  */
+# define FE_NOMASK_ENV  ((__const fenv_t *) -2)
+#endif
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/bits/ipctypes.h glibc-2.14.1/sysdeps/riscv/bits/ipctypes.h
--- ../glibc-2.14.1-orig/sysdeps/riscv/bits/ipctypes.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/bits/ipctypes.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,32 @@
+/* bits/ipctypes.h -- Define some types used by SysV IPC/MSG/SHM.  MIPS version
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ * Never include <bits/ipctypes.h> directly.
+ */
+
+#ifndef _BITS_IPCTYPES_H
+#define _BITS_IPCTYPES_H	1
+
+#include <bits/types.h>
+
+typedef __SLONG32_TYPE __ipc_pid_t;
+
+
+#endif /* bits/ipctypes.h */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/bits/link.h glibc-2.14.1/sysdeps/riscv/bits/link.h
--- ../glibc-2.14.1-orig/sysdeps/riscv/bits/link.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/bits/link.h	2011-11-03 19:06:26.000000000 -0700
@@ -0,0 +1,76 @@
+/* Copyright (C) 2005, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_LINK_H
+# error "Never include <bits/link.h> directly; use <link.h> instead."
+#endif
+
+typedef struct La_mips_64_regs
+{
+  unsigned long lr_reg[8]; /* $a0 through $a7 */
+  double lr_fpreg[8]; /* $f4 throgh $f11 */
+  unsigned long lr_ra;
+  unsigned long lr_sp;
+} La_mips_64_regs;
+
+/* Return values for calls from PLT on MIPS.  */
+typedef struct La_mips_64_retval
+{
+  unsigned long lrv_v0;
+  unsigned long lrv_v1;
+  double lrv_fv0;
+  double lrv_fv1;
+} La_mips_64_retval;
+
+__BEGIN_DECLS
+
+#if _RISCV_SIM == _ABI32
+
+extern Elf32_Addr la_mips_n32_gnu_pltenter (Elf32_Sym *__sym, unsigned int __ndx,
+					    uintptr_t *__refcook,
+					    uintptr_t *__defcook,
+					    La_mips_64_regs *__regs,
+					    unsigned int *__flags,
+					    const char *__symname,
+					    long int *__framesizep);
+extern unsigned int la_mips_n32_gnu_pltexit (Elf32_Sym *__sym, unsigned int __ndx,
+					     uintptr_t *__refcook,
+					     uintptr_t *__defcook,
+					     const La_mips_64_regs *__inregs,
+					     La_mips_64_retval *__outregs,
+					     const char *__symname);
+
+#else
+
+extern Elf64_Addr la_mips_n64_gnu_pltenter (Elf64_Sym *__sym, unsigned int __ndx,
+					    uintptr_t *__refcook,
+					    uintptr_t *__defcook,
+					    La_mips_64_regs *__regs,
+					    unsigned int *__flags,
+					    const char *__symname,
+					    long int *__framesizep);
+extern unsigned int la_mips_n64_gnu_pltexit (Elf64_Sym *__sym, unsigned int __ndx,
+					     uintptr_t *__refcook,
+					     uintptr_t *__defcook,
+					     const La_mips_64_regs *__inregs,
+					     La_mips_64_retval *__outregs,
+					     const char *__symname);
+
+#endif
+
+__END_DECLS
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/bits/linkmap.h glibc-2.14.1/sysdeps/riscv/bits/linkmap.h
--- ../glibc-2.14.1-orig/sysdeps/riscv/bits/linkmap.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/bits/linkmap.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,4 @@
+struct link_map_machine
+  {
+    ElfW(Addr) plt; /* Address of .plt */
+  };
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/bits/mathdef.h glibc-2.14.1/sysdeps/riscv/bits/mathdef.h
--- ../glibc-2.14.1-orig/sysdeps/riscv/bits/mathdef.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/bits/mathdef.h	2011-11-03 18:57:51.000000000 -0700
@@ -0,0 +1,45 @@
+/* Copyright (C) 1997, 1998, 1999, 2000, 2002, 2003, 2004, 2007
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _MATH_H && !defined _COMPLEX_H
+# error "Never use <bits/mathdef.h> directly; include <math.h> instead"
+#endif
+
+#include <sgidefs.h>
+
+#if defined  __USE_ISOC99 && defined _MATH_H && !defined _MATH_H_MATHDEF
+# define _MATH_H_MATHDEF	1
+
+/* MIPS has `float' and `double' operations.  */
+typedef float float_t;		/* `float' expressions are evaluated as
+				   `float'.  */
+typedef double double_t;	/* `double' expressions are evaluated as
+				   `double'.  */
+
+/* The values returned by `ilogb' for 0 and NaN respectively.  */
+# define FP_ILOGB0	(-2147483647)
+# define FP_ILOGBNAN	2147483647
+
+#endif	/* ISO C99 */
+
+#if ! defined __NO_LONG_DOUBLE_MATH && _RISCV_SIM == _ABI32
+/* Signal that we do not really have a `long double'.  This disables the
+   declaration of all the `long double' function variants.  */
+# define __NO_LONG_DOUBLE_MATH	1
+#endif
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/bits/nan.h glibc-2.14.1/sysdeps/riscv/bits/nan.h
--- ../glibc-2.14.1-orig/sysdeps/riscv/bits/nan.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/bits/nan.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,56 @@
+/* `NAN' constant for IEEE 754 machines.
+   Copyright (C) 1992, 1996, 1997, 1999, 2002, 2004
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _MATH_H
+# error "Never use <bits/nan.h> directly; include <math.h> instead."
+#endif
+
+
+/* IEEE Not A Number (QNaN). Note that MIPS has the QNaN and SNaN patterns
+   reversed compared to most other architectures. The IEEE spec left
+   the definition of this open to implementations, and for MIPS the top
+   bit of the mantissa must be SET to indicate a SNaN.  */
+
+#if __GNUC_PREREQ(3,3)
+
+# define NAN	(__builtin_nanf(""))
+
+#elif defined __GNUC__
+
+# define NAN \
+  (__extension__                                                            \
+   ((union { unsigned __l __attribute__((__mode__(__SI__))); float __d; })  \
+    { __l: 0x7fbfffffUL }).__d)
+
+#else
+
+# include <endian.h>
+
+# if __BYTE_ORDER == __BIG_ENDIAN
+#  define __nan_bytes		{ 0x7f, 0xbf, 0xff, 0xff }
+# endif
+# if __BYTE_ORDER == __LITTLE_ENDIAN
+#  define __nan_bytes		{ 0xff, 0xff, 0xbf, 0x7f }
+# endif
+
+static union { unsigned char __c[4]; float __d; } __nan_union = { __nan_bytes };
+# define NAN	(__nan_union.__d)
+
+#endif	/* GCC.  */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/bits/setjmp.h glibc-2.14.1/sysdeps/riscv/bits/setjmp.h
--- ../glibc-2.14.1-orig/sysdeps/riscv/bits/setjmp.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/bits/setjmp.h	2011-11-02 01:20:35.000000000 -0700
@@ -0,0 +1,47 @@
+/* Define the machine-dependent type `jmp_buf'.  RISC-V version.
+   Copyright (C) 1992,1993,1995,1997,2000,2002,2003,2004,2005,2006
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _RISCV_BITS_SETJMP_H
+#define _RISCV_BITS_SETJMP_H
+
+typedef struct __jmp_buf_internal_tag
+  {
+    /* Program counter.  */
+    long __pc;
+
+    /* Stack pointer.  */
+    long __sp;
+
+    /* Thread pointer. */
+    long __tp;
+
+    /* Callee-saved registers s0 through s9.  */
+    long __regs[10];
+
+    /* Floating point status register.  */
+    long __fsr;
+
+    /* Callee-saved floating point registers.
+       Note that there are an even number of preceding words in this struct,
+       so no padding will be inserted before __fpregs, even for RV32. */
+    double __fpregs[10];
+  } __jmp_buf[1];
+
+#endif /* _RISCV_BITS_SETJMP_H */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/bits/wordsize.h glibc-2.14.1/sysdeps/riscv/bits/wordsize.h
--- ../glibc-2.14.1-orig/sysdeps/riscv/bits/wordsize.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/bits/wordsize.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,22 @@
+/* Copyright (C) 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define __WORDSIZE	_RISCV_SZPTR
+#if _RISCV_SIM == _ABI64
+# define __WORDSIZE_COMPAT32	1
+#endif
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/bsd-_setjmp.c glibc-2.14.1/sysdeps/riscv/bsd-_setjmp.c
--- ../glibc-2.14.1-orig/sysdeps/riscv/bsd-_setjmp.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/bsd-_setjmp.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1 @@
+/* _setjmp is implemented in setjmp.S */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/bsd-setjmp.c glibc-2.14.1/sysdeps/riscv/bsd-setjmp.c
--- ../glibc-2.14.1-orig/sysdeps/riscv/bsd-setjmp.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/bsd-setjmp.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1 @@
+/* setjmp is implemented in setjmp.S */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/dl-dtprocnum.h glibc-2.14.1/sysdeps/riscv/dl-dtprocnum.h
--- ../glibc-2.14.1-orig/sysdeps/riscv/dl-dtprocnum.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/dl-dtprocnum.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,22 @@
+/* Configuration of lookup functions.  MIPS version.
+   Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Number of extra dynamic section entries for this architecture.  By
+   default there are none.  */
+#define DT_THISPROCNUM	DT_MIPS_NUM
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/dl-lookup.c glibc-2.14.1/sysdeps/riscv/dl-lookup.c
--- ../glibc-2.14.1-orig/sysdeps/riscv/dl-lookup.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/dl-lookup.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,1033 @@
+/* Look up a symbol in the loaded objects.
+   MIPS/Linux version - special handling of non-PIC undefined symbol rules.
+   Copyright (C) 1995-2005, 2006, 2007, 2009, 2010
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <alloca.h>
+#include <libintl.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <ldsodefs.h>
+#include <dl-hash.h>
+#include <dl-machine.h>
+#include <sysdep-cancel.h>
+#include <bits/libc-lock.h>
+#include <tls.h>
+
+#include <assert.h>
+
+#define VERSTAG(tag)	(DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGIDX (tag))
+
+/* We need this string more than once.  */
+static const char undefined_msg[] = "undefined symbol: ";
+
+
+struct sym_val
+  {
+    const ElfW(Sym) *s;
+    struct link_map *m;
+  };
+
+
+#define make_string(string, rest...) \
+  ({									      \
+    const char *all[] = { string, ## rest };				      \
+    size_t len, cnt;							      \
+    char *result, *cp;							      \
+									      \
+    len = 1;								      \
+    for (cnt = 0; cnt < sizeof (all) / sizeof (all[0]); ++cnt)		      \
+      len += strlen (all[cnt]);						      \
+									      \
+    cp = result = alloca (len);						      \
+    for (cnt = 0; cnt < sizeof (all) / sizeof (all[0]); ++cnt)		      \
+      cp = __stpcpy (cp, all[cnt]);					      \
+									      \
+    result;								      \
+  })
+
+/* Statistics function.  */
+#ifdef SHARED
+# define bump_num_relocations() ++GL(dl_num_relocations)
+#else
+# define bump_num_relocations() ((void) 0)
+#endif
+
+
+/* Inner part of the lookup functions.  We return a value > 0 if we
+   found the symbol, the value 0 if nothing is found and < 0 if
+   something bad happened.  */
+static int
+__attribute_noinline__
+do_lookup_x (const char *undef_name, uint_fast32_t new_hash,
+	     unsigned long int *old_hash, const ElfW(Sym) *ref,
+	     struct sym_val *result, struct r_scope_elem *scope, size_t i,
+	     const struct r_found_version *const version, int flags,
+	     struct link_map *skip, int type_class, struct link_map *undef_map)
+{
+  size_t n = scope->r_nlist;
+  /* Make sure we read the value before proceeding.  Otherwise we
+     might use r_list pointing to the initial scope and r_nlist being
+     the value after a resize.  That is the only path in dl-open.c not
+     protected by GSCOPE.  A read barrier here might be to expensive.  */
+  __asm volatile ("" : "+r" (n), "+m" (scope->r_list));
+  struct link_map **list = scope->r_list;
+
+  do
+    {
+      /* These variables are used in the nested function.  */
+      Elf_Symndx symidx;
+      int num_versions = 0;
+      const ElfW(Sym) *versioned_sym = NULL;
+
+      const struct link_map *map = list[i]->l_real;
+
+      /* Here come the extra test needed for `_dl_lookup_symbol_skip'.  */
+      if (map == skip)
+	continue;
+
+      /* Don't search the executable when resolving a copy reloc.  */
+      if ((type_class & ELF_RTYPE_CLASS_COPY) && map->l_type == lt_executable)
+	continue;
+
+      /* Do not look into objects which are going to be removed.  */
+      if (map->l_removed)
+	continue;
+
+      /* Print some debugging info if wanted.  */
+      if (__builtin_expect (GLRO(dl_debug_mask) & DL_DEBUG_SYMBOLS, 0))
+	_dl_debug_printf ("symbol=%s;  lookup in file=%s [%lu]\n",
+			  undef_name,
+			  map->l_name[0] ? map->l_name : rtld_progname,
+			  map->l_ns);
+
+      /* If the hash table is empty there is nothing to do here.  */
+      if (map->l_nbuckets == 0)
+	continue;
+
+      /* The tables for this map.  */
+      const ElfW(Sym) *symtab = (const void *) D_PTR (map, l_info[DT_SYMTAB]);
+      const char *strtab = (const void *) D_PTR (map, l_info[DT_STRTAB]);
+
+
+      /* Nested routine to check whether the symbol matches.  */
+      const ElfW(Sym) *
+      __attribute_noinline__
+      check_match (const ElfW(Sym) *sym)
+      {
+	unsigned int stt = ELFW(ST_TYPE) (sym->st_info);
+	assert (ELF_RTYPE_CLASS_PLT == 1);
+	/* The semantics of zero/non-zero values of undefined symbols
+	   differs depending on whether the non-PIC ABI is in use.
+	   Under the non-PIC ABI, a non-zero value indicates that
+	   there is an address reference to the symbol and thus it
+	   must always be resolved (except when resolving a jump slot
+	   relocation) to the PLT entry whose address is provided as
+	   the symbol's value; a zero value indicates that this
+	   canonical-address behaviour is not required.  Yet under the
+	   classic MIPS psABI, a zero value indicates that there is an
+	   address reference to the function and the dynamic linker
+	   must resolve the symbol immediately upon loading.  To avoid
+	   conflict, symbols for which the dynamic linker must assume
+	   the non-PIC ABI semantics are marked with the STO_MIPS_PLT
+	   flag.  */
+	if (__builtin_expect ((sym->st_value == 0 /* No value.  */
+			       && stt != STT_TLS)
+			      || (sym->st_shndx == SHN_UNDEF
+				  && !(sym->st_other & STO_MIPS_PLT))
+			      || (type_class & (sym->st_shndx == SHN_UNDEF)),
+			      0))
+	  return NULL;
+
+	/* Ignore all but STT_NOTYPE, STT_OBJECT, STT_FUNC,
+	   STT_COMMON, STT_TLS, and STT_GNU_IFUNC since these are no
+	   code/data definitions.  */
+#define ALLOWED_STT \
+	((1 << STT_NOTYPE) | (1 << STT_OBJECT) | (1 << STT_FUNC) \
+	 | (1 << STT_COMMON) | (1 << STT_TLS) | (1 << STT_GNU_IFUNC))
+	if (__builtin_expect (((1 << stt) & ALLOWED_STT) == 0, 0))
+	  return NULL;
+
+	if (sym != ref && strcmp (strtab + sym->st_name, undef_name))
+	  /* Not the symbol we are looking for.  */
+	  return NULL;
+
+	const ElfW(Half) *verstab = map->l_versyms;
+	if (version != NULL)
+	  {
+	    if (__builtin_expect (verstab == NULL, 0))
+	      {
+		/* We need a versioned symbol but haven't found any.  If
+		   this is the object which is referenced in the verneed
+		   entry it is a bug in the library since a symbol must
+		   not simply disappear.
+
+		   It would also be a bug in the object since it means that
+		   the list of required versions is incomplete and so the
+		   tests in dl-version.c haven't found a problem.*/
+		assert (version->filename == NULL
+			|| ! _dl_name_match_p (version->filename, map));
+
+		/* Otherwise we accept the symbol.  */
+	      }
+	    else
+	      {
+		/* We can match the version information or use the
+		   default one if it is not hidden.  */
+		ElfW(Half) ndx = verstab[symidx] & 0x7fff;
+		if ((map->l_versions[ndx].hash != version->hash
+		     || strcmp (map->l_versions[ndx].name, version->name))
+		    && (version->hidden || map->l_versions[ndx].hash
+			|| (verstab[symidx] & 0x8000)))
+		  /* It's not the version we want.  */
+		  return NULL;
+	      }
+	  }
+	else
+	  {
+	    /* No specific version is selected.  There are two ways we
+	       can got here:
+
+	       - a binary which does not include versioning information
+	       is loaded
+
+	       - dlsym() instead of dlvsym() is used to get a symbol which
+	       might exist in more than one form
+
+	       If the library does not provide symbol version information
+	       there is no problem at at: we simply use the symbol if it
+	       is defined.
+
+	       These two lookups need to be handled differently if the
+	       library defines versions.  In the case of the old
+	       unversioned application the oldest (default) version
+	       should be used.  In case of a dlsym() call the latest and
+	       public interface should be returned.  */
+	    if (verstab != NULL)
+	      {
+		if ((verstab[symidx] & 0x7fff)
+		    >= ((flags & DL_LOOKUP_RETURN_NEWEST) ? 2 : 3))
+		  {
+		    /* Don't accept hidden symbols.  */
+		    if ((verstab[symidx] & 0x8000) == 0
+			&& num_versions++ == 0)
+		      /* No version so far.  */
+		      versioned_sym = sym;
+
+		    return NULL;
+		  }
+	      }
+	  }
+
+	/* There cannot be another entry for this symbol so stop here.  */
+	return sym;
+      }
+
+      const ElfW(Sym) *sym;
+      const ElfW(Addr) *bitmask = map->l_gnu_bitmask;
+      if (__builtin_expect (bitmask != NULL, 1))
+	{
+	  ElfW(Addr) bitmask_word
+	    = bitmask[(new_hash / __ELF_NATIVE_CLASS)
+		      & map->l_gnu_bitmask_idxbits];
+
+	  unsigned int hashbit1 = new_hash & (__ELF_NATIVE_CLASS - 1);
+	  unsigned int hashbit2 = ((new_hash >> map->l_gnu_shift)
+				   & (__ELF_NATIVE_CLASS - 1));
+
+	  if (__builtin_expect ((bitmask_word >> hashbit1)
+				& (bitmask_word >> hashbit2) & 1, 0))
+	    {
+	      Elf32_Word bucket = map->l_gnu_buckets[new_hash
+						     % map->l_nbuckets];
+	      if (bucket != 0)
+		{
+		  const Elf32_Word *hasharr = &map->l_gnu_chain_zero[bucket];
+
+		  do
+		    if (((*hasharr ^ new_hash) >> 1) == 0)
+		      {
+			symidx = hasharr - map->l_gnu_chain_zero;
+			sym = check_match (&symtab[symidx]);
+			if (sym != NULL)
+			  goto found_it;
+		      }
+		  while ((*hasharr++ & 1u) == 0);
+		}
+	    }
+	  /* No symbol found.  */
+	  symidx = SHN_UNDEF;
+	}
+      else
+	{
+	  if (*old_hash == 0xffffffff)
+	    *old_hash = _dl_elf_hash (undef_name);
+
+	  /* Use the old SysV-style hash table.  Search the appropriate
+	     hash bucket in this object's symbol table for a definition
+	     for the same symbol name.  */
+	  for (symidx = map->l_buckets[*old_hash % map->l_nbuckets];
+	       symidx != STN_UNDEF;
+	       symidx = map->l_chain[symidx])
+	    {
+	      sym = check_match (&symtab[symidx]);
+	      if (sym != NULL)
+		goto found_it;
+	    }
+	}
+
+      /* If we have seen exactly one versioned symbol while we are
+	 looking for an unversioned symbol and the version is not the
+	 default version we still accept this symbol since there are
+	 no possible ambiguities.  */
+      sym = num_versions == 1 ? versioned_sym : NULL;
+
+      if (sym != NULL)
+	{
+	found_it:
+	  switch (__builtin_expect (ELFW(ST_BIND) (sym->st_info), STB_GLOBAL))
+	    {
+	    case STB_WEAK:
+	      /* Weak definition.  Use this value if we don't find another.  */
+	      if (__builtin_expect (GLRO(dl_dynamic_weak), 0))
+		{
+		  if (! result->s)
+		    {
+		      result->s = sym;
+		      result->m = (struct link_map *) map;
+		    }
+		  break;
+		}
+	      /* FALLTHROUGH */
+	    case STB_GLOBAL:
+	    success:
+	      /* Global definition.  Just what we need.  */
+	      result->s = sym;
+	      result->m = (struct link_map *) map;
+	      return 1;
+
+	    case STB_GNU_UNIQUE:;
+	      /* We have to determine whether we already found a
+		 symbol with this name before.  If not then we have to
+		 add it to the search table.  If we already found a
+		 definition we have to use it.  */
+	      void enter (struct unique_sym *table, size_t size,
+			  unsigned int hash, const char *name,
+			  const ElfW(Sym) *sym, struct link_map *map)
+	      {
+		size_t idx = hash % size;
+		size_t hash2 = 1 + hash % (size - 2);
+		while (1)
+		  {
+		    if (table[idx].name == NULL)
+		      {
+			table[idx].hashval = hash;
+			table[idx].name = name;
+			if ((type_class & ELF_RTYPE_CLASS_COPY) != 0)
+			  {
+			    table[idx].sym = ref;
+			    table[idx].map = undef_map;
+			  }
+			else
+			  {
+			    table[idx].sym = sym;
+			    table[idx].map = map;
+
+			    if (map->l_type == lt_loaded)
+			      /* Make sure we don't unload this object by
+				 setting the appropriate flag.  */
+			      map->l_flags_1 |= DF_1_NODELETE;
+			  }
+
+			return;
+		      }
+
+		    idx += hash2;
+		    if (idx >= size)
+		      idx -= size;
+		  }
+	      }
+
+	      struct unique_sym_table *tab
+		= &GL(dl_ns)[map->l_ns]._ns_unique_sym_table;
+
+	      __rtld_lock_lock_recursive (tab->lock);
+
+	      struct unique_sym *entries = tab->entries;
+	      size_t size = tab->size;
+	      if (entries != NULL)
+		{
+		  size_t idx = new_hash % size;
+		  size_t hash2 = 1 + new_hash % (size - 2);
+		  while (1)
+		    {
+		      if (entries[idx].hashval == new_hash
+			  && strcmp (entries[idx].name, undef_name) == 0)
+			{
+			  result->s = entries[idx].sym;
+			  result->m = (struct link_map *) entries[idx].map;
+			  __rtld_lock_unlock_recursive (tab->lock);
+			  return 1;
+			}
+
+		      if (entries[idx].name == NULL)
+			break;
+
+		      idx += hash2;
+		      if (idx >= size)
+			idx -= size;
+		    }
+
+		  if (size * 3 <= tab->n_elements * 4)
+		    {
+		      /* Expand the table.  */
+#ifdef RTLD_CHECK_FOREIGN_CALL
+		      /* This must not happen during runtime relocations.  */
+		      assert (!RTLD_CHECK_FOREIGN_CALL);
+#endif
+		      size_t newsize = _dl_higher_prime_number (size + 1);
+		      struct unique_sym *newentries
+			= calloc (sizeof (struct unique_sym), newsize);
+		      if (newentries == NULL)
+			{
+			nomem:
+			  __rtld_lock_unlock_recursive (tab->lock);
+			  _dl_fatal_printf ("out of memory\n");
+			}
+
+		      for (idx = 0; idx < size; ++idx)
+			if (entries[idx].name != NULL)
+			  enter (newentries, newsize, entries[idx].hashval,
+				 entries[idx].name, entries[idx].sym,
+				 entries[idx].map);
+
+		      tab->free (entries);
+		      tab->size = newsize;
+		      size = newsize;
+		      entries = tab->entries = newentries;
+		      tab->free = free;
+		    }
+		}
+	      else
+		{
+#ifdef RTLD_CHECK_FOREIGN_CALL
+		  /* This must not happen during runtime relocations.  */
+		  assert (!RTLD_CHECK_FOREIGN_CALL);
+#endif
+
+#ifdef SHARED
+		  /* If tab->entries is NULL, but tab->size is not, it means
+		     this is the second, conflict finding, lookup for
+		     LD_TRACE_PRELINKING in _dl_debug_bindings.  Don't
+		     allocate anything and don't enter anything into the
+		     hash table.  */
+		  if (__builtin_expect (tab->size, 0))
+		    {
+		      assert (GLRO(dl_debug_mask) & DL_DEBUG_PRELINK);
+		      __rtld_lock_unlock_recursive (tab->lock);
+		      goto success;
+		    }
+#endif
+
+#define INITIAL_NUNIQUE_SYM_TABLE 31
+		  size = INITIAL_NUNIQUE_SYM_TABLE;
+		  entries = calloc (sizeof (struct unique_sym), size);
+		  if (entries == NULL)
+		    goto nomem;
+
+		  tab->entries = entries;
+		  tab->size = size;
+		  tab->free = free;
+		}
+
+	      enter (entries, size, new_hash, strtab + sym->st_name, sym,
+		     (struct link_map *) map);
+	      ++tab->n_elements;
+
+	      __rtld_lock_unlock_recursive (tab->lock);
+
+	      goto success;
+
+	    default:
+	      /* Local symbols are ignored.  */
+	      break;
+	    }
+	}
+
+      /* If this current map is the one mentioned in the verneed entry
+	 and we have not found a weak entry, it is a bug.  */
+      if (symidx == STN_UNDEF && version != NULL && version->filename != NULL
+	  && __builtin_expect (_dl_name_match_p (version->filename, map), 0))
+	return -1;
+    }
+  while (++i < n);
+
+  /* We have not found anything until now.  */
+  return 0;
+}
+
+
+static uint_fast32_t
+dl_new_hash (const char *s)
+{
+  uint_fast32_t h = 5381;
+  for (unsigned char c = *s; c != '\0'; c = *++s)
+    h = h * 33 + c;
+  return h & 0xffffffff;
+}
+
+
+/* Add extra dependency on MAP to UNDEF_MAP.  */
+static int
+internal_function
+add_dependency (struct link_map *undef_map, struct link_map *map, int flags)
+{
+  struct link_map *runp;
+  unsigned int i;
+  int result = 0;
+
+  /* Avoid self-references and references to objects which cannot be
+     unloaded anyway.  */
+  if (undef_map == map)
+    return 0;
+
+  /* Avoid references to objects which cannot be unloaded anyway.  */
+  assert (map->l_type == lt_loaded);
+  if ((map->l_flags_1 & DF_1_NODELETE) != 0)
+    return 0;
+
+  struct link_map_reldeps *l_reldeps
+    = atomic_forced_read (undef_map->l_reldeps);
+
+  /* Make sure l_reldeps is read before l_initfini.  */
+  atomic_read_barrier ();
+
+  /* Determine whether UNDEF_MAP already has a reference to MAP.  First
+     look in the normal dependencies.  */
+  struct link_map **l_initfini = atomic_forced_read (undef_map->l_initfini);
+  if (l_initfini != NULL)
+    {
+      for (i = 0; l_initfini[i] != NULL; ++i)
+	if (l_initfini[i] == map)
+	  return 0;
+    }
+
+  /* No normal dependency.  See whether we already had to add it
+     to the special list of dynamic dependencies.  */
+  unsigned int l_reldepsact = 0;
+  if (l_reldeps != NULL)
+    {
+      struct link_map **list = &l_reldeps->list[0];
+      l_reldepsact = l_reldeps->act;
+      for (i = 0; i < l_reldepsact; ++i)
+	if (list[i] == map)
+	  return 0;
+    }
+
+  /* Save serial number of the target MAP.  */
+  unsigned long long serial = map->l_serial;
+
+  /* Make sure nobody can unload the object while we are at it.  */
+  if (__builtin_expect (flags & DL_LOOKUP_GSCOPE_LOCK, 0))
+    {
+      /* We can't just call __rtld_lock_lock_recursive (GL(dl_load_lock))
+	 here, that can result in ABBA deadlock.  */
+      THREAD_GSCOPE_RESET_FLAG ();
+      __rtld_lock_lock_recursive (GL(dl_load_lock));
+      /* While MAP value won't change, after THREAD_GSCOPE_RESET_FLAG ()
+	 it can e.g. point to unallocated memory.  So avoid the optimizer
+	 treating the above read from MAP->l_serial as ensurance it
+	 can safely dereference it.  */
+      map = atomic_forced_read (map);
+
+      /* From this point on it is unsafe to dereference MAP, until it
+	 has been found in one of the lists.  */
+
+      /* Redo the l_initfini check in case undef_map's l_initfini
+	 changed in the mean time.  */
+      if (undef_map->l_initfini != l_initfini
+	  && undef_map->l_initfini != NULL)
+	{
+	  l_initfini = undef_map->l_initfini;
+	  for (i = 0; l_initfini[i] != NULL; ++i)
+	    if (l_initfini[i] == map)
+	      goto out_check;
+	}
+
+      /* Redo the l_reldeps check if undef_map's l_reldeps changed in
+	 the mean time.  */
+      if (undef_map->l_reldeps != NULL)
+	{
+	  if (undef_map->l_reldeps != l_reldeps)
+	    {
+	      struct link_map **list = &undef_map->l_reldeps->list[0];
+	      l_reldepsact = undef_map->l_reldeps->act;
+	      for (i = 0; i < l_reldepsact; ++i)
+		if (list[i] == map)
+		  goto out_check;
+	    }
+	  else if (undef_map->l_reldeps->act > l_reldepsact)
+	    {
+	      struct link_map **list
+		= &undef_map->l_reldeps->list[0];
+	      i = l_reldepsact;
+	      l_reldepsact = undef_map->l_reldeps->act;
+	      for (; i < l_reldepsact; ++i)
+		if (list[i] == map)
+		  goto out_check;
+	    }
+	}
+    }
+  else
+    __rtld_lock_lock_recursive (GL(dl_load_lock));
+
+  /* The object is not yet in the dependency list.  Before we add
+     it make sure just one more time the object we are about to
+     reference is still available.  There is a brief period in
+     which the object could have been removed since we found the
+     definition.  */
+  runp = GL(dl_ns)[undef_map->l_ns]._ns_loaded;
+  while (runp != NULL && runp != map)
+    runp = runp->l_next;
+
+  if (runp != NULL)
+    {
+      /* The object is still available.  */
+
+      /* MAP could have been dlclosed, freed and then some other dlopened
+	 library could have the same link_map pointer.  */
+      if (map->l_serial != serial)
+	goto out_check;
+
+      /* Redo the NODELETE check, as when dl_load_lock wasn't held
+	 yet this could have changed.  */
+      if ((map->l_flags_1 & DF_1_NODELETE) != 0)
+	goto out;
+
+      /* If the object with the undefined reference cannot be removed ever
+	 just make sure the same is true for the object which contains the
+	 definition.  */
+      if (undef_map->l_type != lt_loaded
+	  || (undef_map->l_flags_1 & DF_1_NODELETE) != 0)
+	{
+	  map->l_flags_1 |= DF_1_NODELETE;
+	  goto out;
+	}
+
+      /* Add the reference now.  */
+      if (__builtin_expect (l_reldepsact >= undef_map->l_reldepsmax, 0))
+	{
+	  /* Allocate more memory for the dependency list.  Since this
+	     can never happen during the startup phase we can use
+	     `realloc'.  */
+	  struct link_map_reldeps *newp;
+	  unsigned int max
+	    = undef_map->l_reldepsmax ? undef_map->l_reldepsmax * 2 : 10;
+
+#ifdef RTLD_PREPARE_FOREIGN_CALL
+	  RTLD_PREPARE_FOREIGN_CALL;
+#endif
+
+	  newp = malloc (sizeof (*newp) + max * sizeof (struct link_map *));
+	  if (newp == NULL)
+	    {
+	      /* If we didn't manage to allocate memory for the list this is
+		 no fatal problem.  We simply make sure the referenced object
+		 cannot be unloaded.  This is semantically the correct
+		 behavior.  */
+	      map->l_flags_1 |= DF_1_NODELETE;
+	      goto out;
+	    }
+	  else
+	    {
+	      if (l_reldepsact)
+		memcpy (&newp->list[0], &undef_map->l_reldeps->list[0],
+			l_reldepsact * sizeof (struct link_map *));
+	      newp->list[l_reldepsact] = map;
+	      newp->act = l_reldepsact + 1;
+	      atomic_write_barrier ();
+	      void *old = undef_map->l_reldeps;
+	      undef_map->l_reldeps = newp;
+	      undef_map->l_reldepsmax = max;
+	      if (old)
+		_dl_scope_free (old);
+	    }
+	}
+      else
+	{
+	  undef_map->l_reldeps->list[l_reldepsact] = map;
+	  atomic_write_barrier ();
+	  undef_map->l_reldeps->act = l_reldepsact + 1;
+	}
+
+      /* Display information if we are debugging.  */
+      if (__builtin_expect (GLRO(dl_debug_mask) & DL_DEBUG_FILES, 0))
+	_dl_debug_printf ("\
+\nfile=%s [%lu];  needed by %s [%lu] (relocation dependency)\n\n",
+			  map->l_name[0] ? map->l_name : rtld_progname,
+			  map->l_ns,
+			  undef_map->l_name[0]
+			  ? undef_map->l_name : rtld_progname,
+			  undef_map->l_ns);
+    }
+  else
+    /* Whoa, that was bad luck.  We have to search again.  */
+    result = -1;
+
+ out:
+  /* Release the lock.  */
+  __rtld_lock_unlock_recursive (GL(dl_load_lock));
+
+  if (__builtin_expect (flags & DL_LOOKUP_GSCOPE_LOCK, 0))
+    THREAD_GSCOPE_SET_FLAG ();
+
+  return result;
+
+ out_check:
+  if (map->l_serial != serial)
+    result = -1;
+  goto out;
+}
+
+static void
+internal_function
+_dl_debug_bindings (const char *undef_name, struct link_map *undef_map,
+		    const ElfW(Sym) **ref, struct sym_val *value,
+		    const struct r_found_version *version, int type_class,
+		    int protected);
+
+
+/* Search loaded objects' symbol tables for a definition of the symbol
+   UNDEF_NAME, perhaps with a requested version for the symbol.
+
+   We must never have calls to the audit functions inside this function
+   or in any function which gets called.  If this would happen the audit
+   code might create a thread which can throw off all the scope locking.  */
+lookup_t
+internal_function
+_dl_lookup_symbol_x (const char *undef_name, struct link_map *undef_map,
+		     const ElfW(Sym) **ref,
+		     struct r_scope_elem *symbol_scope[],
+		     const struct r_found_version *version,
+		     int type_class, int flags, struct link_map *skip_map)
+{
+  const uint_fast32_t new_hash = dl_new_hash (undef_name);
+  unsigned long int old_hash = 0xffffffff;
+  struct sym_val current_value = { NULL, NULL };
+  struct r_scope_elem **scope = symbol_scope;
+
+  bump_num_relocations ();
+
+  /* No other flag than DL_LOOKUP_ADD_DEPENDENCY or DL_LOOKUP_GSCOPE_LOCK
+     is allowed if we look up a versioned symbol.  */
+  assert (version == NULL
+	  || (flags & ~(DL_LOOKUP_ADD_DEPENDENCY | DL_LOOKUP_GSCOPE_LOCK))
+	     == 0);
+
+  size_t i = 0;
+  if (__builtin_expect (skip_map != NULL, 0))
+    /* Search the relevant loaded objects for a definition.  */
+    while ((*scope)->r_list[i] != skip_map)
+      ++i;
+
+  /* Search the relevant loaded objects for a definition.  */
+  for (size_t start = i; *scope != NULL; start = 0, ++scope)
+    {
+      int res = do_lookup_x (undef_name, new_hash, &old_hash, *ref,
+			     &current_value, *scope, start, version, flags,
+			     skip_map, type_class, undef_map);
+      if (res > 0)
+	break;
+
+      if (__builtin_expect (res, 0) < 0 && skip_map == NULL)
+	{
+	  /* Oh, oh.  The file named in the relocation entry does not
+	     contain the needed symbol.  This code is never reached
+	     for unversioned lookups.  */
+	  assert (version != NULL);
+	  const char *reference_name = undef_map ? undef_map->l_name : NULL;
+
+	  /* XXX We cannot translate the message.  */
+	  _dl_signal_cerror (0, (reference_name[0]
+				 ? reference_name
+				 : (rtld_progname ?: "<main program>")),
+			     N_("relocation error"),
+			     make_string ("symbol ", undef_name, ", version ",
+					  version->name,
+					  " not defined in file ",
+					  version->filename,
+					  " with link time reference",
+					  res == -2
+					  ? " (no version symbols)" : ""));
+	  *ref = NULL;
+	  return 0;
+	}
+    }
+
+  if (__builtin_expect (current_value.s == NULL, 0))
+    {
+      if ((*ref == NULL || ELFW(ST_BIND) ((*ref)->st_info) != STB_WEAK)
+	  && skip_map == NULL)
+	{
+	  /* We could find no value for a strong reference.  */
+	  const char *reference_name = undef_map ? undef_map->l_name : "";
+	  const char *versionstr = version ? ", version " : "";
+	  const char *versionname = (version && version->name
+				     ? version->name : "");
+
+	  /* XXX We cannot translate the message.  */
+	  _dl_signal_cerror (0, (reference_name[0]
+				 ? reference_name
+				 : (rtld_progname ?: "<main program>")),
+			     N_("symbol lookup error"),
+			     make_string (undefined_msg, undef_name,
+					  versionstr, versionname));
+	}
+      *ref = NULL;
+      return 0;
+    }
+
+  int protected = (*ref
+		   && ELFW(ST_VISIBILITY) ((*ref)->st_other) == STV_PROTECTED);
+  if (__builtin_expect (protected != 0, 0))
+    {
+      /* It is very tricky.  We need to figure out what value to
+	 return for the protected symbol.  */
+      if (type_class == ELF_RTYPE_CLASS_PLT)
+	{
+	  if (current_value.s != NULL && current_value.m != undef_map)
+	    {
+	      current_value.s = *ref;
+	      current_value.m = undef_map;
+	    }
+	}
+      else
+	{
+	  struct sym_val protected_value = { NULL, NULL };
+
+	  for (scope = symbol_scope; *scope != NULL; i = 0, ++scope)
+	    if (do_lookup_x (undef_name, new_hash, &old_hash, *ref,
+			     &protected_value, *scope, i, version, flags,
+			     skip_map, ELF_RTYPE_CLASS_PLT, NULL) != 0)
+	      break;
+
+	  if (protected_value.s != NULL && protected_value.m != undef_map)
+	    {
+	      current_value.s = *ref;
+	      current_value.m = undef_map;
+	    }
+	}
+    }
+
+  /* We have to check whether this would bind UNDEF_MAP to an object
+     in the global scope which was dynamically loaded.  In this case
+     we have to prevent the latter from being unloaded unless the
+     UNDEF_MAP object is also unloaded.  */
+  if (__builtin_expect (current_value.m->l_type == lt_loaded, 0)
+      /* Don't do this for explicit lookups as opposed to implicit
+	 runtime lookups.  */
+      && (flags & DL_LOOKUP_ADD_DEPENDENCY) != 0
+      /* Add UNDEF_MAP to the dependencies.  */
+      && add_dependency (undef_map, current_value.m, flags) < 0)
+      /* Something went wrong.  Perhaps the object we tried to reference
+	 was just removed.  Try finding another definition.  */
+      return _dl_lookup_symbol_x (undef_name, undef_map, ref,
+				  (flags & DL_LOOKUP_GSCOPE_LOCK)
+				  ? undef_map->l_scope : symbol_scope,
+				  version, type_class, flags, skip_map);
+
+  /* The object is used.  */
+  if (__builtin_expect (current_value.m->l_used == 0, 0))
+    current_value.m->l_used = 1;
+
+  if (__builtin_expect (GLRO(dl_debug_mask)
+			& (DL_DEBUG_BINDINGS|DL_DEBUG_PRELINK), 0))
+    _dl_debug_bindings (undef_name, undef_map, ref,
+			&current_value, version, type_class, protected);
+
+  *ref = current_value.s;
+  return LOOKUP_VALUE (current_value.m);
+}
+
+
+/* Cache the location of MAP's hash table.  */
+
+void
+internal_function
+_dl_setup_hash (struct link_map *map)
+{
+  Elf_Symndx *hash;
+  Elf_Symndx nchain;
+
+  if (__builtin_expect (map->l_info[DT_ADDRTAGIDX (DT_GNU_HASH) + DT_NUM
+				    + DT_THISPROCNUM + DT_VERSIONTAGNUM
+				    + DT_EXTRANUM + DT_VALNUM] != NULL, 1))
+    {
+      Elf32_Word *hash32
+	= (void *) D_PTR (map, l_info[DT_ADDRTAGIDX (DT_GNU_HASH) + DT_NUM
+				      + DT_THISPROCNUM + DT_VERSIONTAGNUM
+				      + DT_EXTRANUM + DT_VALNUM]);
+      map->l_nbuckets = *hash32++;
+      Elf32_Word symbias = *hash32++;
+      Elf32_Word bitmask_nwords = *hash32++;
+      /* Must be a power of two.  */
+      assert ((bitmask_nwords & (bitmask_nwords - 1)) == 0);
+      map->l_gnu_bitmask_idxbits = bitmask_nwords - 1;
+      map->l_gnu_shift = *hash32++;
+
+      map->l_gnu_bitmask = (ElfW(Addr) *) hash32;
+      hash32 += __ELF_NATIVE_CLASS / 32 * bitmask_nwords;
+
+      map->l_gnu_buckets = hash32;
+      hash32 += map->l_nbuckets;
+      map->l_gnu_chain_zero = hash32 - symbias;
+      return;
+    }
+
+  if (!map->l_info[DT_HASH])
+    return;
+  hash = (void *) D_PTR (map, l_info[DT_HASH]);
+
+  map->l_nbuckets = *hash++;
+  nchain = *hash++;
+  map->l_buckets = hash;
+  hash += map->l_nbuckets;
+  map->l_chain = hash;
+}
+
+
+static void
+internal_function
+_dl_debug_bindings (const char *undef_name, struct link_map *undef_map,
+		    const ElfW(Sym) **ref, struct sym_val *value,
+		    const struct r_found_version *version, int type_class,
+		    int protected)
+{
+  const char *reference_name = undef_map->l_name;
+
+  if (GLRO(dl_debug_mask) & DL_DEBUG_BINDINGS)
+    {
+      _dl_debug_printf ("binding file %s [%lu] to %s [%lu]: %s symbol `%s'",
+			(reference_name[0]
+			 ? reference_name
+			 : (rtld_progname ?: "<main program>")),
+			undef_map->l_ns,
+			value->m->l_name[0] ? value->m->l_name : rtld_progname,
+			value->m->l_ns,
+			protected ? "protected" : "normal", undef_name);
+      if (version)
+	_dl_debug_printf_c (" [%s]\n", version->name);
+      else
+	_dl_debug_printf_c ("\n");
+    }
+#ifdef SHARED
+  if (GLRO(dl_debug_mask) & DL_DEBUG_PRELINK)
+    {
+      int conflict = 0;
+      struct sym_val val = { NULL, NULL };
+
+      if ((GLRO(dl_trace_prelink_map) == NULL
+	   || GLRO(dl_trace_prelink_map) == GL(dl_ns)[LM_ID_BASE]._ns_loaded)
+	  && undef_map != GL(dl_ns)[LM_ID_BASE]._ns_loaded)
+	{
+	  const uint_fast32_t new_hash = dl_new_hash (undef_name);
+	  unsigned long int old_hash = 0xffffffff;
+	  struct unique_sym *saved_entries
+	    = GL(dl_ns)[LM_ID_BASE]._ns_unique_sym_table.entries;
+
+	  GL(dl_ns)[LM_ID_BASE]._ns_unique_sym_table.entries = NULL;
+	  do_lookup_x (undef_name, new_hash, &old_hash, *ref, &val,
+		       undef_map->l_local_scope[0], 0, version, 0, NULL,
+		       type_class, undef_map);
+	  if (val.s != value->s || val.m != value->m)
+	    conflict = 1;
+	  else if (__builtin_expect (undef_map->l_symbolic_in_local_scope, 0)
+		   && val.s
+		   && __builtin_expect (ELFW(ST_BIND) (val.s->st_info),
+					STB_GLOBAL) == STB_GNU_UNIQUE)
+	    {
+	      /* If it is STB_GNU_UNIQUE and undef_map's l_local_scope
+		 contains any DT_SYMBOLIC libraries, unfortunately there
+		 can be conflicts even if the above is equal.  As symbol
+		 resolution goes from the last library to the first and
+		 if a STB_GNU_UNIQUE symbol is found in some late DT_SYMBOLIC
+		 library, it would be the one that is looked up.  */
+	      struct sym_val val2 = { NULL, NULL };
+	      size_t n;
+	      struct r_scope_elem *scope = undef_map->l_local_scope[0];
+
+	      for (n = 0; n < scope->r_nlist; n++)
+		if (scope->r_list[n] == val.m)
+		  break;
+
+	      for (n++; n < scope->r_nlist; n++)
+		if (scope->r_list[n]->l_info[DT_SYMBOLIC] != NULL
+		    && do_lookup_x (undef_name, new_hash, &old_hash, *ref,
+				    &val2,
+				    &scope->r_list[n]->l_symbolic_searchlist,
+				    0, version, 0, NULL, type_class,
+				    undef_map) > 0)
+		  {
+		    conflict = 1;
+		    val = val2;
+		    break;
+		  }
+	    }
+	  GL(dl_ns)[LM_ID_BASE]._ns_unique_sym_table.entries = saved_entries;
+	}
+
+      if (value->s)
+	{
+	  if (__builtin_expect (ELFW(ST_TYPE) (value->s->st_info)
+				== STT_TLS, 0))
+	    type_class = 4;
+	  else if (__builtin_expect (ELFW(ST_TYPE) (value->s->st_info)
+				     == STT_GNU_IFUNC, 0))
+	    type_class |= 8;
+	}
+
+      if (conflict
+	  || GLRO(dl_trace_prelink_map) == undef_map
+	  || GLRO(dl_trace_prelink_map) == NULL
+	  || type_class >= 4)
+	{
+	  _dl_printf ("%s 0x%0*Zx 0x%0*Zx -> 0x%0*Zx 0x%0*Zx ",
+		      conflict ? "conflict" : "lookup",
+		      (int) sizeof (ElfW(Addr)) * 2,
+		      (size_t) undef_map->l_map_start,
+		      (int) sizeof (ElfW(Addr)) * 2,
+		      (size_t) (((ElfW(Addr)) *ref) - undef_map->l_map_start),
+		      (int) sizeof (ElfW(Addr)) * 2,
+		      (size_t) (value->s ? value->m->l_map_start : 0),
+		      (int) sizeof (ElfW(Addr)) * 2,
+		      (size_t) (value->s ? value->s->st_value : 0));
+
+	  if (conflict)
+	    _dl_printf ("x 0x%0*Zx 0x%0*Zx ",
+			(int) sizeof (ElfW(Addr)) * 2,
+			(size_t) (val.s ? val.m->l_map_start : 0),
+			(int) sizeof (ElfW(Addr)) * 2,
+			(size_t) (val.s ? val.s->st_value : 0));
+
+	  _dl_printf ("/%x %s\n", type_class, undef_name);
+	}
+    }
+#endif
+}
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/dl-machine.h glibc-2.14.1/sysdeps/riscv/dl-machine.h
--- ../glibc-2.14.1-orig/sysdeps/riscv/dl-machine.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/dl-machine.h	2011-11-03 19:07:06.000000000 -0700
@@ -0,0 +1,740 @@
+/* Machine-dependent ELF dynamic relocation inline functions.  MIPS version.
+   Copyright (C) 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Kazumoto Kojima <kkojima@info.kanagawa-u.ac.jp>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*  FIXME: Profiling of shared libraries is not implemented yet.  */
+#ifndef dl_machine_h
+#define dl_machine_h
+
+#define ELF_MACHINE_NAME "RISC-V"
+
+#include <entry.h>
+
+#ifndef ENTRY_POINT
+#error ENTRY_POINT needs to be defined for MIPS.
+#endif
+
+#include <sys/asm.h>
+#include <dl-tls.h>
+
+/* The offset of gp from GOT might be system-dependent.  It's set by
+   ld.  The same value is also */
+#define OFFSET_GP_GOT 0x7f0
+
+#ifndef _RTLD_PROLOGUE
+# define _RTLD_PROLOGUE(entry)						\
+	".globl\t" __STRING(entry) "\n\t"				\
+	".ent\t" __STRING(entry) "\n\t"					\
+	".type\t" __STRING(entry) ", @function\n"			\
+	__STRING(entry) ":\n\t"
+#endif
+
+#ifndef _RTLD_EPILOGUE
+# define _RTLD_EPILOGUE(entry)						\
+	".end\t" __STRING(entry) "\n\t"					\
+	".size\t" __STRING(entry) ", . - " __STRING(entry) "\n\t"
+#endif
+
+/* A reloc type used for ld.so cmdline arg lookups to reject PLT entries.
+   This only makes sense on MIPS when using PLTs, so choose the
+   PLT relocation (not encountered when not using PLTs).  */
+#define ELF_MACHINE_JMP_SLOT			R_MIPS_JUMP_SLOT
+#define elf_machine_type_class(type) \
+  ((((type) == ELF_MACHINE_JMP_SLOT) * ELF_RTYPE_CLASS_PLT)	\
+   | (((type) == R_MIPS_COPY) * ELF_RTYPE_CLASS_COPY))
+
+#define ELF_MACHINE_PLT_REL 1
+
+/* Translate a processor specific dynamic tag to the index
+   in l_info array.  */
+#define DT_MIPS(x) (DT_MIPS_##x - DT_LOPROC + DT_NUM)
+
+/* If there is a DT_MIPS_RLD_MAP entry in the dynamic section, fill it in
+   with the run-time address of the r_debug structure  */
+#define ELF_MACHINE_DEBUG_SETUP(l,r) \
+do { if ((l)->l_info[DT_MIPS (RLD_MAP)]) \
+       *(ElfW(Addr) *)((l)->l_info[DT_MIPS (RLD_MAP)]->d_un.d_ptr) = \
+       (ElfW(Addr)) (r); \
+   } while (0)
+
+/* Return nonzero iff ELF header is compatible with the running host.  */
+static inline int __attribute_used__
+elf_machine_matches_host (const ElfW(Ehdr) *ehdr)
+{
+  return 1;
+}
+
+static inline ElfW(Addr) *
+elf_mips_got_from_gpreg (ElfW(Addr) gpreg)
+{
+  return (ElfW(Addr) *) (gpreg - OFFSET_GP_GOT);
+}
+
+/* Return the link-time address of _DYNAMIC.  Conveniently, this is the
+   first element of the GOT.  This must be inlined in a function which
+   uses global data.  */
+static inline ElfW(Addr)
+elf_machine_dynamic (void)
+{
+  ElfW(Addr) tmp, gp;
+  asm ("   rdnpc %0\n"
+       "1: lui   %1, %%hi(%%neg(%%gp_rel(1b)))\n"
+       "   add   %1, %1, %0\n"
+       "   addi  %1, %1, %%lo(%%neg(%%gp_rel(1b)))\n"
+       : "=r"(tmp), "=r"(gp));
+
+  return *elf_mips_got_from_gpreg (gp);
+}
+
+#define STRINGXP(X) __STRING(X)
+#define STRINGXV(X) STRINGV_(X)
+#define STRINGV_(...) # __VA_ARGS__
+
+/* Return the run-time load address of the shared object.  */
+static inline ElfW(Addr)
+elf_machine_load_address (void)
+{
+  ElfW(Addr) load, link, tmp;
+  asm ("   rdnpc %0\n"
+       "1: lui   %1, %%hi(%%neg(%%gp_rel(1b)))\n"
+       "   add   %1, %1, %0\n"
+       "   addi  %1, %1, %%lo(%%neg(%%gp_rel(1b)))\n"
+       "   lui   %2, %%got_hi(1b)\n"
+       "   add   %2, %2, %1\n"
+       STRINGXP(REG_L) " %1, %%got_lo(1b)(%2)"
+       : "=r"(load), "=r"(link), "=r"(tmp));
+
+  return load - link;
+}
+
+/* The MSB of got[1] of a gnu object is set to identify gnu objects.  */
+#ifdef __riscv64
+# define ELF_MIPS_GNU_GOT1_MASK	0x8000000000000000L
+#else
+# define ELF_MIPS_GNU_GOT1_MASK	0x80000000L
+#endif
+
+/* We can't rely on elf_machine_got_rel because _dl_object_relocation_scope
+   fiddles with global data.  */
+#define ELF_MACHINE_BEFORE_RTLD_RELOC(dynamic_info)			\
+do {									\
+  struct link_map *map = &bootstrap_map;				\
+  ElfW(Sym) *sym;							\
+  ElfW(Addr) *got;							\
+  int i, n;								\
+									\
+  got = (ElfW(Addr) *) D_PTR (map, l_info[DT_PLTGOT]);			\
+									\
+  if (__builtin_expect (map->l_addr == 0, 1))				\
+    break;								\
+									\
+  /* got[0] is reserved. got[1] is also reserved for the dynamic object	\
+     generated by gnu ld. Skip these reserved entries from		\
+     relocation.  */							\
+  i = (got[1] & ELF_MIPS_GNU_GOT1_MASK)? 2 : 1;				\
+  n = map->l_info[DT_MIPS (LOCAL_GOTNO)]->d_un.d_val;			\
+									\
+  /* Add the run-time displacement to all local got entries. */		\
+  while (i < n)								\
+    got[i++] += map->l_addr;						\
+									\
+  /* Handle global got entries. */					\
+  got += n;								\
+  sym = (ElfW(Sym) *) D_PTR(map, l_info[DT_SYMTAB])			\
+       + map->l_info[DT_MIPS (GOTSYM)]->d_un.d_val;			\
+  i = (map->l_info[DT_MIPS (SYMTABNO)]->d_un.d_val			\
+       - map->l_info[DT_MIPS (GOTSYM)]->d_un.d_val);			\
+									\
+  while (i--)								\
+    {									\
+      if (sym->st_shndx == SHN_UNDEF || sym->st_shndx == SHN_COMMON)	\
+	*got = map->l_addr + sym->st_value;				\
+      else if (ELFW(ST_TYPE) (sym->st_info) == STT_FUNC			\
+	       && *got != sym->st_value)				\
+	*got += map->l_addr;						\
+      else if (ELFW(ST_TYPE) (sym->st_info) == STT_SECTION)		\
+	{								\
+	  if (sym->st_other == 0)					\
+	    *got += map->l_addr;					\
+	}								\
+      else								\
+	*got = map->l_addr + sym->st_value;				\
+									\
+      got++;								\
+      sym++;								\
+    }									\
+} while(0)
+
+
+/* Mask identifying addresses reserved for the user program,
+   where the dynamic linker should not map anything.  */
+#define ELF_MACHINE_USER_ADDRESS_MASK	0x80000000UL
+
+
+/* Initial entry point code for the dynamic linker.
+   The C function `_dl_start' is the real entry point;
+   its return value is the user program's entry point. */
+
+#define RTLD_START asm (\
+	".text\n\
+	" _RTLD_PROLOGUE(ENTRY_POINT) "\
+	" STRINGXV(SETUP_GPX64(gp, t7)) "\n\
+	# i386 ABI book says that the first entry of GOT holds\n\
+	# the address of the dynamic structure. Though MIPS ABI\n\
+	# doesn't say nothing about this, I emulate this here.\n\
+	" STRINGXV(PIC_LA(a0, gp, _DYNAMIC)) "\n\
+	# Subtract OFFSET_GP_GOT\n\
+	" STRINGXP(REG_S) " a0, -" STRINGXP(OFFSET_GP_GOT) "(gp)\n\
+	move a0, sp\n\
+	rdnpc t0\n\
+.Lcoff: \n\
+	" STRINGXV(PIC_LA(t1, gp, .Lcoff)) "\n\
+	" STRINGXV(PIC_LA(t7, gp, _dl_start)) "\n\
+	sub  t0, t0, t1\n\
+	add  t7, t7, t0\n\
+	jalr t7\n\
+	# Fall through to _dl_start_user \
+	" _RTLD_EPILOGUE(ENTRY_POINT) "\
+	\n\
+	\n\
+	" _RTLD_PROLOGUE(_dl_start_user) "\
+	" STRINGXV(SETUP_GPX64(gp, t7)) "\n\
+	# Save the user entry point address in a saved register.\n\
+	move s0, v0\n\
+	# See if we were run as a command with the executable file\n\
+	# name as an extra leading argument.\n\
+	" STRINGXV(PIC_LA(v0, gp, _dl_skip_args)) "\n\
+	lw v0, 0(v0)\n\
+	beqz v0, 1f\n\
+	# Load the original argument count.\n\
+	" STRINGXP(REG_L) " a0, 0(sp)\n\
+	# Subtract _dl_skip_args from it.\n\
+	sub a0, a0, v0\n\
+	# Adjust the stack pointer to skip _dl_skip_args words.\n\
+	sll v0, v0, " STRINGXP (PTRLOG) "\n\
+	add sp, sp, v0\n\
+	# Save back the modified argument count.\n\
+	" STRINGXP(REG_S) " a0, 0(sp)\n\
+1:	# Call _dl_init (struct link_map *main_map, int argc, char **argv, char **env) \n\
+	" STRINGXV(PIC_LA(a0, gp, _rtld_local)) "\n\
+	" STRINGXP(REG_L) " a0, 0(a0)\n\
+	" STRINGXP(REG_L) " a1, 0(sp)\n\
+	add a2, sp, " STRINGXP (PTRSIZE) "\n\
+	sll a3, a1, " STRINGXP (PTRLOG) "\n\
+	add a3, a3, a2\n\
+	add a3, a3, " STRINGXP (PTRSIZE) "\n\
+	# Make sure the stack pointer is aligned for _dl_init_internal.\n\
+	and v0, sp, -2 * " STRINGXP(SZREG) "\n\
+	move s3, sp\n\
+	add sp, v0, -32\n\
+	# Call the function to run the initializers.\n\
+	" STRINGXV(PIC_LA(t7, gp, _dl_init_internal)) "\n\
+	jalr t7\n\
+	# Restore the stack pointer for _start.\n\
+	move sp, s3\n\
+	# Pass our finalizer function to the user in v0 as per ELF ABI.\n\
+	" STRINGXV(PIC_LA(v0, gp, _dl_fini)) "\n\
+	# Jump to the user entry point.\n\
+	move t7, s0\n\
+	jr t7\n\t"\
+	_RTLD_EPILOGUE(_dl_start_user)\
+	".previous"\
+);
+
+/* Names of the architecture-specific auditing callback functions.  */
+# ifdef __riscv64
+#  define ARCH_LA_PLTENTER mips_n64_gnu_pltenter
+#  define ARCH_LA_PLTEXIT mips_n64_gnu_pltexit
+# else
+#  define ARCH_LA_PLTENTER mips_n32_gnu_pltenter
+#  define ARCH_LA_PLTEXIT mips_n32_gnu_pltexit
+# endif
+
+/* For a non-writable PLT, rewrite the .got.plt entry at RELOC_ADDR to
+   point at the symbol with address VALUE.  For a writable PLT, rewrite
+   the corresponding PLT entry instead.  */
+static inline ElfW(Addr)
+elf_machine_fixup_plt (struct link_map *map, lookup_t t,
+		       const ElfW(Rel) *reloc,
+		       ElfW(Addr) *reloc_addr, ElfW(Addr) value)
+{
+  return *reloc_addr = value;
+}
+
+static inline ElfW(Addr)
+elf_machine_plt_value (struct link_map *map, const ElfW(Rel) *reloc,
+		       ElfW(Addr) value)
+{
+  return value;
+}
+
+#endif /* !dl_machine_h */
+
+#ifdef RESOLVE_MAP
+
+/* Perform a relocation described by R_INFO at the location pointed to
+   by RELOC_ADDR.  SYM is the relocation symbol specified by R_INFO and
+   MAP is the object containing the reloc.  */
+
+auto inline void
+__attribute__ ((always_inline))
+elf_machine_reloc (struct link_map *map, ElfW(Addr) r_info,
+		   const ElfW(Sym) *sym, const struct r_found_version *version,
+		   void *reloc_addr, ElfW(Addr) r_addend, int inplace_p)
+{
+  const unsigned long int r_type = ELFW(R_TYPE) (r_info);
+  ElfW(Addr) *addr_field = (ElfW(Addr) *) reloc_addr;
+
+#if !defined RTLD_BOOTSTRAP && !defined SHARED
+  /* This is defined in rtld.c, but nowhere in the static libc.a;
+     make the reference weak so static programs can still link.  This
+     declaration cannot be done when compiling rtld.c (i.e.  #ifdef
+     RTLD_BOOTSTRAP) because rtld.c contains the common defn for
+     _dl_rtld_map, which is incompatible with a weak decl in the same
+     file.  */
+  weak_extern (GL(dl_rtld_map));
+#endif
+
+  switch (r_type)
+    {
+#if defined (USE_TLS) && !defined (RTLD_BOOTSTRAP)
+# if _RISCV_SIM == _ABI64
+    case R_MIPS_TLS_DTPMOD64:
+    case R_MIPS_TLS_DTPREL64:
+    case R_MIPS_TLS_TPREL64:
+# else
+    case R_MIPS_TLS_DTPMOD32:
+    case R_MIPS_TLS_DTPREL32:
+    case R_MIPS_TLS_TPREL32:
+# endif
+      {
+	struct link_map *sym_map = RESOLVE_MAP (&sym, version, r_type);
+
+	switch (r_type)
+	  {
+	  case R_MIPS_TLS_DTPMOD64:
+	  case R_MIPS_TLS_DTPMOD32:
+	    if (sym_map)
+	      *addr_field = sym_map->l_tls_modid;
+	    break;
+
+	  case R_MIPS_TLS_DTPREL64:
+	  case R_MIPS_TLS_DTPREL32:
+	    if (sym)
+	      {
+		if (inplace_p)
+		  r_addend = *addr_field;
+		*addr_field = r_addend + TLS_DTPREL_VALUE (sym);
+	      }
+	    break;
+
+	  case R_MIPS_TLS_TPREL32:
+	  case R_MIPS_TLS_TPREL64:
+	    if (sym)
+	      {
+		CHECK_STATIC_TLS (map, sym_map);
+		if (inplace_p)
+		  r_addend = *addr_field;
+		*addr_field = r_addend + TLS_TPREL_VALUE (sym_map, sym);
+	      }
+	    break;
+	  }
+
+	break;
+      }
+#endif
+
+#if _RISCV_SIM == _ABI64
+    case (R_MIPS_64 << 8) | R_MIPS_REL32:
+#else
+    case R_MIPS_REL32:
+#endif
+      {
+	int symidx = ELFW(R_SYM) (r_info);
+	ElfW(Addr) reloc_value;
+
+	if (inplace_p)
+	  /* Support relocations on mis-aligned offsets.  */
+	  __builtin_memcpy (&reloc_value, reloc_addr, sizeof (reloc_value));
+	else
+	  reloc_value = r_addend;
+
+	if (symidx)
+	  {
+	    const ElfW(Word) gotsym
+	      = (const ElfW(Word)) map->l_info[DT_MIPS (GOTSYM)]->d_un.d_val;
+
+	    if ((ElfW(Word))symidx < gotsym)
+	      {
+		/* This wouldn't work for a symbol imported from other
+		   libraries for which there's no GOT entry, but MIPS
+		   requires every symbol referenced in a dynamic
+		   relocation to have a GOT entry in the primary GOT,
+		   so we only get here for locally-defined symbols.
+		   For section symbols, we should *NOT* be adding
+		   sym->st_value (per the definition of the meaning of
+		   S in reloc expressions in the ELF64 MIPS ABI),
+		   since it should have already been added to
+		   reloc_value by the linker, but older versions of
+		   GNU ld didn't add it, and newer versions don't emit
+		   useless relocations to section symbols any more, so
+		   it is safe to keep on adding sym->st_value, even
+		   though it's not ABI compliant.  Some day we should
+		   bite the bullet and stop doing this.  */
+#ifndef RTLD_BOOTSTRAP
+		if (map != &GL(dl_rtld_map))
+#endif
+		  reloc_value += sym->st_value + map->l_addr;
+	      }
+	    else
+	      {
+#ifndef RTLD_BOOTSTRAP
+		const ElfW(Addr) *got
+		  = (const ElfW(Addr) *) D_PTR (map, l_info[DT_PLTGOT]);
+		const ElfW(Word) local_gotno
+		  = (const ElfW(Word))
+		    map->l_info[DT_MIPS (LOCAL_GOTNO)]->d_un.d_val;
+
+		reloc_value += got[symidx + local_gotno - gotsym];
+#endif
+	      }
+	  }
+	else
+#ifndef RTLD_BOOTSTRAP
+	  if (map != &GL(dl_rtld_map))
+#endif
+	    reloc_value += map->l_addr;
+
+	__builtin_memcpy (reloc_addr, &reloc_value, sizeof (reloc_value));
+      }
+      break;
+#ifndef RTLD_BOOTSTRAP
+#if _RISCV_SIM == _ABI64
+    case (R_MIPS_64 << 8) | R_MIPS_GLOB_DAT:
+#else
+    case R_MIPS_GLOB_DAT:
+#endif
+      {
+	int symidx = ELFW(R_SYM) (r_info);
+	const ElfW(Word) gotsym
+	  = (const ElfW(Word)) map->l_info[DT_MIPS (GOTSYM)]->d_un.d_val;
+
+	if (__builtin_expect ((ElfW(Word)) symidx >= gotsym, 1))
+	  {
+	    const ElfW(Addr) *got
+	      = (const ElfW(Addr) *) D_PTR (map, l_info[DT_PLTGOT]);
+	    const ElfW(Word) local_gotno
+	      = ((const ElfW(Word))
+		 map->l_info[DT_MIPS (LOCAL_GOTNO)]->d_un.d_val);
+
+	    ElfW(Addr) reloc_value = got[symidx + local_gotno - gotsym];
+	    __builtin_memcpy (reloc_addr, &reloc_value, sizeof (reloc_value));
+	  }
+      }
+      break;
+#endif
+    case R_MIPS_NONE:		/* Alright, Wilbur.  */
+      break;
+
+    case R_MIPS_JUMP_SLOT:
+      {
+	struct link_map *sym_map;
+	ElfW(Addr) value;
+
+	/* The addend for a jump slot relocation must always be zero:
+	   calls via the PLT always branch to the symbol's address and
+	   not to the address plus a non-zero offset.  */
+	if (r_addend != 0)
+	  _dl_signal_error (0, map->l_name, NULL,
+			    "found jump slot relocation with non-zero addend");
+
+	sym_map = RESOLVE_MAP (&sym, version, r_type);
+	value = sym_map == NULL ? 0 : sym_map->l_addr + sym->st_value;
+	*addr_field = value;
+
+	break;
+      }
+
+    case R_MIPS_COPY:
+      {
+	const ElfW(Sym) *const refsym = sym;
+	struct link_map *sym_map;
+	ElfW(Addr) value;
+
+	/* Calculate the address of the symbol.  */
+	sym_map = RESOLVE_MAP (&sym, version, r_type);
+	value = sym_map == NULL ? 0 : sym_map->l_addr + sym->st_value;
+
+	if (__builtin_expect (sym == NULL, 0))
+	  /* This can happen in trace mode if an object could not be
+	     found.  */
+	  break;
+	if (__builtin_expect (sym->st_size > refsym->st_size, 0)
+	    || (__builtin_expect (sym->st_size < refsym->st_size, 0)
+		&& GLRO(dl_verbose)))
+	  {
+	    const char *strtab;
+
+	    strtab = (const void *) D_PTR (map, l_info[DT_STRTAB]);
+	    _dl_error_printf ("\
+  %s: Symbol `%s' has different size in shared object, consider re-linking\n",
+			      rtld_progname ?: "<program name unknown>",
+			      strtab + refsym->st_name);
+	  }
+	memcpy (reloc_addr, (void *) value,
+	        MIN (sym->st_size, refsym->st_size));
+	break;
+      }
+
+#if _RISCV_SIM == _ABI64
+    case R_MIPS_64:
+      /* For full compliance with the ELF64 ABI, one must precede the
+	 _REL32/_64 pair of relocations with a _64 relocation, such
+	 that the in-place addend is read as a 64-bit value.  IRIX
+	 didn't pick up on this requirement, so we treat the
+	 _REL32/_64 relocation as a 64-bit relocation even if it's by
+	 itself.  For ABI compliance, we ignore such _64 dummy
+	 relocations.  For RELA, this may be simply removed, since
+	 it's totally unnecessary.  */
+      if (ELFW(R_SYM) (r_info) == 0)
+	break;
+      /* Fall through.  */
+#endif
+    default:
+      _dl_reloc_bad_type (map, r_type, 0);
+      break;
+    }
+}
+
+/* Perform the relocation specified by RELOC and SYM (which is fully resolved).
+   MAP is the object containing the reloc.  */
+
+auto inline void
+__attribute__ ((always_inline))
+elf_machine_rel (struct link_map *map, const ElfW(Rel) *reloc,
+		 const ElfW(Sym) *sym, const struct r_found_version *version,
+		 void *const reloc_addr)
+{
+  elf_machine_reloc (map, reloc->r_info, sym, version, reloc_addr, 0, 1);
+}
+
+auto inline void
+__attribute__((always_inline))
+elf_machine_rel_relative (ElfW(Addr) l_addr, const ElfW(Rel) *reloc,
+			  void *const reloc_addr)
+{
+  /* XXX Nothing to do.  There is no relative relocation, right?  */
+}
+
+auto inline void
+__attribute__((always_inline))
+elf_machine_lazy_rel (struct link_map *map,
+		      ElfW(Addr) l_addr, const ElfW(Rel) *reloc)
+{
+  ElfW(Addr) *const reloc_addr = (void *) (l_addr + reloc->r_offset);
+  const unsigned int r_type = ELFW(R_TYPE) (reloc->r_info);
+  /* Check for unexpected PLT reloc type.  */
+  if (__builtin_expect (r_type == R_MIPS_JUMP_SLOT, 1))
+    {
+      if (__builtin_expect (map->l_mach.plt, 0) == 0)
+	{
+	  /* Nothing is required here since we only support lazy
+	     relocation in executables.  */
+	}
+      else
+	*reloc_addr = map->l_mach.plt;
+    }
+  else
+    _dl_reloc_bad_type (map, r_type, 1);
+}
+
+auto inline void
+__attribute__ ((always_inline))
+elf_machine_rela (struct link_map *map, const ElfW(Rela) *reloc,
+		  const ElfW(Sym) *sym, const struct r_found_version *version,
+		 void *const reloc_addr)
+{
+  elf_machine_reloc (map, reloc->r_info, sym, version, reloc_addr,
+		     reloc->r_addend, 0);
+}
+
+auto inline void
+__attribute__((always_inline))
+elf_machine_rela_relative (ElfW(Addr) l_addr, const ElfW(Rela) *reloc,
+			   void *const reloc_addr)
+{
+}
+
+#ifndef RTLD_BOOTSTRAP
+/* Relocate GOT. */
+auto inline void
+__attribute__((always_inline))
+elf_machine_got_rel (struct link_map *map, int lazy)
+{
+  ElfW(Addr) *got;
+  ElfW(Sym) *sym;
+  const ElfW(Half) *vernum;
+  int i, n, symidx;
+
+#define RESOLVE_GOTSYM(sym,vernum,sym_index,reloc)			  \
+    ({									  \
+      const ElfW(Sym) *ref = sym;					  \
+      const struct r_found_version *version				  \
+        = vernum ? &map->l_versions[vernum[sym_index] & 0x7fff] : NULL;	  \
+      struct link_map *sym_map;						  \
+      sym_map = RESOLVE_MAP (&ref, version, reloc);			  \
+      ref ? sym_map->l_addr + ref->st_value : 0;			  \
+    })
+
+  if (map->l_info[VERSYMIDX (DT_VERSYM)] != NULL)
+    vernum = (const void *) D_PTR (map, l_info[VERSYMIDX (DT_VERSYM)]);
+  else
+    vernum = NULL;
+
+  got = (ElfW(Addr) *) D_PTR (map, l_info[DT_PLTGOT]);
+
+  n = map->l_info[DT_MIPS (LOCAL_GOTNO)]->d_un.d_val;
+  /* The dynamic linker's local got entries have already been relocated.  */
+  if (map != &GL(dl_rtld_map))
+    {
+      /* got[0] is reserved. got[1] is also reserved for the dynamic object
+	 generated by gnu ld. Skip these reserved entries from relocation.  */
+      i = (got[1] & ELF_MIPS_GNU_GOT1_MASK)? 2 : 1;
+
+      /* Add the run-time displacement to all local got entries if
+         needed.  */
+      if (__builtin_expect (map->l_addr != 0, 0))
+	{
+	  while (i < n)
+	    got[i++] += map->l_addr;
+	}
+    }
+
+  /* Handle global got entries. */
+  got += n;
+  /* Keep track of the symbol index.  */
+  symidx = map->l_info[DT_MIPS (GOTSYM)]->d_un.d_val;
+  sym = (ElfW(Sym) *) D_PTR (map, l_info[DT_SYMTAB]) + symidx;
+  i = (map->l_info[DT_MIPS (SYMTABNO)]->d_un.d_val
+       - map->l_info[DT_MIPS (GOTSYM)]->d_un.d_val);
+
+  /* This loop doesn't handle Quickstart.  */
+  while (i--)
+    {
+      if (sym->st_shndx == SHN_UNDEF)
+	{
+	  if (ELFW(ST_TYPE) (sym->st_info) == STT_FUNC && sym->st_value
+	      && !(sym->st_other & STO_MIPS_PLT))
+	    {
+	      if (lazy)
+		*got = sym->st_value + map->l_addr;
+	      else
+		/* This is a lazy-binding stub, so we don't need the
+		   canonical address.  */
+		*got = RESOLVE_GOTSYM (sym, vernum, symidx, R_MIPS_JUMP_SLOT);
+	    }
+	  else
+	    *got = RESOLVE_GOTSYM (sym, vernum, symidx, R_MIPS_32);
+	}
+      else if (sym->st_shndx == SHN_COMMON)
+	*got = RESOLVE_GOTSYM (sym, vernum, symidx, R_MIPS_32);
+      else if (ELFW(ST_TYPE) (sym->st_info) == STT_FUNC
+	       && *got != sym->st_value)
+	{
+	  if (lazy)
+	    *got += map->l_addr;
+	  else
+	    /* This is a lazy-binding stub, so we don't need the
+	       canonical address.  */
+	    *got = RESOLVE_GOTSYM (sym, vernum, symidx, R_MIPS_JUMP_SLOT);
+	}
+      else if (ELFW(ST_TYPE) (sym->st_info) == STT_SECTION)
+	{
+	  if (sym->st_other == 0)
+	    *got += map->l_addr;
+	}
+      else
+	*got = RESOLVE_GOTSYM (sym, vernum, symidx, R_MIPS_32);
+
+      ++got;
+      ++sym;
+      ++symidx;
+    }
+
+#undef RESOLVE_GOTSYM
+}
+#endif
+
+/* Set up the loaded object described by L so its stub function
+   will jump to the on-demand fixup code __dl_runtime_resolve.  */
+
+auto inline int
+__attribute__((always_inline))
+elf_machine_runtime_setup (struct link_map *l, int lazy, int profile)
+{
+# ifndef RTLD_BOOTSTRAP
+  ElfW(Addr) *got;
+  extern void _dl_runtime_resolve (ElfW(Word));
+  extern void _dl_runtime_pltresolve (void);
+  extern int _dl_mips_gnu_objects;
+
+  if (lazy)
+    {
+      /* The GOT entries for functions have not yet been filled in.
+	 Their initial contents will arrange when called to put an
+	 offset into the .dynsym section in t8, the return address
+	 in t7 and then jump to _GLOBAL_OFFSET_TABLE[0].  */
+      got = (ElfW(Addr) *) D_PTR (l, l_info[DT_PLTGOT]);
+
+      /* This function will get called to fix up the GOT entry indicated by
+	 the register t8, and then jump to the resolved address.  */
+      got[0] = (ElfW(Addr)) &_dl_runtime_resolve;
+
+      /* Store l to _GLOBAL_OFFSET_TABLE[1] for gnu object. The MSB
+	 of got[1] of a gnu object is set to identify gnu objects.
+	 Where we can store l for non gnu objects? XXX  */
+      if ((got[1] & ELF_MIPS_GNU_GOT1_MASK) != 0)
+	got[1] = ((ElfW(Addr)) l | ELF_MIPS_GNU_GOT1_MASK);
+      else
+	_dl_mips_gnu_objects = 0;
+    }
+
+  /* Relocate global offset table.  */
+  elf_machine_got_rel (l, lazy);
+
+  /* If using PLTs, fill in the first two entries of .got.plt.  */
+  if (l->l_info[DT_JMPREL] && lazy)
+    {
+      ElfW(Addr) *gotplt;
+      gotplt = (ElfW(Addr) *) D_PTR (l, l_info[DT_MIPS (PLTGOT)]);
+      /* If a library is prelinked but we have to relocate anyway,
+	 we have to be able to undo the prelinking of .got.plt.
+	 The prelinker saved the address of .plt for us here.  */
+      if (gotplt[1])
+	l->l_mach.plt = gotplt[1] + l->l_addr;
+      gotplt[0] = (ElfW(Addr)) &_dl_runtime_pltresolve;
+      gotplt[1] = (ElfW(Addr)) l;
+    }
+
+# endif
+  return lazy;
+}
+
+#endif /* RESOLVE_MAP */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/dl-tls.h glibc-2.14.1/sysdeps/riscv/dl-tls.h
--- ../glibc-2.14.1-orig/sysdeps/riscv/dl-tls.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/dl-tls.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,49 @@
+/* Thread-local storage handling in the ELF dynamic linker.  MIPS version.
+   Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+
+/* Type used for the representation of TLS information in the GOT.  */
+typedef struct
+{
+  unsigned long int ti_module;
+  unsigned long int ti_offset;
+} tls_index;
+
+/* The thread pointer points 0x7000 past the first static TLS block.  */
+#define TLS_TP_OFFSET		0x7000
+
+/* Dynamic thread vector pointers point 0x8000 past the start of each
+   TLS block.  */
+#define TLS_DTV_OFFSET		0x8000
+
+/* Compute the value for a GOTTPREL reloc.  */
+#define TLS_TPREL_VALUE(sym_map, sym) \
+  ((sym_map)->l_tls_offset + (sym)->st_value - TLS_TP_OFFSET)
+
+/* Compute the value for a DTPREL reloc.  */
+#define TLS_DTPREL_VALUE(sym) \
+  ((sym)->st_value - TLS_DTV_OFFSET)
+
+extern void *__tls_get_addr (tls_index *ti);
+
+# define GET_ADDR_OFFSET	(ti->ti_offset + TLS_DTV_OFFSET)
+# define __TLS_GET_ADDR(__ti)	(__tls_get_addr (__ti) - TLS_DTV_OFFSET)
+
+/* Value used for dtv entries for which the allocation is delayed.  */
+#define TLS_DTV_UNALLOCATED	((void *) -1l)
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/dl-trampoline.c glibc-2.14.1/sysdeps/riscv/dl-trampoline.c
--- ../glibc-2.14.1-orig/sysdeps/riscv/dl-trampoline.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/dl-trampoline.c	2011-11-07 21:41:52.000000000 -0800
@@ -0,0 +1,295 @@
+/* PLT trampoline.  MIPS version.
+   Copyright (C) 1996-2001, 2002, 2003, 2004, 2005
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Kazumoto Kojima <kkojima@info.kanagawa-u.ac.jp>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*  FIXME: Profiling of shared libraries is not implemented yet.  */
+
+#include <sysdep.h>
+#include <link.h>
+#include <elf.h>
+#include <ldsodefs.h>
+#include <dl-machine.h>
+
+/* Get link map for callers object containing STUB_PC.  */
+static inline struct link_map *
+elf_machine_runtime_link_map (ElfW(Addr) gpreg, ElfW(Addr) stub_pc)
+{
+  extern int _dl_mips_gnu_objects;
+
+  /* got[1] is reserved to keep its link map address for the shared
+     object generated by the gnu linker.  If all are such objects, we
+     can find the link map from current GPREG simply.  If not so, get
+     the link map for caller's object containing STUB_PC.  */
+
+  if (_dl_mips_gnu_objects)
+    {
+      ElfW(Addr) *got = elf_mips_got_from_gpreg (gpreg);
+      ElfW(Word) g1;
+
+      g1 = ((ElfW(Word) *) got)[1];
+
+      if ((g1 & ELF_MIPS_GNU_GOT1_MASK) != 0)
+	{
+	  struct link_map *l =
+	    (struct link_map *) (g1 & ~ELF_MIPS_GNU_GOT1_MASK);
+	  ElfW(Addr) base, limit;
+	  const ElfW(Phdr) *p = l->l_phdr;
+	  ElfW(Half) this, nent = l->l_phnum;
+
+	  /* For the common case of a stub being called from the containing
+	     object, STUB_PC will point to somewhere within the object that
+	     is described by the link map fetched via got[1].  Otherwise we
+	     have to scan all maps.  */
+	  for (this = 0; this < nent; this++)
+	    {
+	      if (p[this].p_type == PT_LOAD)
+		{
+		  base = p[this].p_vaddr + l->l_addr;
+		  limit = base + p[this].p_memsz;
+		  if (stub_pc >= base && stub_pc < limit)
+		    return l;
+		}
+	    }
+	}
+    }
+
+    struct link_map *l;
+    Lmid_t nsid;
+
+    for (nsid = 0; nsid < DL_NNS; ++nsid)
+      for (l = GL(dl_ns)[nsid]._ns_loaded; l != NULL; l = l->l_next)
+	{
+	  ElfW(Addr) base, limit;
+	  const ElfW(Phdr) *p = l->l_phdr;
+	  ElfW(Half) this, nent = l->l_phnum;
+
+	  for (this = 0; this < nent; ++this)
+	    {
+	      if (p[this].p_type == PT_LOAD)
+		{
+		  base = p[this].p_vaddr + l->l_addr;
+		  limit = base + p[this].p_memsz;
+		  if (stub_pc >= base && stub_pc < limit)
+		    return l;
+		}
+	    }
+	}
+
+  _dl_signal_error (0, NULL, NULL, "cannot find runtime link map");
+  return NULL;
+}
+
+/* Define mips specific runtime resolver. The function __dl_runtime_resolve
+   is called from assembler function _dl_runtime_resolve which converts
+   special argument registers t5 (x17) and t6 (x18):
+     t5  address to return to the caller of the function
+     t6  index for this function symbol in .dynsym
+   to usual c arguments.
+
+   Other architectures call fixup from dl-runtime.c in
+   _dl_runtime_resolve.  MIPS instead calls __dl_runtime_resolve.  We
+   have to use our own version because of the way the got section is
+   treated on MIPS (we've also got ELF_MACHINE_PLT defined).  */
+
+/* The flag _dl_mips_gnu_objects is set if all dynamic objects are
+   generated by the gnu linker. */
+int _dl_mips_gnu_objects = 1;
+
+#define VERSYMIDX(sym)  (DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGIDX (sym))
+
+/* This is called from assembly stubs below which the compiler can't see.  */
+static ElfW(Addr)
+__dl_runtime_resolve (ElfW(Word), ElfW(Word), ElfW(Addr), ElfW(Addr))
+		  __attribute_used__;
+
+static ElfW(Addr)
+__dl_runtime_resolve (ElfW(Word) sym_index,
+		      ElfW(Word) return_address,
+		      ElfW(Addr) old_gpreg,
+		      ElfW(Addr) stub_pc)
+{
+  struct link_map *l = elf_machine_runtime_link_map (old_gpreg, stub_pc);
+  const ElfW(Sym) *const symtab
+    = (const ElfW(Sym) *) D_PTR (l, l_info[DT_SYMTAB]);
+  const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]);
+  ElfW(Addr) *got
+    = (ElfW(Addr) *) D_PTR (l, l_info[DT_PLTGOT]);
+  const ElfW(Word) local_gotno
+    = (const ElfW(Word)) l->l_info[DT_MIPS (LOCAL_GOTNO)]->d_un.d_val;
+  const ElfW(Word) gotsym
+    = (const ElfW(Word)) l->l_info[DT_MIPS (GOTSYM)]->d_un.d_val;
+  const ElfW(Sym) *sym = &symtab[sym_index];
+  struct link_map *sym_map;
+  ElfW(Addr) value;
+
+  /* FIXME: The symbol versioning stuff is not tested yet.  */
+  if (__builtin_expect (ELFW(ST_VISIBILITY) (sym->st_other), 0) == 0)
+    {
+      switch (l->l_info[VERSYMIDX (DT_VERSYM)] != NULL)
+	{
+	default:
+	  {
+	    const ElfW(Half) *vernum =
+	      (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);
+	    ElfW(Half) ndx = vernum[sym_index] & 0x7fff;
+	    const struct r_found_version *version = &l->l_versions[ndx];
+
+	    if (version->hash != 0)
+	      {
+		sym_map = _dl_lookup_symbol_x (strtab + sym->st_name, l,
+					       &sym, l->l_scope, version,
+					       ELF_RTYPE_CLASS_PLT, 0, 0);
+		break;
+	      }
+	    /* Fall through.  */
+	  }
+	case 0:
+	  sym_map = _dl_lookup_symbol_x (strtab + sym->st_name, l, &sym,
+					 l->l_scope, 0, ELF_RTYPE_CLASS_PLT,
+					 DL_LOOKUP_ADD_DEPENDENCY, 0);
+	}
+
+      /* Currently value contains the base load address of the object
+	 that defines sym.  Now add in the symbol offset.  */
+      value = (sym ? sym_map->l_addr + sym->st_value : 0);
+    }
+  else
+    /* We already found the symbol.  The module (and therefore its load
+       address) is also known.  */
+    value = l->l_addr + sym->st_value;
+
+  /* Apply the relocation with that value.  */
+  *(got + local_gotno + sym_index - gotsym) = value;
+
+  return value;
+}
+
+#define ELF_DL_FRAME_SIZE (10*SZREG)
+
+#define ELF_DL_SAVE_ARG_REGS "\
+	" STRINGXP(REG_S) " t5, 9*" STRINGXP(SZREG) "(sp)\n						      \
+	" STRINGXP(REG_S) " a0, 1*" STRINGXP(SZREG) "(sp)\n						      \
+	" STRINGXP(REG_S) " a1, 2*" STRINGXP(SZREG) "(sp)\n						      \
+	" STRINGXP(REG_S) " a2, 3*" STRINGXP(SZREG) "(sp)\n						      \
+	" STRINGXP(REG_S) " a3, 4*" STRINGXP(SZREG) "(sp)\n						      \
+	" STRINGXP(REG_S) " a4, 5*" STRINGXP(SZREG) "(sp)\n						      \
+	" STRINGXP(REG_S) " a5, 6*" STRINGXP(SZREG) "(sp)\n						      \
+	" STRINGXP(REG_S) " a6, 7*" STRINGXP(SZREG) "(sp)\n						      \
+	" STRINGXP(REG_S) " a7, 8*" STRINGXP(SZREG) "(sp)\n						      \
+"
+
+#define ELF_DL_RESTORE_ARG_REGS "\
+	" STRINGXP(REG_L) " ra, 9*" STRINGXP(SZREG) "(sp)\n						      \
+	" STRINGXP(REG_L) " a0, 1*" STRINGXP(SZREG) "(sp)\n						      \
+	" STRINGXP(REG_L) " a1, 2*" STRINGXP(SZREG) "(sp)\n						      \
+	" STRINGXP(REG_L) " a2, 3*" STRINGXP(SZREG) "(sp)\n						      \
+	" STRINGXP(REG_L) " a3, 4*" STRINGXP(SZREG) "(sp)\n						      \
+	" STRINGXP(REG_L) " a4, 5*" STRINGXP(SZREG) "(sp)\n						      \
+	" STRINGXP(REG_L) " a5, 6*" STRINGXP(SZREG) "(sp)\n						      \
+	" STRINGXP(REG_L) " a6, 7*" STRINGXP(SZREG) "(sp)\n						      \
+	" STRINGXP(REG_L) " a7, 8*" STRINGXP(SZREG) "(sp)\n						      \
+"
+
+/* The PLT resolver should also save and restore $2 and $3, which are used
+   as arguments to MIPS16 stub functions.  */
+#define ELF_DL_PLT_FRAME_SIZE (12*SZREG)
+
+#define ELF_DL_PLT_SAVE_ARG_REGS \
+	ELF_DL_SAVE_ARG_REGS "\
+	" STRINGXP(REG_S) " v0, 10*" STRINGXP(SZREG) "(sp)\n						      \
+	" STRINGXP(REG_S) " v1, 11*" STRINGXP(SZREG) "(sp)\n						      \
+"
+
+#define ELF_DL_PLT_RESTORE_ARG_REGS \
+	ELF_DL_RESTORE_ARG_REGS "\
+	" STRINGXP(REG_L) " v0, 10*" STRINGXP(SZREG) "(sp)\n						      \
+	" STRINGXP(REG_L) " v1, 11*" STRINGXP(SZREG) "(sp)\n						      \
+"
+
+asm ("\n\
+	.text\n\
+	.align	2\n\
+	.globl	_dl_runtime_resolve\n\
+	.type	_dl_runtime_resolve,@function\n\
+	.ent	_dl_runtime_resolve\n\
+_dl_runtime_resolve:\n\
+	.frame	sp, " STRINGXP(ELF_DL_FRAME_SIZE) ", ra\n\
+	" STRINGXV(SETUP_GP64(t4, _dl_runtime_resolve)) "\n\
+	# Save arguments and sp value in stack.\n\
+	addi  sp, sp, " STRINGXP(-ELF_DL_FRAME_SIZE) "\n\
+	# Save slot call pc.\n\
+	move	v0, ra\n\
+	" ELF_DL_SAVE_ARG_REGS "\
+	move	a0, t6\n\
+	move	a1, t5\n\
+	move	a2, v1\n\
+	move	a3, v0\n\
+	" STRINGXV(PIC_JAL(t4, __dl_runtime_resolve)) "\n\
+	" ELF_DL_RESTORE_ARG_REGS "\
+	move	t7, v0\n\
+	addi	sp, sp, " STRINGXP(ELF_DL_FRAME_SIZE) "\n\
+	jr	t7\n\
+	.end	_dl_runtime_resolve\n\
+	.previous\n\
+");
+
+/* Assembler veneer called from the PLT header code when using PLTs.
+
+   Code in each PLT entry and the PLT header fills in the arguments to
+   this function:
+
+   - x17 (t5) - caller's return address
+   - x18 (t6) - PLT entry index
+   - x19 (t7) - address of _dl_runtime_pltresolve
+   - x14 (t2) - address of .got.plt
+
+   Different registers are used for .got.plt because the ABI was
+   originally designed for o32, where gp was available (call
+   clobbered).  On n32/n64 gp is call saved.
+
+   _dl_fixup needs:
+
+   - x4 (a0) - link map address
+   - x5 (a1) - .rel.plt offset (== PLT entry index * 8)  */
+
+asm ("\n\
+	.text\n\
+	.align	2\n\
+	.globl	_dl_runtime_pltresolve\n\
+	.type	_dl_runtime_pltresolve,@function\n\
+	.ent	_dl_runtime_pltresolve\n\
+_dl_runtime_pltresolve:\n\
+	.frame	sp, " STRINGXP(ELF_DL_PLT_FRAME_SIZE) ", ra\n\
+	" STRINGXV(SETUP_GP64(t4, _dl_runtime_pltresolve)) "\n\
+	# Save arguments and sp value in stack.\n\
+1:	addi	sp, sp, " STRINGXP(-ELF_DL_PLT_FRAME_SIZE) "\n\
+	" STRINGXP(REG_L) "	t1, " STRINGXP(PTRSIZE) "(t2)" "\n\
+	" ELF_DL_PLT_SAVE_ARG_REGS "\
+	move	a0, t1\n\
+	sll	a1, t6, " STRINGXP(PTRLOG) " + 1\n\
+	" STRINGXV(PIC_JAL(t4, _dl_fixup)) "\n\
+	move	t7, v0\n\
+	" ELF_DL_PLT_RESTORE_ARG_REGS "\
+	addi	sp, sp, " STRINGXP(ELF_DL_PLT_FRAME_SIZE) "\n\
+	jr	t7\n\
+	.end	_dl_runtime_pltresolve\n\
+	.previous\n\
+");
+
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/elf/configure glibc-2.14.1/sysdeps/riscv/elf/configure
--- ../glibc-2.14.1-orig/sysdeps/riscv/elf/configure	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/elf/configure	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,46 @@
+# This file is generated from configure.in by Autoconf.  DO NOT EDIT!
+ # Local configure fragment for sysdeps/mips/elf.
+
+if test "$usetls" != no; then
+# Check for support of thread-local storage handling in assembler and
+# linker.
+echo "$as_me:$LINENO: checking for MIPS TLS support" >&5
+echo $ECHO_N "checking for MIPS TLS support... $ECHO_C" >&6
+if test "${libc_cv_mips_tls+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat > conftest.s <<\EOF
+	.section ".tdata", "awT", %progbits
+	.globl foo
+foo:	.long	1
+	.section ".tbss", "awT", %nobits
+	.globl bar
+bar:	.skip	4
+	.text
+
+	lw	t7, %call16(__tls_get_addr)(gp)
+	add	a0, gp, %tlsgd(x) 
+	jalr	t7
+EOF
+if { ac_try='${CC-cc} -c $CFLAGS conftest.s 1>&5'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  libc_cv_mips_tls=yes
+else
+  libc_cv_mips_tls=no
+fi
+rm -f conftest*
+fi
+echo "$as_me:$LINENO: result: $libc_cv_mips_tls" >&5
+echo "${ECHO_T}$libc_cv_mips_tls" >&6
+if test $libc_cv_mips_tls = yes; then
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_TLS_SUPPORT 1
+_ACEOF
+
+fi
+fi
+
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/elf/configure.in glibc-2.14.1/sysdeps/riscv/elf/configure.in
--- ../glibc-2.14.1-orig/sysdeps/riscv/elf/configure.in	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/elf/configure.in	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,35 @@
+GLIBC_PROVIDES dnl See aclocal.m4 in the top level source directory.
+# Local configure fragment for sysdeps/mips/elf.
+
+if test "$usetls" != no; then
+# Check for support of thread-local storage handling in assembler and
+# linker.
+AC_CACHE_CHECK(for MIPS TLS support, libc_cv_mips_tls, [dnl
+cat > conftest.s <<\EOF
+	.section ".tdata", "awT", %progbits
+	.globl foo
+foo:	.long	1
+	.section ".tbss", "awT", %nobits
+	.globl bar
+bar:	.skip	4
+	.text
+
+	lw	t7, %call16(__tls_get_addr)(gp)
+	add	a0, gp, %tlsgd(x) 
+	jalr	t7
+EOF
+dnl
+if AC_TRY_COMMAND(${CC-cc} -c $CFLAGS conftest.s 1>&AS_MESSAGE_LOG_FD); then
+  libc_cv_mips_tls=yes
+else
+  libc_cv_mips_tls=no
+fi
+rm -f conftest*])
+if test $libc_cv_mips_tls = yes; then
+  AC_DEFINE(HAVE_TLS_SUPPORT)
+fi
+fi
+
+dnl No MIPS GCC supports accessing static and hidden symbols in an
+dnl position independent way.
+dnl AC_DEFINE(PI_STATIC_AND_HIDDEN)
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/elf/start.S glibc-2.14.1/sysdeps/riscv/elf/start.S
--- ../glibc-2.14.1-orig/sysdeps/riscv/elf/start.S	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/elf/start.S	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,105 @@
+/* Startup code compliant to the ELF Mips ABI.
+   Copyright (C) 1995, 1997, 2000, 2001, 2002, 2003, 2004
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file with other
+   programs, and to distribute those programs without any restriction
+   coming from the use of this file. (The GNU Lesser General Public
+   License restrictions do apply in other respects; for example, they
+   cover modification of the file, and distribution when not linked
+   into another program.)
+
+   Note that people who make modified versions of this file are not
+   obligated to grant this special exception for their modified
+   versions; it is their choice whether to do so. The GNU Lesser
+   General Public License gives permission to release a modified
+   version without this exception; this exception also makes it
+   possible to release a modified version which carries forward this
+   exception.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define __ASSEMBLY__ 1
+#include <entry.h>
+#include <sgidefs.h>
+#include <sys/asm.h>
+
+#ifndef ENTRY_POINT
+#error ENTRY_POINT needs to be defined for start.S on MIPS/ELF.
+#endif
+
+/* This is the canonical entry point, usually the first thing in the text
+   segment.  The SVR4/Mips ABI (pages 3-31, 3-32) says that when the entry
+   point runs, most registers' values are unspecified, except for:
+
+   v0 ($2)	Contains a function pointer to be registered with `atexit'.
+		This is how the dynamic linker arranges to have DT_FINI
+		functions called for shared libraries that have been loaded
+		before this code runs.
+
+   sp ($29)	The stack contains the arguments and environment:
+		0(%esp)			argc
+		4(%esp)			argv[0]
+		...
+		(4*argc)(%esp)		NULL
+		(4*(argc+1))(%esp)	envp[0]
+		...
+					NULL
+   ra ($31)	The return address register is set to zero so that programs
+		that search backword through stack frames recognize the last
+		stack frame.
+*/
+
+
+/* We need to call:
+   __libc_start_main (int (*main) (int, char **, char **), int argc,
+		      char **argv, void (*init) (void), void (*fini) (void),
+		      void (*rtld_fini) (void), void *stack_end)
+*/
+	
+	.text
+	.globl ENTRY_POINT
+	.type ENTRY_POINT,@function
+ENTRY_POINT:
+	SETUP_GPX64(t6, t7)
+
+	PIC_LA	(a0, t6, main)  /* &main */
+	REG_L  	a1, 0(sp)      /* argc */
+	addi   	a2, sp, SZREG  /* argv */
+
+	/* Align stack. */
+	andi   	sp, sp, ALMASK
+
+	PIC_LA	(a3, t6, __libc_csu_init)
+	PIC_LA	(a4, t6, __libc_csu_fini)
+
+	move   	a5, v0  /* rtld_fini */
+	move   	a6, sp  /* stack_end */
+
+	PIC_JAL	(t6, __libc_start_main)
+
+	unimp
+
+/* Define a symbol for the first piece of initialized data.  */
+	.data
+	.globl __data_start
+__data_start:
+	.long 0
+	.weak data_start
+	data_start = __data_start
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/fpu/bits/mathinline.h glibc-2.14.1/sysdeps/riscv/fpu/bits/mathinline.h
--- ../glibc-2.14.1-orig/sysdeps/riscv/fpu/bits/mathinline.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/fpu/bits/mathinline.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,52 @@
+/* Inline math functions for RISC-V.
+   Copyright (C) 2011
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Jakub Jelinek <jakub@redhat.com>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _MATH_H
+# error "Never use <bits/mathinline.h> directly; include <math.h> instead."
+#endif
+
+#include <bits/wordsize.h>
+
+#ifdef __GNUC__
+
+#if defined __USE_ISOC99
+# undef isgreater
+# undef isgreaterequal
+# undef isless
+# undef islessequal
+# undef islessgreater
+# undef isunordered
+
+# define isgreater(x, y) ((x) > (y))
+# define isgreaterequal(x, y) ((x) >= (y))
+# define isless(x, y) ((x) < (y))
+# define islessequal(x, y) ((x) <= (y))
+# define islessgreater(x, y) (!!(isless(x, y) + isgreater(x, y)))
+# define isunordered(x, y) (((x) == (x)) + ((y) == (y)) < 2)
+
+#endif /* __USE_ISOC99 */
+
+#if (!defined __NO_MATH_INLINES || defined __LIBC_INTERNAL_MATH_INLINES) && defined __OPTIMIZE__
+
+/* Nothing yet. */
+
+#endif /* !__NO_MATH_INLINES && __OPTIMIZE__ */
+#endif /* __GNUC__ */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/fpu/e_sqrt.c glibc-2.14.1/sysdeps/riscv/fpu/e_sqrt.c
--- ../glibc-2.14.1-orig/sysdeps/riscv/fpu/e_sqrt.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/fpu/e_sqrt.c	2011-10-27 22:20:54.000000000 -0700
@@ -0,0 +1,26 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Hartvig Ekner <hartvige@mips.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+double
+__ieee754_sqrt (double x)
+{
+  double z;
+  __asm__ ("fsqrt.d %0,%1" : "=f" (z) : "f" (x));
+  return z;
+}
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/fpu/e_sqrtf.c glibc-2.14.1/sysdeps/riscv/fpu/e_sqrtf.c
--- ../glibc-2.14.1-orig/sysdeps/riscv/fpu/e_sqrtf.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/fpu/e_sqrtf.c	2011-10-27 22:21:11.000000000 -0700
@@ -0,0 +1,26 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Hartvig Ekner <hartvige@mips.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+float
+__ieee754_sqrtf (float x)
+{
+  float z;
+  __asm__ ("fsqrt.s %0,%1" : "=f" (z) : "f" (x));
+  return z;
+}
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/fpu/fclrexcpt.c glibc-2.14.1/sysdeps/riscv/fpu/fclrexcpt.c
--- ../glibc-2.14.1-orig/sysdeps/riscv/fpu/fclrexcpt.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/fpu/fclrexcpt.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,47 @@
+/* Clear given exceptions in current floating-point environment.
+   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fenv_libc.h>
+#include <fpu_control.h>
+
+int
+feclearexcept (int excepts)
+{
+  int cw;
+
+  /* Mask out unsupported bits/exceptions.  */
+  excepts &= FE_ALL_EXCEPT;
+
+  /* Read the complete control word.  */
+  _FPU_GETCW (cw);
+
+  /* Clear exception flag bits and cause bits. If the cause bit is not
+     cleared, the next CTC instruction (just below) will re-generate the
+     exception.  */
+
+  cw &= ~(excepts | (excepts << CAUSE_SHIFT));
+
+  /* Put the new data in effect.  */
+  _FPU_SETCW (cw);
+
+  /* Success.  */
+  return 0;
+}
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/fpu/fedisblxcpt.c glibc-2.14.1/sysdeps/riscv/fpu/fedisblxcpt.c
--- ../glibc-2.14.1-orig/sysdeps/riscv/fpu/fedisblxcpt.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/fpu/fedisblxcpt.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,42 @@
+/* Disable floating-point exceptions.
+   Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fenv_libc.h>
+#include <fpu_control.h>
+
+int
+fedisableexcept (int excepts)
+{
+  unsigned int new_exc, old_exc;
+
+  /* Get the current control word.  */
+  _FPU_GETCW (new_exc);
+
+  old_exc = (new_exc & ENABLE_MASK) >> ENABLE_SHIFT;
+
+  excepts &= FE_ALL_EXCEPT;
+
+  new_exc &= ~(excepts << ENABLE_SHIFT);
+  new_exc &= ~_FPU_RESERVED;
+  _FPU_SETCW (new_exc);
+
+  return old_exc;
+}
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/fpu/feenablxcpt.c glibc-2.14.1/sysdeps/riscv/fpu/feenablxcpt.c
--- ../glibc-2.14.1-orig/sysdeps/riscv/fpu/feenablxcpt.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/fpu/feenablxcpt.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,42 @@
+/* Enable floating-point exceptions.
+   Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fenv_libc.h>
+#include <fpu_control.h>
+
+int
+feenableexcept (int excepts)
+{
+  unsigned int new_exc, old_exc;
+
+  /* Get the current control word.  */
+  _FPU_GETCW (new_exc);
+
+  old_exc = (new_exc & ENABLE_MASK) >> ENABLE_SHIFT;
+
+  excepts &= FE_ALL_EXCEPT;
+
+  new_exc |= excepts << ENABLE_SHIFT;
+  new_exc &= ~_FPU_RESERVED;
+  _FPU_SETCW (new_exc);
+
+  return old_exc;
+}
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/fpu/fegetenv.c glibc-2.14.1/sysdeps/riscv/fpu/fegetenv.c
--- ../glibc-2.14.1-orig/sysdeps/riscv/fpu/fegetenv.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/fpu/fegetenv.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,32 @@
+/* Store current floating-point environment.
+   Copyright (C) 1998, 1999, 2000, 2002, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+fegetenv (fenv_t *envp)
+{
+  _FPU_GETCW (*envp);
+
+  /* Success.  */
+  return 0;
+}
+libm_hidden_def (fegetenv)
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/fpu/fegetexcept.c glibc-2.14.1/sysdeps/riscv/fpu/fegetexcept.c
--- ../glibc-2.14.1-orig/sysdeps/riscv/fpu/fegetexcept.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/fpu/fegetexcept.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,34 @@
+/* Get enabled floating-point exceptions.
+   Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fenv_libc.h>
+#include <fpu_control.h>
+
+int
+fegetexcept (void)
+{
+  unsigned int exc;
+
+  /* Get the current control word.  */
+  _FPU_GETCW (exc);
+
+  return (exc & ENABLE_MASK) >> ENABLE_SHIFT;
+}
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/fpu/fegetround.c glibc-2.14.1/sysdeps/riscv/fpu/fegetround.c
--- ../glibc-2.14.1-orig/sysdeps/riscv/fpu/fegetround.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/fpu/fegetround.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,33 @@
+/* Return current rounding direction.
+   Copyright (C) 1998 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@arthur.rhein-neckar.de>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+fegetround (void)
+{
+  int cw;
+
+  /* Get control word.  */
+  _FPU_GETCW (cw);
+
+  return cw & 0x3;
+}
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/fpu/feholdexcpt.c glibc-2.14.1/sysdeps/riscv/fpu/feholdexcpt.c
--- ../glibc-2.14.1-orig/sysdeps/riscv/fpu/feholdexcpt.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/fpu/feholdexcpt.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,40 @@
+/* Store current floating-point environment and clear exceptions.
+   Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+feholdexcept (fenv_t *envp)
+{
+  fpu_control_t cw;
+
+  /* Save the current state.  */
+  _FPU_GETCW (cw);
+  envp->__fp_control_register = cw;
+
+  /* Clear all exception enable bits and flags.  */
+  cw &= ~(_FPU_MASK_V|_FPU_MASK_Z|_FPU_MASK_O|_FPU_MASK_U|_FPU_MASK_I|FE_ALL_EXCEPT);
+  _FPU_SETCW (cw);
+
+  return 0;
+}
+
+libm_hidden_def (feholdexcept)
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/fpu/fenv_libc.h glibc-2.14.1/sysdeps/riscv/fpu/fenv_libc.h
--- ../glibc-2.14.1-orig/sysdeps/riscv/fpu/fenv_libc.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/fpu/fenv_libc.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,32 @@
+/* Copyright (C) 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _FENV_LIBC_H
+#define _FENV_LIBC_H    1
+
+/* Mask for enabling exceptions and for the CAUSE bits.  */
+#define ENABLE_MASK	0x00F80U
+#define CAUSE_MASK	0x1F000U
+
+/* Shift for FE_* flags to get up to the ENABLE bits and the CAUSE bits.  */
+#define	ENABLE_SHIFT	5
+#define	CAUSE_SHIFT	10
+
+
+#endif /* _FENV_LIBC_H */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/fpu/fesetenv.c glibc-2.14.1/sysdeps/riscv/fpu/fesetenv.c
--- ../glibc-2.14.1-orig/sysdeps/riscv/fpu/fesetenv.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/fpu/fesetenv.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,43 @@
+/* Install given floating-point environment.
+   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+fesetenv (const fenv_t *envp)
+{
+  fpu_control_t cw;
+
+  /* Read first current state to flush fpu pipeline.  */
+  _FPU_GETCW (cw);
+
+  if (envp == FE_DFL_ENV)
+    _FPU_SETCW (_FPU_DEFAULT);
+  else if (envp == FE_NOMASK_ENV)
+    _FPU_SETCW (_FPU_IEEE);
+  else
+    _FPU_SETCW (envp->__fp_control_register);
+
+  /* Success.  */
+  return 0;
+}
+
+libm_hidden_def (fesetenv)
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/fpu/fesetround.c glibc-2.14.1/sysdeps/riscv/fpu/fesetround.c
--- ../glibc-2.14.1-orig/sysdeps/riscv/fpu/fesetround.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/fpu/fesetround.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,45 @@
+/* Set current rounding direction.
+   Copyright (C) 1998 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@arthur.rhein-neckar.de>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+fesetround (int round)
+{
+  fpu_control_t cw;
+
+  if ((round & ~0x3) != 0)
+    /* ROUND is no valid rounding mode.  */
+    return 1;
+
+  /* Get current state.  */
+  _FPU_GETCW (cw);
+
+  /* Set rounding bits.  */
+  cw &= ~0x3;
+  cw |= round;
+  /* Set new state.  */
+  _FPU_SETCW (cw);
+
+  return 0;
+}
+
+libm_hidden_def (fesetround)
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/fpu/feupdateenv.c glibc-2.14.1/sysdeps/riscv/fpu/feupdateenv.c
--- ../glibc-2.14.1-orig/sysdeps/riscv/fpu/feupdateenv.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/fpu/feupdateenv.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,44 @@
+/* Install given floating-point environment and raise exceptions.
+   Copyright (C) 1998, 1999, 2000, 2002, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+feupdateenv (const fenv_t *envp)
+{
+  int temp;
+
+  /* Save current exceptions.  */
+  _FPU_GETCW (temp);
+  temp &= FE_ALL_EXCEPT;
+
+  /* Install new environment.  */
+  fesetenv (envp);
+
+  /* Raise the safed exception.  Incidently for us the implementation
+     defined format of the values in objects of type fexcept_t is the
+     same as the ones specified using the FE_* constants.  */
+  feraiseexcept (temp);
+
+  /* Success.  */
+  return 0;
+}
+libm_hidden_def (feupdateenv)
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/fpu/fgetexcptflg.c glibc-2.14.1/sysdeps/riscv/fpu/fgetexcptflg.c
--- ../glibc-2.14.1-orig/sysdeps/riscv/fpu/fgetexcptflg.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/fpu/fgetexcptflg.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,40 @@
+/* Store current representation for exceptions.
+   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+fegetexceptflag (fexcept_t *flagp, int excepts)
+{
+  fpu_control_t temp;
+
+  /* Get the current exceptions.  */
+  _FPU_GETCW (temp);
+
+  /* We only save the relevant bits here. In particular, care has to be 
+     taken with the CAUSE bits, as an inadvertent restore later on could
+     generate unexpected exceptions.  */
+
+  *flagp = temp & excepts & FE_ALL_EXCEPT;
+
+  /* Success.  */
+  return 0;
+}
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/fpu/fraiseexcpt.c glibc-2.14.1/sysdeps/riscv/fpu/fraiseexcpt.c
--- ../glibc-2.14.1-orig/sysdeps/riscv/fpu/fraiseexcpt.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/fpu/fraiseexcpt.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,47 @@
+/* Raise given exceptions.
+   Copyright (C) 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fenv_libc.h>
+#include <fpu_control.h>
+
+int
+feraiseexcept (int excepts)
+{
+  fpu_control_t cw;
+
+  /* Get current state.  */
+  _FPU_GETCW (cw);
+
+  /* Set flag bits (which are accumulative), and *also* set the 
+     cause bits. The setting of the cause bits is what actually causes
+     the hardware to generate the exception, if the corresponding enable
+     bit is set as well.  */
+
+  excepts &= FE_ALL_EXCEPT;
+  cw |= excepts | (excepts << CAUSE_SHIFT);
+
+  /* Set new state.  */
+  _FPU_SETCW (cw);
+
+  return 0;
+}
+
+libm_hidden_def (feraiseexcept)
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/fpu/fsetexcptflg.c glibc-2.14.1/sysdeps/riscv/fpu/fsetexcptflg.c
--- ../glibc-2.14.1-orig/sysdeps/riscv/fpu/fsetexcptflg.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/fpu/fsetexcptflg.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,43 @@
+/* Set floating-point environment exception handling.
+   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Hartvig Ekner <hartvige@mips.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+fesetexceptflag (const fexcept_t *flagp, int excepts)
+{
+  fpu_control_t temp;
+
+  /* Get the current exceptions.  */
+  _FPU_GETCW (temp);
+
+  /* Make sure the flags we want restored are legal.  */
+  excepts &= FE_ALL_EXCEPT;
+
+  /* Now clear the bits called for, and copy them in from flagp. Note that
+     we ignore all non-flag bits from *flagp, so they don't matter.  */
+  temp = (temp & ~excepts) | (*flagp & excepts);
+
+  _FPU_SETCW (temp);
+
+  /* Success.  */
+  return 0;
+}
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/fpu/ftestexcept.c glibc-2.14.1/sysdeps/riscv/fpu/ftestexcept.c
--- ../glibc-2.14.1-orig/sysdeps/riscv/fpu/ftestexcept.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/fpu/ftestexcept.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,34 @@
+/* Test exception in current environment.
+   Copyright (C) 1998, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@arthur.rhein-neckar.de>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+fetestexcept (int excepts)
+{
+  int cw;
+
+  /* Get current control word.  */
+  _FPU_GETCW (cw);
+
+  return cw & excepts & FE_ALL_EXCEPT;
+}
+libm_hidden_def (fetestexcept)
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/fpu/libm-test-ulps glibc-2.14.1/sysdeps/riscv/fpu/libm-test-ulps
--- ../glibc-2.14.1-orig/sysdeps/riscv/fpu/libm-test-ulps	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/fpu/libm-test-ulps	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,890 @@
+# Begin of automatic generation
+
+# atan2
+Test "atan2 (-0.75, -1.0) == -2.49809154479650885165983415456218025":
+float: 3
+ifloat: 3
+Test "atan2 (0.75, -1.0) == 2.49809154479650885165983415456218025":
+float: 3
+ifloat: 3
+Test "atan2 (1.390625, 0.9296875) == 0.981498387184244311516296577615519772":
+float: 1
+ifloat: 1
+
+# atanh
+Test "atanh (0.75) == 0.972955074527656652552676371721589865":
+float: 1
+ifloat: 1
+
+# cacosh
+Test "Real part of: cacosh (-2 - 3 i) == 1.9833870299165354323470769028940395 - 2.1414491111159960199416055713254211 i":
+double: 1
+float: 7
+idouble: 1
+ifloat: 7
+Test "Imaginary part of: cacosh (-2 - 3 i) == 1.9833870299165354323470769028940395 - 2.1414491111159960199416055713254211 i":
+double: 1
+float: 3
+idouble: 1
+ifloat: 3
+
+# casin
+Test "Real part of: casin (0.75 + 1.25 i) == 0.453276177638793913448921196101971749 + 1.13239363160530819522266333696834467 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+# casinh
+Test "Real part of: casinh (-2 - 3 i) == -1.9686379257930962917886650952454982 - 0.96465850440760279204541105949953237 i":
+double: 5
+float: 1
+idouble: 5
+ifloat: 1
+Test "Imaginary part of: casinh (-2 - 3 i) == -1.9686379257930962917886650952454982 - 0.96465850440760279204541105949953237 i":
+double: 3
+float: 6
+idouble: 3
+ifloat: 6
+Test "Real part of: casinh (0.75 + 1.25 i) == 1.03171853444778027336364058631006594 + 0.911738290968487636358489564316731207 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: casinh (0.75 + 1.25 i) == 1.03171853444778027336364058631006594 + 0.911738290968487636358489564316731207 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+# catan
+Test "Real part of: catan (-2 - 3 i) == -1.4099210495965755225306193844604208 - 0.22907268296853876629588180294200276 i":
+float: 3
+ifloat: 3
+Test "Imaginary part of: catan (-2 - 3 i) == -1.4099210495965755225306193844604208 - 0.22907268296853876629588180294200276 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Real part of: catan (0.75 + 1.25 i) == 1.10714871779409050301706546017853704 + 0.549306144334054845697622618461262852 i":
+float: 4
+ifloat: 4
+
+# catanh
+Test "Real part of: catanh (-2 - 3 i) == -0.14694666622552975204743278515471595 - 1.3389725222944935611241935759091443 i":
+double: 4
+idouble: 4
+Test "Imaginary part of: catanh (-2 - 3 i) == -0.14694666622552975204743278515471595 - 1.3389725222944935611241935759091443 i":
+float: 4
+ifloat: 4
+Test "Real part of: catanh (0.75 + 1.25 i) == 0.261492138795671927078652057366532140 + 0.996825126463918666098902241310446708 i":
+double: 1
+idouble: 1
+Test "Imaginary part of: catanh (0.75 + 1.25 i) == 0.261492138795671927078652057366532140 + 0.996825126463918666098902241310446708 i":
+float: 6
+ifloat: 6
+
+# cbrt
+Test "cbrt (-27.0) == -3.0":
+double: 1
+idouble: 1
+Test "cbrt (0.75) == 0.908560296416069829445605878163630251":
+double: 1
+idouble: 1
+Test "cbrt (0.9921875) == 0.997389022060725270579075195353955217":
+double: 1
+idouble: 1
+
+# ccos
+Test "Imaginary part of: ccos (-2 - 3 i) == -4.18962569096880723013255501961597373 - 9.10922789375533659797919726277886212 i":
+float: 1
+ifloat: 1
+Test "Real part of: ccos (0.75 + 1.25 i) == 1.38173873063425888530729933139078645 - 1.09193013555397466170919531722024128 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: ccos (0.75 + 1.25 i) == 1.38173873063425888530729933139078645 - 1.09193013555397466170919531722024128 i":
+float: 1
+ifloat: 1
+
+# ccosh
+Test "Real part of: ccosh (-2 - 3 i) == -3.72454550491532256547397070325597253 + 0.511822569987384608834463849801875634 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: ccosh (-2 - 3 i) == -3.72454550491532256547397070325597253 + 0.511822569987384608834463849801875634 i":
+float: 1
+ifloat: 1
+Test "Real part of: ccosh (0.75 + 1.25 i) == 0.408242591877968807788852146397499084 + 0.780365930845853240391326216300863152 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: ccosh (0.75 + 1.25 i) == 0.408242591877968807788852146397499084 + 0.780365930845853240391326216300863152 i":
+float: 1
+ifloat: 1
+
+# cexp
+Test "Imaginary part of: cexp (-2.0 - 3.0 i) == -0.13398091492954261346140525546115575 - 0.019098516261135196432576240858800925 i":
+float: 1
+ifloat: 1
+Test "Real part of: cexp (0.75 + 1.25 i) == 0.667537446429131586942201977015932112 + 2.00900045494094876258347228145863909 i":
+float: 1
+ifloat: 1
+
+# clog
+Test "Imaginary part of: clog (-2 - 3 i) == 1.2824746787307683680267437207826593 - 2.1587989303424641704769327722648368 i":
+float: 3
+ifloat: 3
+Test "Real part of: clog (0.75 + 1.25 i) == 0.376885901188190075998919126749298416 + 1.03037682652431246378774332703115153 i":
+float: 1
+ifloat: 1
+
+# clog10
+Test "Imaginary part of: clog10 (-0 + inf i) == inf + pi/2*log10(e) i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-0 - inf i) == inf - pi/2*log10(e) i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-2 - 3 i) == 0.556971676153418384603252578971164214 - 0.937554462986374708541507952140189646 i":
+double: 1
+float: 5
+idouble: 1
+ifloat: 5
+Test "Imaginary part of: clog10 (-3 + inf i) == inf + pi/2*log10(e) i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-3 - inf i) == inf - pi/2*log10(e) i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-inf + 0 i) == inf + pi*log10(e) i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-inf + 1 i) == inf + pi*log10(e) i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-inf - 0 i) == inf - pi*log10(e) i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-inf - 1 i) == inf - pi*log10(e) i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (0 + inf i) == inf + pi/2*log10(e) i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (0 - inf i) == inf - pi/2*log10(e) i":
+float: 1
+ifloat: 1
+Test "Real part of: clog10 (0.75 + 1.25 i) == 0.163679467193165171449476605077428975 + 0.447486970040493067069984724340855636 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (3 + inf i) == inf + pi/2*log10(e) i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (3 - inf i) == inf - pi/2*log10(e) i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (inf + inf i) == inf + pi/4*log10(e) i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (inf - inf i) == inf - pi/4*log10(e) i":
+float: 1
+ifloat: 1
+
+# cos
+Test "cos (M_PI_6l * 2.0) == 0.5":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "cos (M_PI_6l * 4.0) == -0.5":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "cos (pi/2) == 0":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+# cpow
+Test "Real part of: cpow (0.75 + 1.25 i, 0.0 + 1.0 i) == 0.331825439177608832276067945276730566 + 0.131338600281188544930936345230903032 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: cpow (0.75 + 1.25 i, 0.0 + 1.0 i) == 0.331825439177608832276067945276730566 + 0.131338600281188544930936345230903032 i":
+float: 1
+ifloat: 1
+Test "Real part of: cpow (0.75 + 1.25 i, 0.75 + 1.25 i) == 0.117506293914473555420279832210420483 + 0.346552747708338676483025352060418001 i":
+double: 1
+float: 4
+idouble: 1
+ifloat: 4
+Test "Real part of: cpow (0.75 + 1.25 i, 1.0 + 1.0 i) == 0.0846958290317209430433805274189191353 + 0.513285749182902449043287190519090481 i":
+double: 2
+float: 3
+idouble: 2
+ifloat: 3
+Test "Real part of: cpow (2 + 3 i, 4 + 0 i) == -119.0 - 120.0 i":
+double: 1
+float: 4
+idouble: 1
+ifloat: 4
+Test "Imaginary part of: cpow (2 + 3 i, 4 + 0 i) == -119.0 - 120.0 i":
+float: 2
+ifloat: 2
+Test "Imaginary part of: cpow (e + 0 i, 0 + 2 * M_PIl i) == 1.0 + 0.0 i":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+
+# csinh
+Test "Imaginary part of: csinh (-2 - 3 i) == 3.59056458998577995201256544779481679 - 0.530921086248519805267040090660676560 i":
+double: 1
+idouble: 1
+Test "Real part of: csinh (0.75 + 1.25 i) == 0.259294854551162779153349830618433028 + 1.22863452409509552219214606515777594 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: csinh (0.75 + 1.25 i) == 0.259294854551162779153349830618433028 + 1.22863452409509552219214606515777594 i":
+float: 1
+ifloat: 1
+
+# csqrt
+Test "Real part of: csqrt (-2 + 3 i) == 0.89597747612983812471573375529004348 + 1.6741492280355400404480393008490519 i":
+float: 1
+ifloat: 1
+Test "Real part of: csqrt (-2 - 3 i) == 0.89597747612983812471573375529004348 - 1.6741492280355400404480393008490519 i":
+float: 1
+ifloat: 1
+
+# ctan
+Test "Real part of: ctan (-2 - 3 i) == 0.376402564150424829275122113032269084e-2 - 1.00323862735360980144635859782192726 i":
+double: 1
+idouble: 1
+Test "Imaginary part of: ctan (0.75 + 1.25 i) == 0.160807785916206426725166058173438663 + 0.975363285031235646193581759755216379 i":
+double: 1
+idouble: 1
+
+# ctanh
+Test "Real part of: ctanh (-2 - 3 i) == -0.965385879022133124278480269394560686 + 0.988437503832249372031403430350121098e-2 i":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+Test "Imaginary part of: ctanh (0 + pi/4 i) == 0.0 + 1.0 i":
+float: 1
+ifloat: 1
+Test "Real part of: ctanh (0.75 + 1.25 i) == 1.37260757053378320258048606571226857 + 0.385795952609750664177596760720790220 i":
+double: 1
+idouble: 1
+
+# erf
+Test "erf (1.25) == 0.922900128256458230136523481197281140":
+double: 1
+idouble: 1
+
+# erfc
+Test "erfc (2.0) == 0.00467773498104726583793074363274707139":
+double: 1
+idouble: 1
+Test "erfc (4.125) == 0.542340079956506600531223408575531062e-8":
+double: 1
+idouble: 1
+
+# exp10
+Test "exp10 (-1) == 0.1":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "exp10 (0.75) == 5.62341325190349080394951039776481231":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "exp10 (3) == 1000":
+double: 6
+float: 2
+idouble: 6
+ifloat: 2
+
+# expm1
+Test "expm1 (0.75) == 1.11700001661267466854536981983709561":
+double: 1
+idouble: 1
+Test "expm1 (1) == M_El - 1.0":
+float: 1
+ifloat: 1
+
+# hypot
+Test "hypot (-0.7, -12.4) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (-0.7, 12.4) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (-12.4, -0.7) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (-12.4, 0.7) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (0.7, -12.4) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (0.7, 12.4) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (12.4, -0.7) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (12.4, 0.7) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+
+# j0
+Test "j0 (-4.0) == -3.9714980986384737228659076845169804197562E-1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "j0 (0.75) == 0.864242275166648623555731103820923211":
+float: 1
+ifloat: 1
+Test "j0 (10.0) == -0.245935764451348335197760862485328754":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "j0 (2.0) == 0.223890779141235668051827454649948626":
+float: 2
+ifloat: 2
+Test "j0 (4.0) == -3.9714980986384737228659076845169804197562E-1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "j0 (8.0) == 0.171650807137553906090869407851972001":
+float: 1
+ifloat: 1
+
+# j1
+Test "j1 (10.0) == 0.0434727461688614366697487680258592883":
+float: 2
+ifloat: 2
+Test "j1 (2.0) == 0.576724807756873387202448242269137087":
+double: 1
+idouble: 1
+Test "j1 (8.0) == 0.234636346853914624381276651590454612":
+double: 1
+idouble: 1
+
+# jn
+Test "jn (0, -4.0) == -3.9714980986384737228659076845169804197562E-1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "jn (0, 0.75) == 0.864242275166648623555731103820923211":
+float: 1
+ifloat: 1
+Test "jn (0, 10.0) == -0.245935764451348335197760862485328754":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "jn (0, 2.0) == 0.223890779141235668051827454649948626":
+float: 2
+ifloat: 2
+Test "jn (0, 4.0) == -3.9714980986384737228659076845169804197562E-1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "jn (0, 8.0) == 0.171650807137553906090869407851972001":
+float: 1
+ifloat: 1
+Test "jn (1, 10.0) == 0.0434727461688614366697487680258592883":
+float: 2
+ifloat: 2
+Test "jn (1, 2.0) == 0.576724807756873387202448242269137087":
+double: 1
+idouble: 1
+Test "jn (1, 8.0) == 0.234636346853914624381276651590454612":
+double: 1
+idouble: 1
+Test "jn (10, 0.125) == 0.250543369809369890173993791865771547e-18":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "jn (10, 0.75) == 0.149621713117596814698712483621682835e-10":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "jn (10, 10.0) == 0.207486106633358857697278723518753428":
+double: 4
+float: 3
+idouble: 4
+ifloat: 3
+Test "jn (10, 2.0) == 0.251538628271673670963516093751820639e-6":
+float: 4
+ifloat: 4
+Test "jn (3, 0.125) == 0.406503832554912875023029337653442868e-4":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "jn (3, 0.75) == 0.848438342327410884392755236884386804e-2":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "jn (3, 10.0) == 0.0583793793051868123429354784103409563":
+double: 3
+float: 1
+idouble: 3
+ifloat: 1
+Test "jn (3, 2.0) == 0.128943249474402051098793332969239835":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+
+# lgamma
+Test "lgamma (0.7) == 0.260867246531666514385732417016759578":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "lgamma (1.2) == -0.853740900033158497197028392998854470e-1":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+
+# log10
+Test "log10 (0.75) == -0.124938736608299953132449886193870744":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+Test "log10 (e) == log10(e)":
+float: 1
+ifloat: 1
+
+# log1p
+Test "log1p (-0.25) == -0.287682072451780927439219005993827432":
+float: 1
+ifloat: 1
+
+# sincos
+Test "sincos (M_PI_6l*2.0, &sin_res, &cos_res) puts 0.5 in cos_res":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "sincos (M_PI_6l*2.0, &sin_res, &cos_res) puts 0.86602540378443864676372317075293616 in sin_res":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "sincos (pi/2, &sin_res, &cos_res) puts 0 in cos_res":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "sincos (pi/6, &sin_res, &cos_res) puts 0.86602540378443864676372317075293616 in cos_res":
+float: 1
+ifloat: 1
+
+# tan
+Test "tan (pi/4) == 1":
+double: 1
+idouble: 1
+
+# tgamma
+Test "tgamma (-0.5) == -2 sqrt (pi)":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "tgamma (0.5) == sqrt (pi)":
+float: 1
+ifloat: 1
+Test "tgamma (0.7) == 1.29805533264755778568117117915281162":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+# y0
+Test "y0 (1.0) == 0.0882569642156769579829267660235151628":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "y0 (1.5) == 0.382448923797758843955068554978089862":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "y0 (10.0) == 0.0556711672835993914244598774101900481":
+float: 1
+ifloat: 1
+Test "y0 (8.0) == 0.223521489387566220527323400498620359":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+# y1
+Test "y1 (0.125) == -5.19993611253477499595928744876579921":
+double: 1
+idouble: 1
+Test "y1 (1.5) == -0.412308626973911295952829820633445323":
+float: 1
+ifloat: 1
+Test "y1 (10.0) == 0.249015424206953883923283474663222803":
+double: 3
+float: 1
+idouble: 3
+ifloat: 1
+Test "y1 (2.0) == -0.107032431540937546888370772277476637":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "y1 (8.0) == -0.158060461731247494255555266187483550":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+
+# yn
+Test "yn (0, 1.0) == 0.0882569642156769579829267660235151628":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "yn (0, 1.5) == 0.382448923797758843955068554978089862":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "yn (0, 10.0) == 0.0556711672835993914244598774101900481":
+float: 1
+ifloat: 1
+Test "yn (0, 8.0) == 0.223521489387566220527323400498620359":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "yn (1, 0.125) == -5.19993611253477499595928744876579921":
+double: 1
+idouble: 1
+Test "yn (1, 1.5) == -0.412308626973911295952829820633445323":
+float: 1
+ifloat: 1
+Test "yn (1, 10.0) == 0.249015424206953883923283474663222803":
+double: 3
+float: 1
+idouble: 3
+ifloat: 1
+Test "yn (1, 2.0) == -0.107032431540937546888370772277476637":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "yn (1, 8.0) == -0.158060461731247494255555266187483550":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+Test "yn (10, 0.125) == -127057845771019398.252538486899753195":
+double: 1
+idouble: 1
+Test "yn (10, 0.75) == -2133501638.90573424452445412893839236":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "yn (10, 1.0) == -121618014.278689189288130426667971145":
+double: 1
+idouble: 1
+Test "yn (10, 10.0) == -0.359814152183402722051986577343560609":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "yn (10, 2.0) == -129184.542208039282635913145923304214":
+double: 2
+idouble: 2
+Test "yn (3, 0.125) == -2612.69757350066712600220955744091741":
+double: 1
+idouble: 1
+Test "yn (3, 0.75) == -12.9877176234475433186319774484809207":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "yn (3, 10.0) == -0.251362657183837329779204747654240998":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "yn (3, 2.0) == -1.12778377684042778608158395773179238":
+double: 1
+idouble: 1
+
+# Maximal error of functions:
+Function: "atan2":
+float: 3
+ifloat: 3
+
+Function: "atanh":
+float: 1
+ifloat: 1
+
+Function: Real part of "cacosh":
+double: 1
+float: 7
+idouble: 1
+ifloat: 7
+
+Function: Imaginary part of "cacosh":
+double: 1
+float: 3
+idouble: 1
+ifloat: 3
+
+Function: Real part of "casin":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+Function: Real part of "casinh":
+double: 5
+float: 1
+idouble: 5
+ifloat: 1
+
+Function: Imaginary part of "casinh":
+double: 3
+float: 6
+idouble: 3
+ifloat: 6
+
+Function: Real part of "catan":
+float: 4
+ifloat: 4
+
+Function: Imaginary part of "catan":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+Function: Real part of "catanh":
+double: 4
+idouble: 4
+
+Function: Imaginary part of "catanh":
+float: 6
+ifloat: 6
+
+Function: "cbrt":
+double: 1
+idouble: 1
+
+Function: Real part of "ccos":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+Function: Imaginary part of "ccos":
+float: 1
+ifloat: 1
+
+Function: Real part of "ccosh":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+Function: Imaginary part of "ccosh":
+float: 1
+ifloat: 1
+
+Function: Real part of "cexp":
+float: 1
+ifloat: 1
+
+Function: Imaginary part of "cexp":
+float: 1
+ifloat: 1
+
+Function: Real part of "clog":
+float: 1
+ifloat: 1
+
+Function: Imaginary part of "clog":
+float: 3
+ifloat: 3
+
+Function: Real part of "clog10":
+float: 1
+ifloat: 1
+
+Function: Imaginary part of "clog10":
+double: 1
+float: 5
+idouble: 1
+ifloat: 5
+
+Function: "cos":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+
+Function: Real part of "cpow":
+double: 2
+float: 4
+idouble: 2
+ifloat: 4
+
+Function: Imaginary part of "cpow":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+
+Function: Real part of "csinh":
+float: 1
+ifloat: 1
+
+Function: Imaginary part of "csinh":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+Function: Real part of "csqrt":
+float: 1
+ifloat: 1
+
+Function: Real part of "ctan":
+double: 1
+idouble: 1
+
+Function: Imaginary part of "ctan":
+double: 1
+idouble: 1
+
+Function: Real part of "ctanh":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+
+Function: Imaginary part of "ctanh":
+float: 1
+ifloat: 1
+
+Function: "erf":
+double: 1
+idouble: 1
+
+Function: "erfc":
+double: 1
+idouble: 1
+
+Function: "exp10":
+double: 6
+float: 2
+idouble: 6
+ifloat: 2
+
+Function: "expm1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+Function: "hypot":
+float: 1
+ifloat: 1
+
+Function: "j0":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+
+Function: "j1":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+
+Function: "jn":
+double: 4
+float: 4
+idouble: 4
+ifloat: 4
+
+Function: "lgamma":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+
+Function: "log10":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+
+Function: "log1p":
+float: 1
+ifloat: 1
+
+Function: "sincos":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+Function: "tan":
+double: 1
+idouble: 1
+
+Function: "tgamma":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+Function: "y0":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+
+Function: "y1":
+double: 3
+float: 2
+idouble: 3
+ifloat: 2
+
+Function: "yn":
+double: 3
+float: 2
+idouble: 3
+ifloat: 2
+
+# end of automatic generation
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/fpu_control.h glibc-2.14.1/sysdeps/riscv/fpu_control.h
--- ../glibc-2.14.1-orig/sysdeps/riscv/fpu_control.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/fpu_control.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,112 @@
+/* FPU control word bits.  Mips version.
+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2006, 2008
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Olaf Flebbe and Ralf Baechle.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _FPU_CONTROL_H
+#define _FPU_CONTROL_H
+
+/* MIPS FPU floating point control register bits.
+ *
+ * 31-25  -> floating point conditions code bits 7-1.  These bits are only
+ *           available in MIPS IV.
+ * 24     -> flush denormalized results to zero instead of
+ *           causing unimplemented operation exception.  This bit is only
+ *           available for MIPS III and newer.
+ * 23     -> Condition bit
+ * 22-18  -> reserved (read as 0, write with 0)
+ * 17     -> cause bit for unimplemented operation
+ * 16     -> cause bit for invalid exception
+ * 15     -> cause bit for division by zero exception
+ * 14     -> cause bit for overflow exception
+ * 13     -> cause bit for underflow exception
+ * 12     -> cause bit for inexact exception
+ * 11     -> enable exception for invalid exception
+ * 10     -> enable exception for division by zero exception
+ *  9     -> enable exception for overflow exception
+ *  8     -> enable exception for underflow exception
+ *  7     -> enable exception for inexact exception
+ *  6     -> flag invalid exception
+ *  5     -> flag division by zero exception
+ *  4     -> flag overflow exception
+ *  3     -> flag underflow exception
+ *  2     -> flag inexact exception
+ *  1-0   -> rounding control
+ *
+ *
+ * Rounding Control:
+ * 00 - rounding to nearest (RN)
+ * 01 - rounding toward zero (RZ)
+ * 10 - rounding (up) toward plus infinity (RP)
+ * 11 - rounding (down)toward minus infinity (RM)
+ */
+
+#include <features.h>
+
+#ifdef __mips_soft_float
+
+#define _FPU_RESERVED 0xffffffff
+#define _FPU_DEFAULT  0x00000000
+typedef unsigned int fpu_control_t;
+#define _FPU_GETCW(cw) 0
+#define _FPU_SETCW(cw) do { } while (0)
+extern fpu_control_t __fpu_control;
+
+#else /* __mips_soft_float */
+
+/* masking of interrupts */
+#define _FPU_MASK_V     0x0800  /* Invalid operation */
+#define _FPU_MASK_Z     0x0400  /* Division by zero  */
+#define _FPU_MASK_O     0x0200  /* Overflow          */
+#define _FPU_MASK_U     0x0100  /* Underflow         */
+#define _FPU_MASK_I     0x0080  /* Inexact operation */
+
+/* flush denormalized numbers to zero */
+#define _FPU_FLUSH_TZ   0x1000000
+
+/* rounding control */
+#define _FPU_RC_NEAREST 0x0     /* RECOMMENDED */
+#define _FPU_RC_ZERO    0x1
+#define _FPU_RC_UP      0x2
+#define _FPU_RC_DOWN    0x3
+
+#define _FPU_RESERVED 0xfe3c0000  /* Reserved bits in cw */
+
+
+/* The fdlibm code requires strict IEEE double precision arithmetic,
+   and no interrupts for exceptions, rounding to nearest.  */
+
+#define _FPU_DEFAULT  0x00000000
+
+/* IEEE:  same as above, but exceptions */
+#define _FPU_IEEE     0x00000F80
+
+/* Type of the control word.  */
+typedef unsigned int fpu_control_t __attribute__ ((__mode__ (__SI__)));
+
+/* Macros for accessing the hardware control word.  */
+#define _FPU_GETCW(cw) __asm__ volatile ("mffsr %0" : "=r" (cw))
+#define _FPU_SETCW(cw) __asm__ volatile ("mtfsr %0" : : "r" (cw))
+
+/* Default control word set at startup.  */
+extern fpu_control_t __fpu_control;
+
+#endif /* __mips_soft_float */
+
+#endif	/* fpu_control.h */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/gccframe.h glibc-2.14.1/sysdeps/riscv/gccframe.h
--- ../glibc-2.14.1-orig/sysdeps/riscv/gccframe.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/gccframe.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,22 @@
+/* Definition of object in frame unwind info.  mips version.
+   Copyright (C) 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define FIRST_PSEUDO_REGISTER 76
+
+#include <sysdeps/generic/gccframe.h>
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/ieee754.h glibc-2.14.1/sysdeps/riscv/ieee754.h
--- ../glibc-2.14.1-orig/sysdeps/riscv/ieee754.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/ieee754.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,325 @@
+/* Copyright (C) 1992, 1995, 1996, 1999, 2002, 2003
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _IEEE754_H
+
+#define _IEEE754_H 1
+#include <features.h>
+
+#include <endian.h>
+
+#include <float.h>
+
+__BEGIN_DECLS
+
+union ieee754_float
+  {
+    float f;
+
+    /* This is the IEEE 754 single-precision format.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:8;
+	unsigned int mantissa:23;
+#endif				/* Big endian.  */
+#if	__BYTE_ORDER == __LITTLE_ENDIAN
+	unsigned int mantissa:23;
+	unsigned int exponent:8;
+	unsigned int negative:1;
+#endif				/* Little endian.  */
+      } ieee;
+
+    /* This format makes it easier to see if a NaN is a signalling NaN.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:8;
+	unsigned int quiet_nan:1;
+	unsigned int mantissa:22;
+#endif				/* Big endian.  */
+#if	__BYTE_ORDER == __LITTLE_ENDIAN
+	unsigned int mantissa:22;
+	unsigned int quiet_nan:1;
+	unsigned int exponent:8;
+	unsigned int negative:1;
+#endif				/* Little endian.  */
+      } ieee_nan;
+  };
+
+#define IEEE754_FLOAT_BIAS	0x7f /* Added to exponent.  */
+
+
+union ieee754_double
+  {
+    double d;
+
+    /* This is the IEEE 754 double-precision format.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:11;
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa0:20;
+	unsigned int mantissa1:32;
+#endif				/* Big endian.  */
+#if	__BYTE_ORDER == __LITTLE_ENDIAN
+# if	__FLOAT_WORD_ORDER == __BIG_ENDIAN
+	unsigned int mantissa0:20;
+	unsigned int exponent:11;
+	unsigned int negative:1;
+	unsigned int mantissa1:32;
+# else
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa1:32;
+	unsigned int mantissa0:20;
+	unsigned int exponent:11;
+	unsigned int negative:1;
+# endif
+#endif				/* Little endian.  */
+      } ieee;
+
+    /* This format makes it easier to see if a NaN is a signalling NaN.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:11;
+	unsigned int quiet_nan:1;
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa0:19;
+	unsigned int mantissa1:32;
+#else
+# if	__FLOAT_WORD_ORDER == __BIG_ENDIAN
+	unsigned int mantissa0:19;
+	unsigned int quiet_nan:1;
+	unsigned int exponent:11;
+	unsigned int negative:1;
+	unsigned int mantissa1:32;
+# else
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa1:32;
+	unsigned int mantissa0:19;
+	unsigned int quiet_nan:1;
+	unsigned int exponent:11;
+	unsigned int negative:1;
+# endif
+#endif
+      } ieee_nan;
+  };
+
+#define IEEE754_DOUBLE_BIAS	0x3ff /* Added to exponent.  */
+
+#if LDBL_MANT_DIG == 113
+
+union ieee854_long_double
+  {
+    long double d;
+
+    /* This is the IEEE 854 quad-precision format.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:15;
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa0:16;
+	unsigned int mantissa1:32;
+	unsigned int mantissa2:32;
+	unsigned int mantissa3:32;
+#endif				/* Big endian.  */
+#if	__BYTE_ORDER == __LITTLE_ENDIAN
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa3:32;
+	unsigned int mantissa2:32;
+	unsigned int mantissa1:32;
+	unsigned int mantissa0:16;
+	unsigned int exponent:15;
+	unsigned int negative:1;
+#endif				/* Little endian.  */
+      } ieee;
+
+    /* This format makes it easier to see if a NaN is a signalling NaN.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:15;
+	unsigned int quiet_nan:1;
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa0:15;
+	unsigned int mantissa1:32;
+	unsigned int mantissa2:32;
+	unsigned int mantissa3:32;
+#endif				/* Big endian.  */
+#if	__BYTE_ORDER == __LITTLE_ENDIAN
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa3:32;
+	unsigned int mantissa2:32;
+	unsigned int mantissa1:32;
+	unsigned int mantissa0:15;
+	unsigned int quiet_nan:1;
+	unsigned int exponent:15;
+	unsigned int negative:1;
+#endif				/* Little endian.  */
+      } ieee_nan;
+  };
+
+#define IEEE854_LONG_DOUBLE_BIAS 0x3fff /* Added to exponent.  */
+
+#elif LDBL_MANT_DIG == 64
+
+union ieee854_long_double
+  {
+    long double d;
+
+    /* This is the IEEE 854 double-extended-precision format.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:15;
+	unsigned int empty:16;
+	unsigned int mantissa0:32;
+	unsigned int mantissa1:32;
+#endif
+#if	__BYTE_ORDER == __LITTLE_ENDIAN
+# if	__FLOAT_WORD_ORDER == __BIG_ENDIAN
+	unsigned int exponent:15;
+	unsigned int negative:1;
+	unsigned int empty:16;
+	unsigned int mantissa0:32;
+	unsigned int mantissa1:32;
+# else
+	unsigned int mantissa1:32;
+	unsigned int mantissa0:32;
+	unsigned int exponent:15;
+	unsigned int negative:1;
+	unsigned int empty:16;
+# endif
+#endif
+      } ieee;
+
+    /* This is for NaNs in the IEEE 854 double-extended-precision format.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:15;
+	unsigned int empty:16;
+	unsigned int one:1;
+	unsigned int quiet_nan:1;
+	unsigned int mantissa0:30;
+	unsigned int mantissa1:32;
+#endif
+#if	__BYTE_ORDER == __LITTLE_ENDIAN
+# if	__FLOAT_WORD_ORDER == __BIG_ENDIAN
+	unsigned int exponent:15;
+	unsigned int negative:1;
+	unsigned int empty:16;
+	unsigned int mantissa0:30;
+	unsigned int quiet_nan:1;
+	unsigned int one:1;
+	unsigned int mantissa1:32;
+# else
+	unsigned int mantissa1:32;
+	unsigned int mantissa0:30;
+	unsigned int quiet_nan:1;
+	unsigned int one:1;
+	unsigned int exponent:15;
+	unsigned int negative:1;
+	unsigned int empty:16;
+# endif
+#endif
+      } ieee_nan;
+  };
+
+#define IEEE854_LONG_DOUBLE_BIAS 0x3fff
+
+#elif LDBL_MANT_DIG == 53
+
+union ieee854_long_double
+  {
+    long double d;
+
+    /* This is the IEEE 754 double-precision format.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:11;
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa0:20;
+	unsigned int mantissa1:32;
+#endif				/* Big endian.  */
+#if	__BYTE_ORDER == __LITTLE_ENDIAN
+# if	__FLOAT_WORD_ORDER == __BIG_ENDIAN
+	unsigned int mantissa0:20;
+	unsigned int exponent:11;
+	unsigned int negative:1;
+	unsigned int mantissa1:32;
+# else
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa1:32;
+	unsigned int mantissa0:20;
+	unsigned int exponent:11;
+	unsigned int negative:1;
+# endif
+#endif				/* Little endian.  */
+      } ieee;
+
+    /* This format makes it easier to see if a NaN is a signalling NaN.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:11;
+	unsigned int quiet_nan:1;
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa0:19;
+	unsigned int mantissa1:32;
+#else
+# if	__FLOAT_WORD_ORDER == __BIG_ENDIAN
+	unsigned int mantissa0:19;
+	unsigned int quiet_nan:1;
+	unsigned int exponent:11;
+	unsigned int negative:1;
+	unsigned int mantissa1:32;
+# else
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa1:32;
+	unsigned int mantissa0:19;
+	unsigned int quiet_nan:1;
+	unsigned int exponent:11;
+	unsigned int negative:1;
+# endif
+#endif
+      } ieee_nan;
+  };
+
+#define IEEE854_LONG_DOUBLE_BIAS	0x3ff /* Added to exponent.  */
+
+#endif /* LDBL_MANT_DIG == 53 */
+
+__END_DECLS
+
+#endif /* ieee754.h */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/Implies glibc-2.14.1/sysdeps/riscv/Implies
--- ../glibc-2.14.1-orig/sysdeps/riscv/Implies	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/Implies	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,5 @@
+ieee754/flt-32
+ieee754/dbl-64
+
+# This needs to change to support rv32
+riscv/rv64
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/init-first.c glibc-2.14.1/sysdeps/riscv/init-first.c
--- ../glibc-2.14.1-orig/sysdeps/riscv/init-first.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/init-first.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,66 @@
+/* Initialization code run first thing by the ELF startup code.  For mips/Unix.
+   Copyright (C) 1996, 1997, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+
+extern void __libc_init (int, char **, char **);
+extern void __libc_global_ctors (void);
+
+
+static void
+init (int *data)
+{
+  int argc = *data;
+  char **argv = (void *) (data + 1);
+  char **envp = &argv[argc + 1];
+
+  __environ = envp;
+  __libc_init (argc, argv, envp);
+}
+
+#ifdef SHARED
+/* This function is called to initialize the shared C library.
+   It is called just before the user _start code from mips/elf/start.S,
+   with the stack set up as that code gets it.  */
+
+/* NOTE!  The linker notices the magical name `_init' and sets the DT_INIT
+   pointer in the dynamic section based solely on that.  It is convention
+   for this function to be in the `.init' section, but the symbol name is
+   the only thing that really matters!!  */
+/*void _init (int argc, ...) __attribute__ ((unused, section (".init")));*/
+
+void
+_init (int argc, ...)
+{
+  init (&argc);
+
+#ifndef NO_CTORS_DTORS_SECTIONS
+  __libc_global_ctors ();
+#endif
+}
+#endif
+
+
+void
+__libc_init_first (int argc __attribute__ ((unused)), ...)
+{
+#ifndef SHARED
+  init (&argc);
+#endif
+}
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/jmpbuf-unwind.h glibc-2.14.1/sysdeps/riscv/jmpbuf-unwind.h
--- ../glibc-2.14.1-orig/sysdeps/riscv/jmpbuf-unwind.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/jmpbuf-unwind.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,46 @@
+/* Copyright (C) 2003, 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <setjmp.h>
+#include <stdint.h>
+#include <unwind.h>
+#include <sysdep.h>
+
+/* Test if longjmp to JMPBUF would unwind the frame
+   containing a local variable at ADDRESS.  */
+#define _JMPBUF_UNWINDS(jmpbuf, address, demangle)		\
+  ((void *) (address) < (void *) demangle ((jmpbuf)[0].__sp))
+
+#define _JMPBUF_CFA_UNWINDS_ADJ(_jmpbuf, _context, _adj) \
+  _JMPBUF_UNWINDS_ADJ (_jmpbuf, (void *) _Unwind_GetCFA (_context), _adj)
+
+static inline uintptr_t __attribute__ ((unused))
+_jmpbuf_sp (__jmp_buf regs)
+{
+  uintptr_t sp = regs[0].__sp;
+#ifdef PTR_DEMANGLE
+  PTR_DEMANGLE (sp);
+#endif
+  return sp;
+}
+
+#define _JMPBUF_UNWINDS_ADJ(_jmpbuf, _address, _adj) \
+  ((uintptr_t) (_address) - (_adj) < _jmpbuf_sp (_jmpbuf) - (_adj))
+
+/* We use the normal longjmp for unwinding.  */
+#define __libc_unwind_longjmp(buf, val) __libc_longjmp (buf, val)
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/ldsodefs.h glibc-2.14.1/sysdeps/riscv/ldsodefs.h
--- ../glibc-2.14.1-orig/sysdeps/riscv/ldsodefs.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/ldsodefs.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,150 @@
+/* Run-time dynamic linker data structures for loaded ELF shared objects.
+   Copyright (C) 2000, 2002, 2003, 2006, 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _MIPS_LDSODEFS_H
+#define _MIPS_LDSODEFS_H 1
+
+#include <elf.h>
+
+struct La_mips_32_regs;
+struct La_mips_32_retval;
+struct La_mips_64_regs;
+struct La_mips_64_retval;
+
+#define ARCH_PLTENTER_MEMBERS						    \
+    Elf32_Addr (*mips_o32_gnu_pltenter) (Elf32_Sym *, unsigned int,	    \
+					 uintptr_t *, uintptr_t *,	    \
+					 const struct La_mips_32_regs *,    \
+					 unsigned int *, const char *name,  \
+					 long int *framesizep);		    \
+    Elf32_Addr (*mips_n32_gnu_pltenter) (Elf32_Sym *, unsigned int,	    \
+					 uintptr_t *, uintptr_t *,	    \
+					 const struct La_mips_64_regs *,    \
+					 unsigned int *, const char *name,  \
+					 long int *framesizep);		    \
+    Elf64_Addr (*mips_n64_gnu_pltenter) (Elf64_Sym *, unsigned int,	    \
+					 uintptr_t *, uintptr_t *,	    \
+					 const struct La_mips_64_regs *,    \
+					 unsigned int *, const char *name,  \
+					 long int *framesizep);
+
+#define ARCH_PLTEXIT_MEMBERS						    \
+    unsigned int (*mips_o32_gnu_pltexit) (Elf32_Sym *, unsigned int,	    \
+					  uintptr_t *, uintptr_t *,	    \
+					  const struct La_mips_32_regs *,   \
+					  struct La_mips_32_retval *,	    \
+					  const char *);		    \
+    unsigned int (*mips_n32_gnu_pltexit) (Elf32_Sym *, unsigned int,	    \
+					  uintptr_t *, uintptr_t *,	    \
+					  const struct La_mips_64_regs *,   \
+					  struct La_mips_64_retval *,	    \
+					  const char *);		    \
+    unsigned int (*mips_n64_gnu_pltexit) (Elf64_Sym *, unsigned int,	    \
+					  uintptr_t *, uintptr_t *,	    \
+					  const struct La_mips_64_regs *,   \
+					  struct La_mips_64_retval *,	    \
+					  const char *);
+
+/* The MIPS ABI specifies that the dynamic section has to be read-only.  */
+
+#define DL_RO_DYN_SECTION 1
+
+#include_next <ldsodefs.h>
+
+/* The 64-bit MIPS ELF ABI uses an unusual reloc format.  Each
+   relocation entry specifies up to three actual relocations, all at
+   the same address.  The first relocation which required a symbol
+   uses the symbol in the r_sym field.  The second relocation which
+   requires a symbol uses the symbol in the r_ssym field.  If all
+   three relocations require a symbol, the third one uses a zero
+   value.
+
+   We define these structures in internal headers because we're not
+   sure we want to make them part of the ABI yet.  Eventually, some of
+   this may move into elf/elf.h.  */
+
+/* An entry in a 64 bit SHT_REL section.  */
+
+typedef struct
+{
+  Elf32_Word    r_sym;		/* Symbol index */
+  unsigned char r_ssym;		/* Special symbol for 2nd relocation */
+  unsigned char r_type3;	/* 3rd relocation type */
+  unsigned char r_type2;	/* 2nd relocation type */
+  unsigned char r_type1;	/* 1st relocation type */
+} _Elf64_Mips_R_Info;
+
+typedef union
+{
+  Elf64_Xword	r_info_number;
+  _Elf64_Mips_R_Info r_info_fields;
+} _Elf64_Mips_R_Info_union;
+
+typedef struct
+{
+  Elf64_Addr	r_offset;		/* Address */
+  _Elf64_Mips_R_Info_union r_info;	/* Relocation type and symbol index */
+} Elf64_Mips_Rel;
+
+typedef struct
+{
+  Elf64_Addr	r_offset;		/* Address */
+  _Elf64_Mips_R_Info_union r_info;	/* Relocation type and symbol index */
+  Elf64_Sxword	r_addend;		/* Addend */
+} Elf64_Mips_Rela;
+
+#define ELF64_MIPS_R_SYM(i) \
+  ((__extension__ (_Elf64_Mips_R_Info_union)(i)).r_info_fields.r_sym)
+#define ELF64_MIPS_R_TYPE(i) \
+  (((_Elf64_Mips_R_Info_union)(i)).r_info_fields.r_type1 \
+   | ((Elf32_Word)(__extension__ (_Elf64_Mips_R_Info_union)(i) \
+		   ).r_info_fields.r_type2 << 8) \
+   | ((Elf32_Word)(__extension__ (_Elf64_Mips_R_Info_union)(i) \
+		   ).r_info_fields.r_type3 << 16) \
+   | ((Elf32_Word)(__extension__ (_Elf64_Mips_R_Info_union)(i) \
+		   ).r_info_fields.r_ssym << 24))
+#define ELF64_MIPS_R_INFO(sym, type) \
+  (__extension__ (_Elf64_Mips_R_Info_union) \
+   (__extension__ (_Elf64_Mips_R_Info) \
+   { (sym), ELF64_MIPS_R_SSYM (type), \
+       ELF64_MIPS_R_TYPE3 (type), \
+       ELF64_MIPS_R_TYPE2 (type), \
+       ELF64_MIPS_R_TYPE1 (type) \
+   }).r_info_number)
+/* These macros decompose the value returned by ELF64_MIPS_R_TYPE, and
+   compose it back into a value that it can be used as an argument to
+   ELF64_MIPS_R_INFO.  */
+#define ELF64_MIPS_R_SSYM(i) (((i) >> 24) & 0xff)
+#define ELF64_MIPS_R_TYPE3(i) (((i) >> 16) & 0xff)
+#define ELF64_MIPS_R_TYPE2(i) (((i) >> 8) & 0xff)
+#define ELF64_MIPS_R_TYPE1(i) ((i) & 0xff)
+#define ELF64_MIPS_R_TYPEENC(type1, type2, type3, ssym) \
+  ((type1) \
+   | ((Elf32_Word)(type2) << 8) \
+   | ((Elf32_Word)(type3) << 16) \
+   | ((Elf32_Word)(ssym) << 24))
+
+#undef ELF64_R_SYM
+#define ELF64_R_SYM(i) ELF64_MIPS_R_SYM (i)
+#undef ELF64_R_TYPE
+#define ELF64_R_TYPE(i) ELF64_MIPS_R_TYPE (i)
+#undef ELF64_R_INFO
+#define ELF64_R_INFO(sym, type) ELF64_MIPS_R_INFO ((sym), (type))
+
+#endif
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/libc-tls.c glibc-2.14.1/sysdeps/riscv/libc-tls.c
--- ../glibc-2.14.1-orig/sysdeps/riscv/libc-tls.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/libc-tls.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,37 @@
+/* Thread-local storage handling in the ELF dynamic linker.  MIPS version.
+   Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <csu/libc-tls.c>
+#include <dl-tls.h>
+
+#if USE_TLS
+
+/* On MIPS, linker optimizations are not required, so __tls_get_addr
+   can be called even in statically linked binaries.  In this case module
+   must be always 1 and PT_TLS segment exist in the binary, otherwise it
+   would not link.  */
+
+void *
+__tls_get_addr (tls_index *ti)
+{
+  dtv_t *dtv = THREAD_DTV ();
+  return (char *) dtv[1].pointer.val + GET_ADDR_OFFSET;
+}
+
+#endif
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/__longjmp.S glibc-2.14.1/sysdeps/riscv/__longjmp.S
--- ../glibc-2.14.1-orig/sysdeps/riscv/__longjmp.S	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/__longjmp.S	2011-11-02 01:24:15.000000000 -0700
@@ -0,0 +1,59 @@
+/* Copyright (C) 1996, 1997, 2000, 2002, 2003, 2004
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <sys/asm.h>
+
+ENTRY (__longjmp)
+	REG_L ra,  0*SZREG(a0)
+	REG_L sp,  1*SZREG(a0)
+	REG_L tp,  2*SZREG(a0)
+	REG_L s0,  3*SZREG(a0)
+	REG_L s1,  4*SZREG(a0)
+	REG_L s2,  5*SZREG(a0)
+	REG_L s3,  6*SZREG(a0)
+	REG_L s4,  7*SZREG(a0)
+	REG_L s5,  8*SZREG(a0)
+	REG_L s6,  9*SZREG(a0)
+	REG_L s7, 10*SZREG(a0)
+	REG_L s8, 11*SZREG(a0)
+	REG_L s9, 12*SZREG(a0)
+
+#ifdef __riscv_hard_float
+	REG_L t0, 13*SZREG(a0)
+
+	fld  fs0, 8*0 + 14*SZREG(a0)
+	fld  fs1, 8*1 + 14*SZREG(a0)
+	fld  fs2, 8*2 + 14*SZREG(a0)
+	fld  fs3, 8*3 + 14*SZREG(a0)
+	fld  fs4, 8*4 + 14*SZREG(a0)
+	fld  fs5, 8*5 + 14*SZREG(a0)
+	fld  fs6, 8*6 + 14*SZREG(a0)
+	fld  fs7, 8*7 + 14*SZREG(a0)
+	fld  fs8, 8*8 + 14*SZREG(a0)
+	fld  fs9, 8*9 + 14*SZREG(a0)
+
+	mtfsr t0
+#endif
+
+	sltu t0, a1, 1    # t0 = (a1 == 0)
+	add  v0, t0, a1   # v0 = (a1 == 0 ? 1 : a1)
+	ret
+
+END(__longjmp)
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/Makefile glibc-2.14.1/sysdeps/riscv/Makefile
--- ../glibc-2.14.1-orig/sysdeps/riscv/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/Makefile	2011-10-27 22:23:23.000000000 -0700
@@ -0,0 +1,9 @@
+ifeq ($(subdir),misc)
+sysdep_headers += sys/asm.h sgidefs.h
+endif
+
+ifeq ($(subdir),rt)
+librt-sysdep_routines += rt-sysdep
+endif
+
+ASFLAGS-.os += $(pic-ccflag)
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/memcpy.c glibc-2.14.1/sysdeps/riscv/memcpy.c
--- ../glibc-2.14.1-orig/sysdeps/riscv/memcpy.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/memcpy.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,50 @@
+#include <string.h>
+
+#undef memcpy
+
+void* memcpy(void* dst, const void* src, size_t n)
+{
+  void* dst0 = dst;
+  void* end = dst + n;
+
+  /* are dst and src word-aligned? */
+  if ((((long)dst | (long)src) & (sizeof(long)-1)) == 0)
+  {
+    /* copy 10 words at a time */
+    for ( ; dst <= end - 10*sizeof(long); dst += 10*sizeof(long), src += 10*sizeof(long))
+    {
+      long t0 = *(const long*)(src+0*sizeof(long));
+      long t1 = *(const long*)(src+1*sizeof(long));
+      long t2 = *(const long*)(src+2*sizeof(long));
+      long t3 = *(const long*)(src+3*sizeof(long));
+      long t4 = *(const long*)(src+4*sizeof(long));
+      long t5 = *(const long*)(src+5*sizeof(long));
+      long t6 = *(const long*)(src+6*sizeof(long));
+      long t7 = *(const long*)(src+7*sizeof(long));
+      long t8 = *(const long*)(src+8*sizeof(long));
+      long t9 = *(const long*)(src+9*sizeof(long));
+      *(long*)(dst+0*sizeof(long)) = t0;
+      *(long*)(dst+1*sizeof(long)) = t1;
+      *(long*)(dst+2*sizeof(long)) = t2;
+      *(long*)(dst+3*sizeof(long)) = t3;
+      *(long*)(dst+4*sizeof(long)) = t4;
+      *(long*)(dst+5*sizeof(long)) = t5;
+      *(long*)(dst+6*sizeof(long)) = t6;
+      *(long*)(dst+7*sizeof(long)) = t7;
+      *(long*)(dst+8*sizeof(long)) = t8;
+      *(long*)(dst+9*sizeof(long)) = t9;
+    }
+
+    /* copy a word at a time */
+    for ( ; dst <= end - sizeof(long); dst += sizeof(long), src += sizeof(long))
+      *(long*)dst = *(const long*)src;
+  }
+
+  /* copy a byte at a time */
+  for ( ; dst < end; dst++, src++)
+    *(char*)dst = *(const char*)src;
+
+  return dst0;
+}
+
+libc_hidden_builtin_def (memcpy)
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/memset.c glibc-2.14.1/sysdeps/riscv/memset.c
--- ../glibc-2.14.1-orig/sysdeps/riscv/memset.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/memset.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,49 @@
+typedef unsigned long size_t;
+//#include <string.h>
+
+void* memset(void* dst, int val, size_t n)
+{
+  void* dst0 = dst;
+  void* end = dst + n;
+  unsigned char v = val;
+
+  /* is dst word-aligned? */
+  if (((long)dst & (sizeof(long)-1)) == 0)
+  {
+    long lval = v;
+    lval |= lval << 8;
+    lval |= lval << 16;
+    #ifdef __riscv64
+    lval |= lval << 32;
+    #elif !defined(__riscv32)
+    # error
+    #endif
+
+    /* set 10 words at a time */
+    for ( ; dst <= end - 10*sizeof(long); dst += 10*sizeof(long))
+    {
+      *(long*)(dst+0*sizeof(long)) = lval;
+      *(long*)(dst+1*sizeof(long)) = lval;
+      *(long*)(dst+2*sizeof(long)) = lval;
+      *(long*)(dst+3*sizeof(long)) = lval;
+      *(long*)(dst+4*sizeof(long)) = lval;
+      *(long*)(dst+5*sizeof(long)) = lval;
+      *(long*)(dst+6*sizeof(long)) = lval;
+      *(long*)(dst+7*sizeof(long)) = lval;
+      *(long*)(dst+8*sizeof(long)) = lval;
+      *(long*)(dst+9*sizeof(long)) = lval;
+    }
+
+    /* set a word at a time */
+    for ( ; dst <= end - sizeof(long); dst += sizeof(long))
+      *(long*)dst = lval;
+  }
+
+  /* set a byte at a time */
+  for ( ; dst < end; dst++)
+    *(unsigned char*)dst = v;
+
+  return dst0;
+}
+
+weak_alias (memset, __GI_memset)
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/memusage.h glibc-2.14.1/sysdeps/riscv/memusage.h
--- ../glibc-2.14.1-orig/sysdeps/riscv/memusage.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/memusage.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,21 @@
+/* Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define GETSP() ({ register uintptr_t stack_ptr asm ("sp"); stack_ptr; })
+
+#include <sysdeps/generic/memusage.h>
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/nptl/Makefile glibc-2.14.1/sysdeps/riscv/nptl/Makefile
--- ../glibc-2.14.1-orig/sysdeps/riscv/nptl/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/nptl/Makefile	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,25 @@
+# Copyright (C) 2005 Free Software Foundation, Inc.
+# This file is part of the GNU C Library.
+#
+# The GNU C Library is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Lesser General Public
+# License as published by the Free Software Foundation; either
+# version 2.1 of the License, or (at your option) any later version.
+#
+# The GNU C Library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+#
+# You should have received a copy of the GNU Lesser General Public
+# License along with the GNU C Library; if not, write to the Free
+# Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+# 02111-1307 USA.
+
+ifeq ($(subdir),csu)
+gen-as-const-headers += tcb-offsets.sym
+endif
+
+ifeq ($(subdir),nptl)
+libpthread-sysdep_routines += nptl-sysdep
+endif
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/nptl/nptl-sysdep.c glibc-2.14.1/sysdeps/riscv/nptl/nptl-sysdep.c
--- ../glibc-2.14.1-orig/sysdeps/riscv/nptl/nptl-sysdep.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/nptl/nptl-sysdep.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,2 @@
+/* Pull in __syscall_error.  */
+#include <sysdep.c>
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/nptl/pthreaddef.h glibc-2.14.1/sysdeps/riscv/nptl/pthreaddef.h
--- ../glibc-2.14.1-orig/sysdeps/riscv/nptl/pthreaddef.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/nptl/pthreaddef.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,39 @@
+/* Copyright (C) 2002, 2003, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Default stack size.  */
+#define ARCH_STACK_DEFAULT_SIZE	(2 * 1024 * 1024)
+
+/* Required stack pointer alignment at beginning.  */
+#define STACK_ALIGN		16
+
+/* Minimal stack size after allocating thread descriptor and guard size.  */
+#define MINIMAL_REST_STACK	2048
+
+/* Alignment requirement for TCB.  */
+#define TCB_ALIGNMENT		16
+
+
+/* Location of current stack frame.  */
+#define CURRENT_STACK_FRAME	__builtin_frame_address (0)
+
+
+/* XXX Until we have a better place keep the definitions here.  */
+
+#define __exit_thread_inline(val) \
+  INLINE_SYSCALL (exit, 1, (val))
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/nptl/pthread_spin_lock.c glibc-2.14.1/sysdeps/riscv/nptl/pthread_spin_lock.c
--- ../glibc-2.14.1-orig/sysdeps/riscv/nptl/pthread_spin_lock.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/nptl/pthread_spin_lock.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,32 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+
+int pthread_spin_lock(pthread_spinlock_t* lock)
+{
+  while (__sync_fetch_and_or(lock, 1) != 0)
+  {
+    while (*lock)
+      ;
+  }
+
+  __sync_synchronize();
+
+  return 0;
+}
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/nptl/pthread_spin_trylock.c glibc-2.14.1/sysdeps/riscv/nptl/pthread_spin_trylock.c
--- ../glibc-2.14.1-orig/sysdeps/riscv/nptl/pthread_spin_trylock.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/nptl/pthread_spin_trylock.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,33 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+
+int pthread_spin_trylock(pthread_spinlock_t* lock)
+{
+  int ret;
+
+  if (__sync_fetch_and_or(lock, 1) == 0)
+    ret = 0;
+  else
+    ret = EBUSY;
+
+  __sync_synchronize();
+
+  return ret;
+}
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/nptl/tcb-offsets.sym glibc-2.14.1/sysdeps/riscv/nptl/tcb-offsets.sym
--- ../glibc-2.14.1-orig/sysdeps/riscv/nptl/tcb-offsets.sym	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/nptl/tcb-offsets.sym	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,11 @@
+#include <sysdep.h>
+#include <tls.h>
+
+--
+
+-- Abuse tls.h macros to derive offsets relative to the thread register.
+#define thread_offsetof(mem)	(long)(offsetof(struct pthread, mem) - TLS_TCB_OFFSET - TLS_PRE_TCB_SIZE)
+
+MULTIPLE_THREADS_OFFSET		thread_offsetof (header.multiple_threads)
+PID_OFFSET			thread_offsetof (pid)
+TID_OFFSET			thread_offsetof (tid)
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/nptl/tls.h glibc-2.14.1/sysdeps/riscv/nptl/tls.h
--- ../glibc-2.14.1-orig/sysdeps/riscv/nptl/tls.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/nptl/tls.h	2011-10-27 22:17:29.000000000 -0700
@@ -0,0 +1,165 @@
+/* Definition for thread-local data handling.  NPTL/MIPS version.
+   Copyright (C) 2005, 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _TLS_H
+#define _TLS_H	1
+
+#include <dl-sysdep.h>
+
+#ifndef __ASSEMBLER__
+# include <stdbool.h>
+# include <stddef.h>
+# include <stdint.h>
+
+/* Type for the dtv.  */
+typedef union dtv
+{
+  size_t counter;
+  struct
+  {
+    void *val;
+    bool is_static;
+  } pointer;
+} dtv_t;
+
+register void* __thread_self asm("tp");
+# define READ_THREAD_POINTER() ({ __thread_self; })
+
+#endif /* __ASSEMBLER__ */
+
+
+/* We require TLS support in the tools.  */
+#ifndef HAVE_TLS_SUPPORT
+# error "TLS support is required."
+#endif
+
+/* Signal that TLS support is available.  */
+#define USE_TLS	1
+
+#ifndef __ASSEMBLER__
+
+/* Get system call information.  */
+# include <sysdep.h>
+
+/* The TP points to the start of the thread blocks.  */
+# define TLS_DTV_AT_TP	1
+
+/* Get the thread descriptor definition.  */
+# include <nptl/descr.h>
+
+typedef struct
+{
+  dtv_t *dtv;
+  void *private;
+} tcbhead_t;
+
+/* This is the size of the initial TCB.  Because our TCB is before the thread
+   pointer, we don't need this.  */
+# define TLS_INIT_TCB_SIZE	0
+
+/* Alignment requirements for the initial TCB.  */
+# define TLS_INIT_TCB_ALIGN	__alignof__ (struct pthread)
+
+/* This is the size of the TCB.  Because our TCB is before the thread
+   pointer, we don't need this.  */
+# define TLS_TCB_SIZE		0
+
+/* Alignment requirements for the TCB.  */
+# define TLS_TCB_ALIGN		__alignof__ (struct pthread)
+
+/* This is the size we need before TCB - actually, it includes the TCB.  */
+# define TLS_PRE_TCB_SIZE \
+  (sizeof (struct pthread)						      \
+   + ((sizeof (tcbhead_t) + TLS_TCB_ALIGN - 1) & ~(TLS_TCB_ALIGN - 1)))
+
+/* The thread pointer (in hardware register $29) points to the end of
+   the TCB + 0x7000, as for PowerPC.  The pthread_descr structure is
+   immediately in front of the TCB.  */
+# define TLS_TCB_OFFSET	0x7000
+
+/* Install the dtv pointer.  The pointer passed is to the element with
+   index -1 which contain the length.  */
+# define INSTALL_DTV(tcbp, dtvp) \
+  (((tcbhead_t *) (tcbp))[-1].dtv = (dtvp) + 1)
+
+/* Install new dtv for current thread.  */
+# define INSTALL_NEW_DTV(dtv) \
+  (THREAD_DTV() = (dtv))
+
+/* Return dtv of given thread descriptor.  */
+# define GET_DTV(tcbp) \
+  (((tcbhead_t *) (tcbp))[-1].dtv)
+
+/* Code to initially initialize the thread pointer. */
+# define TLS_INIT_TP(tcbp, secondcall) \
+  ({ __thread_self = (char*)tcbp + TLS_TCB_OFFSET; NULL; })
+
+/* Return the address of the dtv for the current thread.  */
+# define THREAD_DTV() \
+  (((tcbhead_t *) (READ_THREAD_POINTER () - TLS_TCB_OFFSET))[-1].dtv)
+
+/* Return the thread descriptor for the current thread.  */
+# define THREAD_SELF \
+ ((struct pthread *) (READ_THREAD_POINTER ()			     \
+		      - TLS_TCB_OFFSET - TLS_PRE_TCB_SIZE))
+
+/* Magic for libthread_db to know how to do THREAD_SELF.  */
+# define DB_THREAD_SELF \
+  CONST_THREAD_AREA (32, TLS_TCB_OFFSET + TLS_PRE_TCB_SIZE)
+
+/* Access to data in the thread descriptor is easy.  */
+# define THREAD_GETMEM(descr, member) \
+  descr->member
+# define THREAD_GETMEM_NC(descr, member, idx) \
+  descr->member[idx]
+# define THREAD_SETMEM(descr, member, value) \
+  descr->member = (value)
+# define THREAD_SETMEM_NC(descr, member, idx, value) \
+  descr->member[idx] = (value)
+
+/* l_tls_offset == 0 is perfectly valid on MIPS, so we have to use some
+   different value to mean unset l_tls_offset.  */
+# define NO_TLS_OFFSET		-1
+
+/* Get and set the global scope generation counter in struct pthread.  */
+#define THREAD_GSCOPE_FLAG_UNUSED 0
+#define THREAD_GSCOPE_FLAG_USED   1
+#define THREAD_GSCOPE_FLAG_WAIT   2
+#define THREAD_GSCOPE_RESET_FLAG() \
+  do									     \
+    { int __res								     \
+	= atomic_exchange_rel (&THREAD_SELF->header.gscope_flag,	     \
+			       THREAD_GSCOPE_FLAG_UNUSED);		     \
+      if (__res == THREAD_GSCOPE_FLAG_WAIT)				     \
+	lll_futex_wake (&THREAD_SELF->header.gscope_flag, 1, LLL_PRIVATE);   \
+    }									     \
+  while (0)
+#define THREAD_GSCOPE_SET_FLAG() \
+  do									     \
+    {									     \
+      THREAD_SELF->header.gscope_flag = THREAD_GSCOPE_FLAG_USED;	     \
+      atomic_write_barrier ();						     \
+    }									     \
+  while (0)
+#define THREAD_GSCOPE_WAIT() \
+  GL(dl_wait_lookup_done) ()
+
+#endif /* __ASSEMBLER__ */
+
+#endif	/* tls.h */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/preconfigure glibc-2.14.1/sysdeps/riscv/preconfigure
--- ../glibc-2.14.1-orig/sysdeps/riscv/preconfigure	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/preconfigure	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,21 @@
+ccccase "$CC $CFLAGS $CPPFLAGS " in
+*" -mabi=32 "*) mips_cc_abi=32 ;;
+*" -mabi=64 "*) mips_cc_abi=64 ;;
+*) mips_cc_abi=default ;;
+esac
+case $config_os in
+*abi64*) mips_config_abi=64 ;;
+*abi32*) mips_config_abi=32 ;;
+*) mips_config_abi=$mips_cc_abi ;;
+esac
+case $mips_config_abi in
+default) machine=riscv/rv64 ;;
+32) machine=riscv/rv32 ;;
+esac
+machine=$machine/$config_machine
+if test $mips_config_abi != $mips_cc_abi; then
+  # This won't make it to config.make, but we want to
+  # set this in case configure tests depend on it.
+  CPPFLAGS="$CPPFLAGS -mabi=$mips_config_abi"
+fi
+;;
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/rv32/Implies glibc-2.14.1/sysdeps/riscv/rv32/Implies
--- ../glibc-2.14.1-orig/sysdeps/riscv/rv32/Implies	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/rv32/Implies	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,2 @@
+riscv
+wordsize-32
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/rv32/Makefile glibc-2.14.1/sysdeps/riscv/rv32/Makefile
--- ../glibc-2.14.1-orig/sysdeps/riscv/rv32/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/rv32/Makefile	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,3 @@
+ifeq ($(filter -mabi=32,$(CC)),)
+CC += -mabi=32
+endif
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/rv64/gmp-mparam.h glibc-2.14.1/sysdeps/riscv/rv64/gmp-mparam.h
--- ../glibc-2.14.1-orig/sysdeps/riscv/rv64/gmp-mparam.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/rv64/gmp-mparam.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,31 @@
+/* gmp-mparam.h -- Compiler/machine parameter header file.
+
+Copyright (C) 1991, 1993, 1994, 2002, 2003 Free Software Foundation, Inc.
+
+This file is part of the GNU MP Library.
+
+The GNU MP Library is free software; you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation; either version 2.1 of the License, or (at your
+option) any later version.
+
+The GNU MP Library is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with the GNU MP Library; see the file COPYING.LIB.  If not, write to
+the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. */
+
+#if defined __GMP_H__ && ! defined _LONG_LONG_LIMB
+#error "Included too late for _LONG_LONG_LIMB to take effect"
+#endif
+
+#define _LONG_LONG_LIMB
+#define BITS_PER_MP_LIMB 64
+#define BYTES_PER_MP_LIMB 8
+#define BITS_PER_LONGINT __WORDSIZE
+#define BITS_PER_INT 32
+#define BITS_PER_SHORTINT 16
+#define BITS_PER_CHAR 8
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/rv64/Implies glibc-2.14.1/sysdeps/riscv/rv64/Implies
--- ../glibc-2.14.1-orig/sysdeps/riscv/rv64/Implies	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/rv64/Implies	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,6 @@
+ieee754/flt-32
+ieee754/dbl-64
+riscv/rv64/soft-fp
+riscv/rv64
+riscv
+wordsize-64
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/rv64/libm-test-ulps glibc-2.14.1/sysdeps/riscv/rv64/libm-test-ulps
--- ../glibc-2.14.1-orig/sysdeps/riscv/rv64/libm-test-ulps	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/rv64/libm-test-ulps	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,1245 @@
+# Begin of automatic generation
+
+# atan2
+Test "atan2 (-0.00756827042671106339, -.001792735857538728036) == -1.80338464113663849327153994379639112":
+ildouble: 1
+ldouble: 1
+Test "atan2 (-0.75, -1.0) == -2.49809154479650885165983415456218025":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "atan2 (0.75, -1.0) == 2.49809154479650885165983415456218025":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "atan2 (1.390625, 0.9296875) == 0.981498387184244311516296577615519772":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# atanh
+Test "atanh (0.75) == 0.972955074527656652552676371721589865":
+float: 1
+ifloat: 1
+
+# cacos
+Test "Imaginary part of: cacos (0.75 + 1.25 i) == 1.11752014915610270578240049553777969 - 1.13239363160530819522266333696834467 i":
+ildouble: 1
+ldouble: 1
+
+# cacosh
+Test "Imaginary part of: cacosh (-2 - 3 i) == 1.9833870299165354323470769028940395 - 2.1414491111159960199416055713254211 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# casin
+Test "Real part of: casin (0.75 + 1.25 i) == 0.453276177638793913448921196101971749 + 1.13239363160530819522266333696834467 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: casin (0.75 + 1.25 i) == 0.453276177638793913448921196101971749 + 1.13239363160530819522266333696834467 i":
+ildouble: 1
+ldouble: 1
+
+# casinh
+Test "Real part of: casinh (-2 - 3 i) == -1.9686379257930962917886650952454982 - 0.96465850440760279204541105949953237 i":
+double: 5
+float: 1
+idouble: 5
+ifloat: 1
+ildouble: 4
+ldouble: 4
+Test "Imaginary part of: casinh (-2 - 3 i) == -1.9686379257930962917886650952454982 - 0.96465850440760279204541105949953237 i":
+double: 3
+float: 6
+idouble: 3
+ifloat: 6
+ildouble: 2
+ldouble: 2
+Test "Real part of: casinh (0.75 + 1.25 i) == 1.03171853444778027336364058631006594 + 0.911738290968487636358489564316731207 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: casinh (0.75 + 1.25 i) == 1.03171853444778027336364058631006594 + 0.911738290968487636358489564316731207 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# catan
+Test "Imaginary part of: catan (-2 - 3 i) == -1.4099210495965755225306193844604208 - 0.22907268296853876629588180294200276 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: catan (0.75 + 1.25 i) == 1.10714871779409050301706546017853704 + 0.549306144334054845697622618461262852 i":
+ildouble: 1
+ldouble: 1
+
+# catanh
+Test "Real part of: catanh (-2 - 3 i) == -0.14694666622552975204743278515471595 - 1.3389725222944935611241935759091443 i":
+double: 4
+idouble: 4
+Test "Real part of: catanh (0.75 + 1.25 i) == 0.261492138795671927078652057366532140 + 0.996825126463918666098902241310446708 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: catanh (0.75 + 1.25 i) == 0.261492138795671927078652057366532140 + 0.996825126463918666098902241310446708 i":
+ildouble: 1
+ldouble: 1
+
+# cbrt
+Test "cbrt (-0.001) == -0.1":
+ildouble: 1
+ldouble: 1
+Test "cbrt (-27.0) == -3.0":
+double: 1
+idouble: 1
+Test "cbrt (0.75) == 0.908560296416069829445605878163630251":
+double: 1
+idouble: 1
+Test "cbrt (0.9921875) == 0.997389022060725270579075195353955217":
+double: 1
+idouble: 1
+
+# ccos
+Test "Real part of: ccos (-2 - 3 i) == -4.18962569096880723013255501961597373 - 9.10922789375533659797919726277886212 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ccos (-2 - 3 i) == -4.18962569096880723013255501961597373 - 9.10922789375533659797919726277886212 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: ccos (0.75 + 1.25 i) == 1.38173873063425888530729933139078645 - 1.09193013555397466170919531722024128 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: ccos (0.75 + 1.25 i) == 1.38173873063425888530729933139078645 - 1.09193013555397466170919531722024128 i":
+float: 1
+ifloat: 1
+
+# ccosh
+Test "Real part of: ccosh (-2 - 3 i) == -3.72454550491532256547397070325597253 + 0.511822569987384608834463849801875634 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ccosh (-2 - 3 i) == -3.72454550491532256547397070325597253 + 0.511822569987384608834463849801875634 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: ccosh (0.75 + 1.25 i) == 0.408242591877968807788852146397499084 + 0.780365930845853240391326216300863152 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: ccosh (0.75 + 1.25 i) == 0.408242591877968807788852146397499084 + 0.780365930845853240391326216300863152 i":
+float: 1
+ifloat: 1
+
+# cexp
+Test "Real part of: cexp (-2.0 - 3.0 i) == -0.13398091492954261346140525546115575 - 0.019098516261135196432576240858800925 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: cexp (-2.0 - 3.0 i) == -0.13398091492954261346140525546115575 - 0.019098516261135196432576240858800925 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: cexp (0.75 + 1.25 i) == 0.667537446429131586942201977015932112 + 2.00900045494094876258347228145863909 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: cexp (0.75 + 1.25 i) == 0.667537446429131586942201977015932112 + 2.00900045494094876258347228145863909 i":
+ildouble: 1
+ldouble: 1
+
+# clog
+Test "Real part of: clog (0.75 + 1.25 i) == 0.376885901188190075998919126749298416 + 1.03037682652431246378774332703115153 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# clog10
+Test "Imaginary part of: clog10 (-0 + inf i) == inf + pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-0 - inf i) == inf - pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Real part of: clog10 (-2 - 3 i) == 0.556971676153418384603252578971164214 - 0.937554462986374708541507952140189646 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: clog10 (-2 - 3 i) == 0.556971676153418384603252578971164214 - 0.937554462986374708541507952140189646 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: clog10 (-3 + inf i) == inf + pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-3 - inf i) == inf - pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-inf + 0 i) == inf + pi*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-inf + 1 i) == inf + pi*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-inf + inf i) == inf + 3/4 pi*log10(e) i":
+double: 1
+idouble: 1
+Test "Imaginary part of: clog10 (-inf - 0 i) == inf - pi*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-inf - 1 i) == inf - pi*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (0 + inf i) == inf + pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (0 - inf i) == inf - pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Real part of: clog10 (0.75 + 1.25 i) == 0.163679467193165171449476605077428975 + 0.447486970040493067069984724340855636 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (0.75 + 1.25 i) == 0.163679467193165171449476605077428975 + 0.447486970040493067069984724340855636 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: clog10 (3 + inf i) == inf + pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (3 - inf i) == inf - pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (inf + inf i) == inf + pi/4*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (inf - inf i) == inf - pi/4*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+# cos
+Test "cos (M_PI_6l * 2.0) == 0.5":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "cos (M_PI_6l * 4.0) == -0.5":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# cpow
+Test "Real part of: cpow (0.75 + 1.25 i, 0.0 + 1.0 i) == 0.331825439177608832276067945276730566 + 0.131338600281188544930936345230903032 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: cpow (0.75 + 1.25 i, 0.0 + 1.0 i) == 0.331825439177608832276067945276730566 + 0.131338600281188544930936345230903032 i":
+float: 1
+ifloat: 1
+Test "Real part of: cpow (0.75 + 1.25 i, 0.75 + 1.25 i) == 0.117506293914473555420279832210420483 + 0.346552747708338676483025352060418001 i":
+double: 1
+float: 4
+idouble: 1
+ifloat: 4
+ildouble: 4
+ldouble: 4
+Test "Real part of: cpow (0.75 + 1.25 i, 1.0 + 0.0 i) == 0.75 + 1.25 i":
+ildouble: 2
+ldouble: 2
+Test "Imaginary part of: cpow (0.75 + 1.25 i, 1.0 + 0.0 i) == 0.75 + 1.25 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: cpow (0.75 + 1.25 i, 1.0 + 1.0 i) == 0.0846958290317209430433805274189191353 + 0.513285749182902449043287190519090481 i":
+double: 2
+float: 3
+idouble: 2
+ifloat: 3
+ildouble: 10
+ldouble: 10
+Test "Real part of: cpow (2 + 0 i, 10 + 0 i) == 1024.0 + 0.0 i":
+ildouble: 2
+ldouble: 2
+Test "Real part of: cpow (2 + 3 i, 4 + 0 i) == -119.0 - 120.0 i":
+double: 1
+float: 4
+idouble: 1
+ifloat: 4
+ildouble: 3
+ldouble: 3
+Test "Imaginary part of: cpow (2 + 3 i, 4 + 0 i) == -119.0 - 120.0 i":
+float: 2
+ifloat: 2
+Test "Imaginary part of: cpow (e + 0 i, 0 + 2 * M_PIl i) == 1.0 + 0.0 i":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+# csin
+Test "Imaginary part of: csin (-2 - 3 i) == -9.15449914691142957346729954460983256 + 4.16890695996656435075481305885375484 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: csin (0.75 + 1.25 i) == 1.28722291002649188575873510790565441 + 1.17210635989270256101081285116138863 i":
+ildouble: 1
+ldouble: 1
+
+# csinh
+Test "Real part of: csinh (-2 - 3 i) == 3.59056458998577995201256544779481679 - 0.530921086248519805267040090660676560 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: csinh (-2 - 3 i) == 3.59056458998577995201256544779481679 - 0.530921086248519805267040090660676560 i":
+double: 1
+idouble: 1
+Test "Real part of: csinh (0.75 + 1.25 i) == 0.259294854551162779153349830618433028 + 1.22863452409509552219214606515777594 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: csinh (0.75 + 1.25 i) == 0.259294854551162779153349830618433028 + 1.22863452409509552219214606515777594 i":
+float: 1
+ifloat: 1
+
+# csqrt
+Test "Real part of: csqrt (-2 + 3 i) == 0.89597747612983812471573375529004348 + 1.6741492280355400404480393008490519 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: csqrt (-2 - 3 i) == 0.89597747612983812471573375529004348 - 1.6741492280355400404480393008490519 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: csqrt (0.75 + 1.25 i) == 1.05065169626078392338656675760808326 + 0.594868882070379067881984030639932657 i":
+ildouble: 1
+ldouble: 1
+
+# ctan
+Test "Real part of: ctan (-2 - 3 i) == 0.376402564150424829275122113032269084e-2 - 1.00323862735360980144635859782192726 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ctan (-2 - 3 i) == 0.376402564150424829275122113032269084e-2 - 1.00323862735360980144635859782192726 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ctan (0.75 + 1.25 i) == 0.160807785916206426725166058173438663 + 0.975363285031235646193581759755216379 i":
+double: 1
+idouble: 1
+ildouble: 2
+ldouble: 2
+
+# ctanh
+Test "Real part of: ctanh (-2 - 3 i) == -0.965385879022133124278480269394560686 + 0.988437503832249372031403430350121098e-2 i":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ctanh (-2 - 3 i) == -0.965385879022133124278480269394560686 + 0.988437503832249372031403430350121098e-2 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ctanh (0 + pi/4 i) == 0.0 + 1.0 i":
+float: 1
+ifloat: 1
+Test "Real part of: ctanh (0.75 + 1.25 i) == 1.37260757053378320258048606571226857 + 0.385795952609750664177596760720790220 i":
+double: 1
+idouble: 1
+
+# erf
+Test "erf (1.25) == 0.922900128256458230136523481197281140":
+double: 1
+idouble: 1
+
+# erfc
+Test "erfc (2.0) == 0.00467773498104726583793074363274707139":
+double: 1
+idouble: 1
+Test "erfc (27.0) == 0.523704892378925568501606768284954709e-318":
+ildouble: 1
+ldouble: 1
+Test "erfc (4.125) == 0.542340079956506600531223408575531062e-8":
+double: 1
+idouble: 1
+
+# exp10
+Test "exp10 (-1) == 0.1":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "exp10 (0.75) == 5.62341325190349080394951039776481231":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "exp10 (3) == 1000":
+double: 6
+float: 2
+idouble: 6
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+# exp2
+Test "exp2 (10) == 1024":
+ildouble: 2
+ldouble: 2
+
+# expm1
+Test "expm1 (0.75) == 1.11700001661267466854536981983709561":
+double: 1
+idouble: 1
+Test "expm1 (1) == M_El - 1.0":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# gamma
+Test "gamma (-0.5) == log(2*sqrt(pi))":
+ildouble: 1
+ldouble: 1
+
+# hypot
+Test "hypot (-0.7, -12.4) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (-0.7, 12.4) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (-12.4, -0.7) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (-12.4, 0.7) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (0.7, -12.4) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (0.7, 12.4) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (12.4, -0.7) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (12.4, 0.7) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+
+# j0
+Test "j0 (-4.0) == -3.9714980986384737228659076845169804197562E-1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "j0 (0.75) == 0.864242275166648623555731103820923211":
+float: 1
+ifloat: 1
+Test "j0 (10.0) == -0.245935764451348335197760862485328754":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "j0 (2.0) == 0.223890779141235668051827454649948626":
+float: 2
+ifloat: 2
+ildouble: 2
+ldouble: 2
+Test "j0 (4.0) == -3.9714980986384737228659076845169804197562E-1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "j0 (8.0) == 0.171650807137553906090869407851972001":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# j1
+Test "j1 (-1.0) == -0.440050585744933515959682203718914913":
+ildouble: 1
+ldouble: 1
+Test "j1 (0.75) == 0.349243602174862192523281016426251335":
+ildouble: 1
+ldouble: 1
+Test "j1 (1.0) == 0.440050585744933515959682203718914913":
+ildouble: 1
+ldouble: 1
+Test "j1 (10.0) == 0.0434727461688614366697487680258592883":
+float: 2
+ifloat: 2
+ildouble: 2
+ldouble: 2
+Test "j1 (2.0) == 0.576724807756873387202448242269137087":
+double: 1
+idouble: 1
+Test "j1 (8.0) == 0.234636346853914624381276651590454612":
+double: 1
+idouble: 1
+ildouble: 4
+ldouble: 4
+
+# jn
+Test "jn (0, -4.0) == -3.9714980986384737228659076845169804197562E-1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "jn (0, 0.75) == 0.864242275166648623555731103820923211":
+float: 1
+ifloat: 1
+Test "jn (0, 10.0) == -0.245935764451348335197760862485328754":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "jn (0, 2.0) == 0.223890779141235668051827454649948626":
+float: 2
+ifloat: 2
+ildouble: 2
+ldouble: 2
+Test "jn (0, 4.0) == -3.9714980986384737228659076845169804197562E-1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "jn (0, 8.0) == 0.171650807137553906090869407851972001":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "jn (1, -1.0) == -0.440050585744933515959682203718914913":
+ildouble: 1
+ldouble: 1
+Test "jn (1, 0.75) == 0.349243602174862192523281016426251335":
+ildouble: 1
+ldouble: 1
+Test "jn (1, 1.0) == 0.440050585744933515959682203718914913":
+ildouble: 1
+ldouble: 1
+Test "jn (1, 10.0) == 0.0434727461688614366697487680258592883":
+float: 2
+ifloat: 2
+ildouble: 2
+ldouble: 2
+Test "jn (1, 2.0) == 0.576724807756873387202448242269137087":
+double: 1
+idouble: 1
+Test "jn (1, 8.0) == 0.234636346853914624381276651590454612":
+double: 1
+idouble: 1
+ildouble: 4
+ldouble: 4
+Test "jn (10, -1.0) == 0.263061512368745320699785368779050294e-9":
+ildouble: 1
+ldouble: 1
+Test "jn (10, 0.125) == 0.250543369809369890173993791865771547e-18":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "jn (10, 0.75) == 0.149621713117596814698712483621682835e-10":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "jn (10, 1.0) == 0.263061512368745320699785368779050294e-9":
+ildouble: 1
+ldouble: 1
+Test "jn (10, 10.0) == 0.207486106633358857697278723518753428":
+double: 4
+float: 3
+idouble: 4
+ifloat: 3
+ildouble: 2
+ldouble: 2
+Test "jn (10, 2.0) == 0.251538628271673670963516093751820639e-6":
+float: 4
+ifloat: 4
+Test "jn (3, 0.125) == 0.406503832554912875023029337653442868e-4":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "jn (3, 0.75) == 0.848438342327410884392755236884386804e-2":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "jn (3, 10.0) == 0.0583793793051868123429354784103409563":
+double: 3
+float: 1
+idouble: 3
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "jn (3, 2.0) == 0.128943249474402051098793332969239835":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+
+# lgamma
+Test "lgamma (-0.5) == log(2*sqrt(pi))":
+ildouble: 1
+ldouble: 1
+Test "lgamma (0.7) == 0.260867246531666514385732417016759578":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "lgamma (1.2) == -0.853740900033158497197028392998854470e-1":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+# log10
+Test "log10 (0.75) == -0.124938736608299953132449886193870744":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+Test "log10 (e) == log10(e)":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# log1p
+Test "log1p (-0.25) == -0.287682072451780927439219005993827432":
+float: 1
+ifloat: 1
+
+# log2
+Test "log2 (0.75) == -.415037499278843818546261056052183492":
+ildouble: 1
+ldouble: 1
+
+# sincos
+Test "sincos (M_PI_6l*2.0, &sin_res, &cos_res) puts 0.5 in cos_res":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "sincos (M_PI_6l*2.0, &sin_res, &cos_res) puts 0.86602540378443864676372317075293616 in sin_res":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "sincos (pi/6, &sin_res, &cos_res) puts 0.86602540378443864676372317075293616 in cos_res":
+float: 1
+ifloat: 1
+
+# sqrt
+Test "sqrt (2) == M_SQRT2l":
+ildouble: 1
+ldouble: 1
+
+# tanh
+Test "tanh (-0.75) == -0.635148952387287319214434357312496495":
+ildouble: 1
+ldouble: 1
+Test "tanh (-1.0) == -0.7615941559557648881194582826047935904":
+ildouble: 1
+ldouble: 1
+Test "tanh (0.75) == 0.635148952387287319214434357312496495":
+ildouble: 1
+ldouble: 1
+Test "tanh (1.0) == 0.7615941559557648881194582826047935904":
+ildouble: 1
+ldouble: 1
+
+# tgamma
+Test "tgamma (-0.5) == -2 sqrt (pi)":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "tgamma (0.5) == sqrt (pi)":
+float: 1
+ifloat: 1
+Test "tgamma (0.7) == 1.29805533264755778568117117915281162":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "tgamma (4) == 6":
+ildouble: 1
+ldouble: 1
+
+# y0
+Test "y0 (1.0) == 0.0882569642156769579829267660235151628":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "y0 (1.5) == 0.382448923797758843955068554978089862":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "y0 (10.0) == 0.0556711672835993914244598774101900481":
+float: 1
+ifloat: 1
+ildouble: 3
+ldouble: 3
+Test "y0 (8.0) == 0.223521489387566220527323400498620359":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 3
+ldouble: 3
+
+# y1
+Test "y1 (0.125) == -5.19993611253477499595928744876579921":
+double: 1
+idouble: 1
+Test "y1 (0.75) == -1.03759455076928541973767132140642198":
+ildouble: 1
+ldouble: 1
+Test "y1 (1.5) == -0.412308626973911295952829820633445323":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "y1 (10.0) == 0.249015424206953883923283474663222803":
+double: 3
+float: 1
+idouble: 3
+ifloat: 1
+Test "y1 (2.0) == -0.107032431540937546888370772277476637":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "y1 (8.0) == -0.158060461731247494255555266187483550":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+# yn
+Test "yn (0, 1.0) == 0.0882569642156769579829267660235151628":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "yn (0, 1.5) == 0.382448923797758843955068554978089862":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "yn (0, 10.0) == 0.0556711672835993914244598774101900481":
+float: 1
+ifloat: 1
+ildouble: 3
+ldouble: 3
+Test "yn (0, 8.0) == 0.223521489387566220527323400498620359":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 3
+ldouble: 3
+Test "yn (1, 0.125) == -5.19993611253477499595928744876579921":
+double: 1
+idouble: 1
+Test "yn (1, 0.75) == -1.03759455076928541973767132140642198":
+ildouble: 1
+ldouble: 1
+Test "yn (1, 1.5) == -0.412308626973911295952829820633445323":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "yn (1, 10.0) == 0.249015424206953883923283474663222803":
+double: 3
+float: 1
+idouble: 3
+ifloat: 1
+Test "yn (1, 2.0) == -0.107032431540937546888370772277476637":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "yn (1, 8.0) == -0.158060461731247494255555266187483550":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 1
+ldouble: 1
+Test "yn (10, 0.125) == -127057845771019398.252538486899753195":
+double: 1
+idouble: 1
+ildouble: 2
+ldouble: 2
+Test "yn (10, 0.75) == -2133501638.90573424452445412893839236":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 5
+ldouble: 5
+Test "yn (10, 1.0) == -121618014.278689189288130426667971145":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "yn (10, 10.0) == -0.359814152183402722051986577343560609":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "yn (10, 2.0) == -129184.542208039282635913145923304214":
+double: 2
+idouble: 2
+ildouble: 2
+ldouble: 2
+Test "yn (3, 0.125) == -2612.69757350066712600220955744091741":
+double: 1
+idouble: 1
+Test "yn (3, 0.75) == -12.9877176234475433186319774484809207":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "yn (3, 10.0) == -0.251362657183837329779204747654240998":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "yn (3, 2.0) == -1.12778377684042778608158395773179238":
+double: 1
+idouble: 1
+
+# Maximal error of functions:
+Function: "atan2":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "atanh":
+float: 1
+ifloat: 1
+
+Function: Imaginary part of "cacos":
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "cacosh":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "casin":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+Function: Imaginary part of "casin":
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "casinh":
+double: 5
+float: 1
+idouble: 5
+ifloat: 1
+ildouble: 4
+ldouble: 4
+
+Function: Imaginary part of "casinh":
+double: 3
+float: 6
+idouble: 3
+ifloat: 6
+ildouble: 2
+ldouble: 2
+
+Function: Imaginary part of "catan":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "catanh":
+double: 4
+idouble: 4
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "catanh":
+ildouble: 1
+ldouble: 1
+
+Function: "cbrt":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "ccos":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "ccos":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "ccosh":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "ccosh":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "cexp":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "cexp":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "clog":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "clog10":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "clog10":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "cos":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "cpow":
+double: 2
+float: 4
+idouble: 2
+ifloat: 4
+ildouble: 10
+ldouble: 10
+
+Function: Imaginary part of "cpow":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "csin":
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "csin":
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "csinh":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "csinh":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+Function: Real part of "csqrt":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "csqrt":
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "ctan":
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "ctan":
+double: 1
+idouble: 1
+ildouble: 2
+ldouble: 2
+
+Function: Real part of "ctanh":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "ctanh":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "erf":
+double: 1
+idouble: 1
+
+Function: "erfc":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+
+Function: "exp10":
+double: 6
+float: 2
+idouble: 6
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+Function: "exp2":
+ildouble: 2
+ldouble: 2
+
+Function: "expm1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "gamma":
+ildouble: 1
+ldouble: 1
+
+Function: "hypot":
+float: 1
+ifloat: 1
+
+Function: "j0":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+ildouble: 2
+ldouble: 2
+
+Function: "j1":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 4
+ldouble: 4
+
+Function: "jn":
+double: 4
+float: 4
+idouble: 4
+ifloat: 4
+ildouble: 4
+ldouble: 4
+
+Function: "lgamma":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+Function: "log10":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+Function: "log1p":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "log2":
+ildouble: 1
+ldouble: 1
+
+Function: "sincos":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "sqrt":
+ildouble: 1
+ldouble: 1
+
+Function: "tan":
+double: 1
+idouble: 1
+
+Function: "tanh":
+ildouble: 1
+ldouble: 1
+
+Function: "tgamma":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "y0":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 3
+ldouble: 3
+
+Function: "y1":
+double: 3
+float: 2
+idouble: 3
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+Function: "yn":
+double: 3
+float: 2
+idouble: 3
+ifloat: 2
+ildouble: 5
+ldouble: 5
+
+# end of automatic generation
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/rv64/Makefile glibc-2.14.1/sysdeps/riscv/rv64/Makefile
--- ../glibc-2.14.1-orig/sysdeps/riscv/rv64/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/rv64/Makefile	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,3 @@
+ifeq ($(filter -mabi=64,$(CC)),)
+CC += -mabi=64
+endif
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/rv64/soft-fp/e_sqrtl.c glibc-2.14.1/sysdeps/riscv/rv64/soft-fp/e_sqrtl.c
--- ../glibc-2.14.1-orig/sysdeps/riscv/rv64/soft-fp/e_sqrtl.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/rv64/soft-fp/e_sqrtl.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,39 @@
+/* long double square root in software floating-point emulation.
+   Copyright (C) 1997, 1999, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson (rth@cygnus.com) and
+		  Jakub Jelinek (jj@ultra.linux.cz).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stdlib.h>
+#include <soft-fp.h>
+#include <quad.h>
+
+long double
+__ieee754_sqrtl (const long double a)
+{
+  FP_DECL_EX;
+  FP_DECL_Q(A); FP_DECL_Q(C);
+  long double c;
+
+  FP_INIT_ROUNDMODE;
+  FP_UNPACK_Q(A, a);
+  FP_SQRT_Q(C, A);
+  FP_PACK_Q(c, C);
+  FP_HANDLE_EXCEPTIONS;
+  return c;
+}
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/rv64/soft-fp/Makefile glibc-2.14.1/sysdeps/riscv/rv64/soft-fp/Makefile
--- ../glibc-2.14.1-orig/sysdeps/riscv/rv64/soft-fp/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/rv64/soft-fp/Makefile	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,3 @@
+ifeq ($(subdir),math)
+CPPFLAGS += -I../soft-fp
+endif
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/rv64/soft-fp/sfp-machine.h glibc-2.14.1/sysdeps/riscv/rv64/soft-fp/sfp-machine.h
--- ../glibc-2.14.1-orig/sysdeps/riscv/rv64/soft-fp/sfp-machine.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/rv64/soft-fp/sfp-machine.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,74 @@
+#include <fenv.h>
+#include <fpu_control.h>
+
+#define _FP_W_TYPE_SIZE		64
+#define _FP_W_TYPE		unsigned long long
+#define _FP_WS_TYPE		signed long long
+#define _FP_I_TYPE		long long
+
+#define _FP_MUL_MEAT_S(R,X,Y)					\
+  _FP_MUL_MEAT_1_imm(_FP_WFRACBITS_S,R,X,Y)
+#define _FP_MUL_MEAT_D(R,X,Y)					\
+  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_Q(R,X,Y)					\
+  _FP_MUL_MEAT_2_wide_3mul(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)
+
+#define _FP_DIV_MEAT_S(R,X,Y)	_FP_DIV_MEAT_1_imm(S,R,X,Y,_FP_DIV_HELP_imm)
+#define _FP_DIV_MEAT_D(R,X,Y)	_FP_DIV_MEAT_1_udiv_norm(D,R,X,Y)
+#define _FP_DIV_MEAT_Q(R,X,Y)	_FP_DIV_MEAT_2_udiv(Q,R,X,Y)
+
+#define _FP_NANFRAC_S		((_FP_QNANBIT_S << 1) - 1)
+#define _FP_NANFRAC_D		((_FP_QNANBIT_D << 1) - 1)
+#define _FP_NANFRAC_Q		((_FP_QNANBIT_Q << 1) - 1), -1
+#define _FP_NANSIGN_S		0
+#define _FP_NANSIGN_D		0
+#define _FP_NANSIGN_Q		0
+
+#define _FP_KEEPNANFRACP 1
+/* From my experiments it seems X is chosen unless one of the
+   NaNs is sNaN,  in which case the result is NANSIGN/NANFRAC.  */
+#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)			\
+  do {								\
+    if ((_FP_FRAC_HIGH_RAW_##fs(X) |				\
+	 _FP_FRAC_HIGH_RAW_##fs(Y)) & _FP_QNANBIT_##fs)		\
+      {								\
+	R##_s = _FP_NANSIGN_##fs;				\
+        _FP_FRAC_SET_##wc(R,_FP_NANFRAC_##fs);			\
+      }								\
+    else							\
+      {								\
+	R##_s = X##_s;						\
+        _FP_FRAC_COPY_##wc(R,X);				\
+      }								\
+    R##_c = FP_CLS_NAN;						\
+  } while (0)
+
+#define _FP_DECL_EX		fpu_control_t _fcw
+
+#define FP_ROUNDMODE		(_fcw & 0x3)
+
+#define FP_RND_NEAREST		FE_TONEAREST
+#define FP_RND_ZERO		FE_TOWARDZERO
+#define FP_RND_PINF		FE_UPWARD
+#define FP_RND_MINF		FE_DOWNWARD
+
+#define FP_EX_INVALID		FE_INVALID
+#define FP_EX_OVERFLOW		FE_OVERFLOW
+#define FP_EX_UNDERFLOW		FE_UNDERFLOW
+#define FP_EX_DIVZERO		FE_DIVBYZERO
+#define FP_EX_INEXACT		FE_INEXACT
+
+#ifdef __mips_hard_float
+#define FP_INIT_ROUNDMODE			\
+do {						\
+  _FPU_GETCW (_fcw);				\
+} while (0)
+
+#define FP_HANDLE_EXCEPTIONS			\
+do {						\
+  if (__builtin_expect (_fex, 0))		\
+    _FPU_SETCW (_fcw | _fex | (_fex << 10));	\
+} while (0)
+#else
+#define FP_INIT_ROUNDMODE	_fcw = FP_RND_NEAREST
+#endif
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/rv64/Versions glibc-2.14.1/sysdeps/riscv/rv64/Versions
--- ../glibc-2.14.1-orig/sysdeps/riscv/rv64/Versions	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/rv64/Versions	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,7 @@
+libm {
+  GLIBC_2.1 {
+    # A generic bug got this omitted from other configurations' version
+    # sets, but we always had it.
+    exp2l;
+  }
+}
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/setjmp.S glibc-2.14.1/sysdeps/riscv/setjmp.S
--- ../glibc-2.14.1-orig/sysdeps/riscv/setjmp.S	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/setjmp.S	2011-11-02 01:21:55.000000000 -0700
@@ -0,0 +1,75 @@
+/* Copyright (C) 1996, 1997, 2000, 2002, 2003, 2004
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <sys/asm.h>
+
+ENTRY (_setjmp)
+  li	a1, 0
+  j	__sigsetjmp
+END (_setjmp)
+ENTRY (setjmp)
+  li	a1, 1
+  /* Fallthrough */
+END (setjmp)
+ENTRY (__sigsetjmp)
+  REG_S ra,  0*SZREG(a0)
+  REG_S sp,  1*SZREG(a0)
+  REG_S tp,  2*SZREG(a0)
+  REG_S s0,  3*SZREG(a0)
+  REG_S s1,  4*SZREG(a0)
+  REG_S s2,  5*SZREG(a0)
+  REG_S s3,  6*SZREG(a0)
+  REG_S s4,  7*SZREG(a0)
+  REG_S s5,  8*SZREG(a0)
+  REG_S s6,  9*SZREG(a0)
+  REG_S s7, 10*SZREG(a0)
+  REG_S s8, 11*SZREG(a0)
+  REG_S s9, 12*SZREG(a0)
+
+#ifdef __riscv_hard_float
+  mffsr t0
+
+  fsd  fs0, 8*0 + 14*SZREG(a0)
+  fsd  fs1, 8*1 + 14*SZREG(a0)
+  fsd  fs2, 8*2 + 14*SZREG(a0)
+  fsd  fs3, 8*3 + 14*SZREG(a0)
+  fsd  fs4, 8*4 + 14*SZREG(a0)
+  fsd  fs5, 8*5 + 14*SZREG(a0)
+  fsd  fs6, 8*6 + 14*SZREG(a0)
+  fsd  fs7, 8*7 + 14*SZREG(a0)
+  fsd  fs8, 8*8 + 14*SZREG(a0)
+  fsd  fs9, 8*9 + 14*SZREG(a0)
+
+  REG_S t0, 13*SZREG(a0)
+#endif
+
+#if defined NOT_IN_libc && defined IS_IN_rtld
+  /* In ld.so we never save the signal mask.  */
+  li v0, 0
+  ret
+#else
+  /* Make a tail call to __sigjmp_save; it takes the same args.  */
+  j __sigjmp_save
+#endif
+
+
+END(__sigsetjmp)
+
+weak_alias(_setjmp, __GI__setjmp)
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/sgidefs.h glibc-2.14.1/sysdeps/riscv/sgidefs.h
--- ../glibc-2.14.1-orig/sysdeps/riscv/sgidefs.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/sgidefs.h	2011-10-27 22:22:09.000000000 -0700
@@ -0,0 +1,41 @@
+/* Copyright (C) 1996, 1997, 1998, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ralf Baechle <ralf@gnu.org>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SGIDEFS_H
+#define _SGIDEFS_H	1
+
+/*
+ * Subprogram calling convention
+ */
+#ifndef _ABIO32
+# define _ABIO32		1
+#endif
+#define _RISCV_SIM_ABI32		_ABIO32
+
+#ifndef _ABIN32
+# define _ABIN32		2
+#endif
+#define _RISCV_SIM_NABI32	_ABIN32
+
+#ifndef _ABI64
+# define _ABI64			3
+#endif
+#define _RISCV_SIM_ABI64		_ABI64
+
+#endif /* sgidefs.h */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/shlib-versions glibc-2.14.1/sysdeps/riscv/shlib-versions
--- ../glibc-2.14.1-orig/sysdeps/riscv/shlib-versions	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/shlib-versions	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,21 @@
+mips.*-.*-linux.*	libm=6			GLIBC_2.0 GLIBC_2.2
+
+# Working mips versions were never released between 2.0 and 2.2.
+mips.*-.*-linux.*	libc=6			GLIBC_2.0 GLIBC_2.2
+
+mips.*-.*-linux.*	ld=ld.so.1		GLIBC_2.0 GLIBC_2.2
+mips.*-.*-linux.*	libdl=2			GLIBC_2.0 GLIBC_2.2
+
+mips.*-.*-linux.*	libresolv=2		GLIBC_2.0 GLIBC_2.2
+
+mips.*-.*-linux.*	libnss_files=2		GLIBC_2.0 GLIBC_2.2
+mips.*-.*-linux.*	libnss_dns=2		GLIBC_2.0 GLIBC_2.2
+mips.*-.*-linux.*	libnss_compat=2		GLIBC_2.0 GLIBC_2.2
+mips.*-.*-linux.*	libnss_nis=2		GLIBC_2.0 GLIBC_2.2
+mips.*-.*-linux.*	libnss_nisplus=2	GLIBC_2.0 GLIBC_2.2
+mips.*-.*-linux.*	libnss_ldap=2		GLIBC_2.0 GLIBC_2.2
+mips.*-.*-linux.*	libnss_hesiod=2		GLIBC_2.0 GLIBC_2.2
+
+mips.*-.*-linux.*	libnsl=1		GLIBC_2.0 GLIBC_2.2
+
+mips.*-.*-linux.*	librt=1			GLIBC_2.0 GLIBC_2.2
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/soft-fp/sfp-machine.h glibc-2.14.1/sysdeps/riscv/soft-fp/sfp-machine.h
--- ../glibc-2.14.1-orig/sysdeps/riscv/soft-fp/sfp-machine.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/soft-fp/sfp-machine.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,47 @@
+#define _FP_W_TYPE_SIZE		32
+#define _FP_W_TYPE		unsigned long
+#define _FP_WS_TYPE		signed long
+#define _FP_I_TYPE		long
+
+#define _FP_MUL_MEAT_S(R,X,Y)				\
+  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_D(R,X,Y)				\
+  _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_Q(R,X,Y)				\
+  _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)
+
+#define _FP_DIV_MEAT_S(R,X,Y)	_FP_DIV_MEAT_1_udiv_norm(S,R,X,Y)
+#define _FP_DIV_MEAT_D(R,X,Y)	_FP_DIV_MEAT_2_udiv(D,R,X,Y)
+#define _FP_DIV_MEAT_Q(R,X,Y)	_FP_DIV_MEAT_4_udiv(Q,R,X,Y)
+
+#define _FP_NANFRAC_S		((_FP_QNANBIT_S << 1) - 1)
+#define _FP_NANFRAC_D		((_FP_QNANBIT_D << 1) - 1), -1
+#define _FP_NANFRAC_Q		((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1
+#define _FP_NANSIGN_S		0
+#define _FP_NANSIGN_D		0
+#define _FP_NANSIGN_Q		0
+
+#define _FP_KEEPNANFRACP 1
+/* From my experiments it seems X is chosen unless one of the
+   NaNs is sNaN,  in which case the result is NANSIGN/NANFRAC.  */
+#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)			\
+  do {								\
+    if ((_FP_FRAC_HIGH_RAW_##fs(X) |				\
+	 _FP_FRAC_HIGH_RAW_##fs(Y)) & _FP_QNANBIT_##fs)		\
+      {								\
+	R##_s = _FP_NANSIGN_##fs;				\
+        _FP_FRAC_SET_##wc(R,_FP_NANFRAC_##fs);			\
+      }								\
+    else							\
+      {								\
+	R##_s = X##_s;						\
+        _FP_FRAC_COPY_##wc(R,X);				\
+      }								\
+    R##_c = FP_CLS_NAN;						\
+  } while (0)
+
+#define FP_EX_INVALID           (1 << 4)
+#define FP_EX_DIVZERO           (1 << 3)
+#define FP_EX_OVERFLOW          (1 << 2)
+#define FP_EX_UNDERFLOW         (1 << 1)
+#define FP_EX_INEXACT           (1 << 0)
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/stackinfo.h glibc-2.14.1/sysdeps/riscv/stackinfo.h
--- ../glibc-2.14.1-orig/sysdeps/riscv/stackinfo.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/stackinfo.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,34 @@
+/* Copyright (C) 2000, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* This file contains a bit of information about the stack allocation
+   of the processor.  */
+
+#ifndef _STACKINFO_H
+#define _STACKINFO_H	1
+
+#include <elf.h>
+
+/* On MIPS the stack grows down.  */
+#define _STACK_GROWS_DOWN	1
+
+/* Default to an executable stack.  PF_X can be overridden if PT_GNU_STACK is
+ * present, but it is presumed absent.  */
+#define DEFAULT_STACK_PERMS (PF_R|PF_W|PF_X)
+
+#endif	/* stackinfo.h */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/sys/asm.h glibc-2.14.1/sysdeps/riscv/sys/asm.h
--- ../glibc-2.14.1-orig/sysdeps/riscv/sys/asm.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/sys/asm.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,206 @@
+/* Copyright (C) 1997, 1998, 2002, 2003, 2004, 2005
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ralf Baechle <ralf@gnu.org>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_ASM_H
+#define _SYS_ASM_H
+
+#ifndef CAT
+# ifdef __STDC__
+#  define __CAT(str1,str2) str1##str2
+# else
+#  define __CAT(str1,str2) str1/**/str2
+# endif
+# define CAT(str1,str2) __CAT(str1,str2)
+#endif
+
+/*
+ * Macros to handle different pointer/register sizes for 32/64-bit code
+ *
+ * 64 bit address space isn't used yet, so we may use the R3000 32 bit
+ * defines for now.
+ */
+#ifdef __riscv64
+# define PTR .dword
+# define PTRSIZE 8
+# define PTRLOG 3
+#else
+# define PTR .word
+# define PTRSIZE 4
+# define PTRLOG 2
+#endif
+
+/*
+ * For callee-saved gp calling convention:
+ */
+#ifdef __PIC__
+
+# define SETUP_GP64_(gp_reg, func, pc_reg) 		\
+  lui   gp_reg, %hi(%neg(%gp_rel(func)));		\
+  add   gp_reg, gp_reg, %lo(%neg(%gp_rel(func)));	\
+  add   gp_reg, gp_reg, pc_reg
+
+# define SETUP_GP64(gp_reg, func) SETUP_GP64_(gp_reg, func, t7)
+
+# define SETUP_GPX64(gp_reg, scratch)	\
+  rdnpc scratch;			\
+10: SETUP_GP64_(gp_reg, 10b, scratch)
+
+# define PIC_LA(dst, gp_reg, sym)	\
+  lui   dst, %got_hi(sym);		\
+  add   dst, dst, gp_reg;		\
+  REG_L dst, %got_lo(sym)(dst)
+
+# define PIC_JAL(gp_reg, target)	\
+  PIC_LA(t7, gp_reg, target); 		\
+  jalr t7
+
+# define PIC_J(target)              	\
+  SETUP_GPX64(t6, t7);          	\
+  PIC_LA(t7, t6, target);       	\
+  jr t7
+
+# define PIC_ASM_DECL .abicalls; .option pic2
+
+#else
+
+# define SETUP_GP64(gp_reg, func)
+# define SETUP_GPX64(gp_reg, scratch)
+# define PIC_LA(dst, gp_reg, sym) la dst, sym
+# define PIC_JAL(gp_reg, target) jal target
+# define PIC_J(target) j target
+
+# define PIC_ASM_DECL .abicalls; .option pic0
+
+#endif
+
+/*
+ * Stack Frame Definitions
+ */
+#define NARGSAVE 0 /* No caller responsibilities.  */
+
+
+/*
+ * LEAF - declare leaf routine
+ */
+#define	LEAF(symbol)	\
+		PIC_ASM_DECL;				\
+		.globl	symbol;                         \
+		.align	2;                              \
+		.type	symbol,@function;               \
+		.ent	symbol,0;                       \
+symbol:
+
+/*
+ * NESTED - declare nested routine entry point
+ */
+#define	NESTED(symbol, framesize, rpc)                  \
+		.globl	symbol;                         \
+		.align	2;                              \
+		.type	symbol,@function;               \
+		.ent	symbol,0;                       \
+symbol:		.frame	sp, framesize, rpc
+
+/*
+ * END - mark end of function
+ */
+#ifndef END
+# define END(function)                                   \
+		.end	function;		        \
+		.size	function,.-function
+#endif
+
+/*
+ * EXPORT - export definition of symbol
+ */
+#define	EXPORT(symbol)                                  \
+		.globl	symbol;                         \
+symbol:
+
+/*
+ * ABS - export absolute symbol
+ */
+#define	ABS(symbol,value)                               \
+		.globl	symbol;                         \
+symbol		=	value
+
+#define	PANIC(msg)                                      \
+		.set	push;				\
+		.set	reorder;                        \
+		la	a0,8f;                          \
+		jal	panic;                          \
+9:		b	9b;                             \
+		.set	pop;				\
+		TEXT(msg)
+
+/*
+ * Print formated string
+ */
+#define PRINT(string)                                   \
+		.set	push;				\
+		.set	reorder;                        \
+		la	a0,8f;                          \
+		jal	printk;                         \
+		.set	pop;				\
+		TEXT(string)
+
+#define	TEXT(msg)                                       \
+		.data;                                  \
+8:		.asciiz	msg;                            \
+		.previous;
+
+/*
+ * Build text tables
+ */
+#define TTABLE(string)                                  \
+		.text;                                  \
+		.word	1f;                             \
+		.previous;                              \
+		.data;                                  \
+1:		.asciz	string;                         \
+		.previous
+
+/*
+ * Stack alignment
+ */
+#define ALSZ	15
+#define ALMASK	~15
+
+/*
+ * Size of a register
+ */
+#ifdef __riscv64
+# define SZREG	8
+#else
+# define SZREG	4
+#endif
+
+/*
+ * Use the following macros in assemblercode to load/store registers,
+ * pointers etc.
+ */
+#if (SZREG == 4)
+# define REG_S sw
+# define REG_L lw
+#else
+# define REG_S sd
+# define REG_L ld
+#endif
+
+#endif /* sys/asm.h */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/sys/ucontext.h glibc-2.14.1/sysdeps/riscv/sys/ucontext.h
--- ../glibc-2.14.1-orig/sysdeps/riscv/sys/ucontext.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/sys/ucontext.h	2011-11-03 19:08:52.000000000 -0700
@@ -0,0 +1,144 @@
+/* Copyright (C) 1998, 1999, 2002, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* System V/mips ABI compliant context switching support.  */
+
+#ifndef _SYS_UCONTEXT_H
+#define _SYS_UCONTEXT_H	1
+
+#include <features.h>
+#include <signal.h>
+
+/* Type for general register.  */
+typedef unsigned long greg_t;
+
+/* Number of general registers.  */
+#define NGREG	36
+
+/* Container for all general registers.  */
+typedef greg_t gregset_t[NGREG];
+
+/* Number of each register is the `gregset_t' array.  */
+enum
+{
+  CTX_R0 = 0,
+#define CTX_R0	CTX_R0
+  CTX_AT = 1,
+#define CTX_AT	CTX_AT
+  CTX_V0 = 2,
+#define CTX_V0	CTX_V0
+  CTX_V1 = 3,
+#define CTX_V1	CTX_V1
+  CTX_A0 = 4,
+#define CTX_A0	CTX_A0
+  CTX_A1 = 5,
+#define CTX_A1	CTX_A1
+  CTX_A2 = 6,
+#define CTX_A2	CTX_A2
+  CTX_A3 = 7,
+#define CTX_A3	CTX_A3
+  CTX_T0 = 8,
+#define CTX_T0	CTX_T0
+  CTX_T1 = 9,
+#define CTX_T1	CTX_T1
+  CTX_T2 = 10,
+#define CTX_T2	CTX_T2
+  CTX_T3 = 11,
+#define CTX_T3	CTX_T3
+  CTX_T4 = 12,
+#define CTX_T4	CTX_T4
+  CTX_T5 = 13,
+#define CTX_T5	CTX_T5
+  CTX_T6 = 14,
+#define CTX_T6	CTX_T6
+  CTX_T7 = 15,
+#define CTX_T7	CTX_T7
+  CTX_S0 = 16,
+#define CTX_S0	CTX_S0
+  CTX_S1 = 17,
+#define CTX_S1	CTX_S1
+  CTX_S2 = 18,
+#define CTX_S2	CTX_S2
+  CTX_S3 = 19,
+#define CTX_S3	CTX_S3
+  CTX_S4 = 20,
+#define CTX_S4	CTX_S4
+  CTX_S5 = 21,
+#define CTX_S5	CTX_S5
+  CTX_S6 = 22,
+#define CTX_S6	CTX_S6
+  CTX_S7 = 23,
+#define CTX_S7	CTX_S7
+  CTX_T8 = 24,
+#define CTX_T8	CTX_T8
+  CTX_T9 = 25,
+#define CTX_T9	CTX_T9
+  CTX_K0 = 26,
+#define CTX_K0	CTX_K0
+  CTX_K1 = 27,
+#define CTX_K1	CTX_K1
+  CTX_GP = 28,
+#define CTX_GP	CTX_GP
+  CTX_SP = 29,
+#define CTX_SP	CTX_SP
+  CTX_S8 = 30,
+#define CTX_S8	CTX_S8
+  CTX_RA = 31,
+#define CTX_RA	CTX_RA
+  CTX_MDLO = 32,
+#define CTX_MDLO	CTX_MDLO
+  CTX_MDHI = 33,
+#define CTX_MDHI	CTX_MDHI
+  CTX_CAUSE = 34,
+#define CTX_CAUSE	CTX_CAUSE
+  CTX_EPC = 35,
+#define CTX_EPC	CTX_EPC
+};
+
+/* Structure to describe FPU registers.  */
+typedef struct fpregset
+{
+  union
+  {
+    double fp_dregs[32];
+    /* float fp_fregs[32]; */
+    __uint64_t fp_regs[32];
+  } fp_r;
+  unsigned int fp_csr;
+  unsigned int fp_pad;
+} fpregset_t;
+
+/* Context to describe whole processor state.  */
+typedef struct
+{
+  gregset_t gpregs;
+  fpregset_t fpregs;
+} mcontext_t;
+
+/* Userlevel context.  */
+typedef struct ucontext
+{
+  unsigned long int uc_flags;
+  struct ucontext *uc_link;
+  __sigset_t uc_sigmask;
+  stack_t uc_stack;
+  mcontext_t uc_mcontext;
+  int uc_filler[48];
+} ucontext_t;
+
+#endif /* sys/ucontext.h */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/tcb-offsets.sym glibc-2.14.1/sysdeps/riscv/tcb-offsets.sym
--- ../glibc-2.14.1-orig/sysdeps/riscv/tcb-offsets.sym	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/tcb-offsets.sym	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,11 @@
+#include <sysdep.h>
+#include <tls.h>
+
+--
+
+-- Abuse tls.h macros to derive offsets relative to the thread register.
+#define thread_offsetof(mem)	(long)(offsetof(struct pthread, mem) - TLS_TCB_OFFSET - TLS_PRE_TCB_SIZE)
+
+MULTIPLE_THREADS_OFFSET		thread_offsetof (header.multiple_threads)
+PID_OFFSET			thread_offsetof (pid)
+TID_OFFSET			thread_offsetof (tid)
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/tls-macros.h glibc-2.14.1/sysdeps/riscv/tls-macros.h
--- ../glibc-2.14.1-orig/sysdeps/riscv/tls-macros.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/tls-macros.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,51 @@
+/* Macros to support TLS testing in times of missing compiler support.  */
+
+#include <sys/cdefs.h>
+#include <sys/asm.h>
+
+#define __STRING2(X) __STRING(X)
+#define LW __STRING2(REG_L)
+
+/* Load the GOT pointer, which may not be in $28 in a non-PIC
+   (abicalls pic0) function.  */
+#ifndef __PIC__
+# define LOAD_GP "move %[tmp], gp\n\tla gp, __gnu_local_gp\n\t"
+# define UNLOAD_GP "\n\tmove gp, %[tmp]"
+#else
+# define LOAD_GP
+# define UNLOAD_GP
+#endif
+
+# define TLS_GD(x)					\
+  ({ void *__result, *__tmp;				\
+     extern void *__tls_get_addr (void *);		\
+     asm ("addi %0, gp, %%tlsgd(" #x ")"	        \
+	  UNLOAD_GP					\
+	  : "=r" (__result), [tmp] "=&r" (__tmp));	\
+     (int *)__tls_get_addr (__result); })
+# define TLS_LD(x)					\
+  ({ void *__result, *__tmp;				\
+     extern void *__tls_get_addr (void *);		\
+     asm (LOAD_GP "addi %0, gp, %%tlsldm(" #x ")"	\
+	  UNLOAD_GP					\
+	  : "=r" (__result), [tmp] "=&r" (__tmp));	\
+     __result = __tls_get_addr (__result);		\
+     asm ("lui %1,%%dtprel_hi(" #x ")\n\t"		\
+	  "addi %1,%1,%%dtprel_lo(" #x ")\n\t"		\
+	  "add %0,%0,%1"				\
+	  : "+r" (__result), "=&r"(__tmp));		\
+     __result; })
+# define TLS_IE(x)					\
+  ({ void *__result, *__tmp, *__tmp2;			\
+     asm (LOAD_GP LW " %2,%%gottprel(" #x ")(gp)\n\t"	\
+	  "add %0,tp,%2"				\
+	  UNLOAD_GP					\
+	  : "=r" (__result), [tmp] "=&r" (__tmp), "=&r" (__tmp2)); \
+     __result; })
+# define TLS_LE(x)					\
+  ({ void *__result, *__tmp;				\
+     asm ("lui %1,%%tprel_hi(" #x ")\n\t"		\
+	  "addi %1,%1,%%tprel_lo(" #x ")\n\t"		\
+	  "add %0,tp,%1"				\
+	  : "=r" (__result), "=&r" (__tmp)		\
+     __result; })
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/riscv/tst-audit.h glibc-2.14.1/sysdeps/riscv/tst-audit.h
--- ../glibc-2.14.1-orig/sysdeps/riscv/tst-audit.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/riscv/tst-audit.h	2011-11-03 19:05:17.000000000 -0700
@@ -0,0 +1,33 @@
+/* Definitions for testing PLT entry/exit auditing.  ARM version.
+
+   Copyright (C) 2005 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sgidefs.h>
+
+#if _RISCV_SIM == _ABI32
+#define pltenter la_mips_n32_gnu_pltenter
+#define pltexit la_mips_n32_gnu_pltexit
+#else
+#define pltenter la_mips_n64_gnu_pltenter
+#define pltexit la_mips_n64_gnu_pltexit
+#endif
+#define La_regs La_mips_64_regs
+#define La_retval La_mips_64_retval
+#define int_retval lrv_v0
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/riscv/pipe.S glibc-2.14.1/sysdeps/unix/riscv/pipe.S
--- ../glibc-2.14.1-orig/sysdeps/unix/riscv/pipe.S	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/riscv/pipe.S	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,33 @@
+/* Copyright (C) 1992, 1995, 1997, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Brendan Kehoe (brendan@zen.org).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+SYSCALL__ (pipe, 1)
+	/* Plop in the two descriptors.  */
+	sw v0, 0(a0)
+	sw v1, 4(a0)
+
+	/* Go out with a clean status.  */
+	move v0, zero
+	ret
+PSEUDO_END(__pipe)
+
+libc_hidden_def (__pipe)
+weak_alias (__pipe, pipe)
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/riscv/rt-sysdep.c glibc-2.14.1/sysdeps/unix/riscv/rt-sysdep.c
--- ../glibc-2.14.1-orig/sysdeps/unix/riscv/rt-sysdep.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/riscv/rt-sysdep.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1 @@
+#include <sysdep.c>
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/riscv/sysdep.c glibc-2.14.1/sysdeps/unix/riscv/sysdep.c
--- ../glibc-2.14.1-orig/sysdeps/unix/riscv/sysdep.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/riscv/sysdep.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,43 @@
+/* Copyright (C) 1992, 1993, 1994, 1997, 1998, 1999, 2000, 2002, 2003 
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Brendan Kehoe (brendan@zen.org).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <errno.h>
+
+long __syscall_error()
+{
+  register long v0 asm("v0");
+
+  /* Referencing errno may call a function, clobbering v0. */
+  long errno_val = v0;
+
+#if defined (EWOULDBLOCK_sys) && EWOULDBLOCK_sys != EAGAIN
+	/* We translate the system's EWOULDBLOCK error into EAGAIN.
+	   The GNU C library always defines EWOULDBLOCK==EAGAIN.
+	   EWOULDBLOCK_sys is the original number.  */
+
+  if (errno_val == EWOULDBLOCK_sys)
+    errno_val = EAGAIN;
+#endif
+
+  errno = errno_val;
+
+  return -1;
+}
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/riscv/sysdep.h glibc-2.14.1/sysdeps/unix/riscv/sysdep.h
--- ../glibc-2.14.1-orig/sysdeps/unix/riscv/sysdep.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/riscv/sysdep.h	2011-10-27 22:23:40.000000000 -0700
@@ -0,0 +1,73 @@
+/* Copyright (C) 1992, 1995, 1997, 1999, 2000, 2002, 2003, 2004
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Brendan Kehoe (brendan@zen.org).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdeps/unix/sysdep.h>
+
+#ifdef __ASSEMBLER__
+
+#include <sys/asm.h>
+
+#define ENTRY(name) LEAF(name)
+
+#undef END
+#define	END(function)                                   \
+		.end	function;		        \
+		.size	function,.-function
+
+#define ret	ret
+
+#undef PSEUDO_END
+#define PSEUDO_END(sym) .end sym; .size sym,.-sym
+
+#define PSEUDO_NOERRNO(name, syscall_name, args)	\
+  .align 2;						\
+  ENTRY(name)						\
+  li v0, SYS_ify(syscall_name);				\
+  syscall
+
+#undef PSEUDO_END_NOERRNO
+#define PSEUDO_END_NOERRNO(sym) .end sym; .size sym,.-sym
+
+#define ret_NOERRNO ret
+
+#define PSEUDO_ERRVAL(name, syscall_name, args) \
+  PSEUDO_NOERRNO(name, syscall_name, args)
+
+#undef PSEUDO_END_ERRVAL
+#define PSEUDO_END_ERRVAL(sym) PSEUDO_END_NOERRNO(sym)
+
+#define ret_ERRVAL ret
+
+#define r0	v0
+#define r1	v1
+#define MOVE(x,y)	move y , x
+
+#define L(label) .L ## label
+
+#define PSEUDO(name, syscall_name, args) \
+  .align 2;							\
+  99: PIC_J(__syscall_error);					\
+  ENTRY(name)							\
+  li v0, SYS_ify(syscall_name);					\
+  syscall;							\
+  bne a3, zero, 99b;						\
+L(syse1):
+
+#endif
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/bits/endian.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/endian.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/bits/endian.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/endian.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,16 @@
+/* The MIPS architecture has selectable endianness.
+   Linux/MIPS exists in two both little and big endian flavours and we
+   want to be able to share the installed headerfiles between both,
+   so we define __BYTE_ORDER based on GCC's predefines.  */
+
+#ifndef _ENDIAN_H
+# error "Never use <bits/endian.h> directly; include <endian.h> instead."
+#endif
+
+#ifdef __RISCVEB__
+# define __BYTE_ORDER __BIG_ENDIAN
+#else
+# ifdef __RISCVEL__
+#  define __BYTE_ORDER __LITTLE_ENDIAN
+# endif
+#endif
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/bits/errno.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/errno.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/bits/errno.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/errno.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,63 @@
+/* Error constants.  MIPS/Linux specific version.
+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2006
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifdef _ERRNO_H
+
+# undef EDOM
+# undef EILSEQ
+# undef ERANGE
+# include <linux/errno.h>
+
+/* Linux has no ENOTSUP error code.  */
+# define ENOTSUP EOPNOTSUPP
+
+# ifndef ECANCELED
+#  define ECANCELED	158
+# endif
+
+/* Support for error codes to support robust mutexes was added later, too.  */
+# ifndef EOWNERDEAD
+#  define EOWNERDEAD		165
+#  define ENOTRECOVERABLE	166
+# endif
+
+# ifndef ERFKILL
+#  define ERFKILL		167
+# endif
+
+# ifndef __ASSEMBLER__
+/* Function to get address of global `errno' variable.  */
+extern int *__errno_location (void) __THROW __attribute__ ((__const__));
+
+#  if !defined _LIBC || defined _LIBC_REENTRANT
+/* When using threads, errno is a per-thread value.  */
+#   define errno (*__errno_location ())
+#  endif
+# endif /* !__ASSEMBLER__ */
+#endif /* _ERRNO_H */
+
+#if !defined _ERRNO_H && defined __need_Emath
+/* This is ugly but the kernel header is not clean enough.  We must
+   define only the values EDOM, EILSEQ and ERANGE in case __need_Emath is
+   defined.  */
+# define EDOM	33	/* Math argument out of domain of function.  */
+# define EILSEQ	88	/* Illegal byte sequence.  */
+# define ERANGE	34	/* Math result not representable.  */
+#endif /* !_ERRNO_H && __need_Emath */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/bits/fcntl.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/fcntl.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/bits/fcntl.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/fcntl.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,296 @@
+/* O_*, F_*, FD_* bit values for Linux.
+   Copyright (C) 1995, 1996, 1997, 1998, 2000, 2002, 2003, 2004, 2006,
+   2007, 2009, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_FCNTL_H
+# error "Never use <bits/fcntl.h> directly; include <fcntl.h> instead."
+#endif
+
+#include <sgidefs.h>
+#include <sys/types.h>
+#ifdef __USE_GNU
+# include <bits/uio.h>
+#endif
+
+
+/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
+   located on an ext2 file system */
+#define O_ACCMODE	   0003
+#define O_RDONLY	     00
+#define O_WRONLY	     01
+#define O_RDWR		     02
+#define O_APPEND	 0x0008
+#define O_SYNC		 0x4010
+#define O_NONBLOCK	 0x0080
+#define O_NDELAY	O_NONBLOCK
+#define O_CREAT		 0x0100	/* not fcntl */
+#define O_TRUNC		 0x0200	/* not fcntl */
+#define O_EXCL		 0x0400	/* not fcntl */
+#define O_NOCTTY	 0x0800	/* not fcntl */
+#define O_FSYNC		 O_SYNC
+#define O_ASYNC		 0x1000
+
+#ifdef __USE_XOPEN2K8
+# define O_NOFOLLOW	0x20000	/* Do not follow links.	 */
+# define O_DIRECTORY	0x10000	/* Must be a directory.	 */
+# define O_CLOEXEC     02000000 /* Set close_on_exec.  */
+#endif
+#ifdef __USE_GNU
+# define O_DIRECT	0x8000	/* Direct disk access hint.  */
+# define O_NOATIME	0x40000	/* Do not set atime.  */
+#endif
+
+/* For now Linux has no synchronisity options for data and read operations.
+   We define the symbols here but let them do the same as O_SYNC since
+   this is a superset.	*/
+#if defined __USE_POSIX199309 || defined __USE_UNIX98
+# define O_DSYNC	0x0010	/* Synchronize data.  */
+# define O_RSYNC	O_SYNC	/* Synchronize read operations.	 */
+#endif
+
+#ifdef __USE_LARGEFILE64
+# define O_LARGEFILE	0x2000	/* Allow large file opens.  */
+#endif
+
+/* Values for the second argument to `fcntl'.  */
+#define F_DUPFD		0	/* Duplicate file descriptor.  */
+#define F_GETFD		1	/* Get file descriptor flags.  */
+#define F_SETFD		2	/* Set file descriptor flags.  */
+#define F_GETFL		3	/* Get file status flags.  */
+#define F_SETFL		4	/* Set file status flags.  */
+#ifndef __USE_FILE_OFFSET64
+# define F_GETLK	14	/* Get record locking info.  */
+# define F_SETLK	6	/* Set record locking info (non-blocking).  */
+# define F_SETLKW	7	/* Set record locking info (blocking).	*/
+#else
+# define F_GETLK	F_GETLK64  /* Get record locking info.	*/
+# define F_SETLK	F_SETLK64  /* Set record locking info (non-blocking).*/
+# define F_SETLKW	F_SETLKW64 /* Set record locking info (blocking).  */
+#endif
+
+#define F_GETLK64	33	/* Get record locking info.  */
+#define F_SETLK64	34	/* Set record locking info (non-blocking).  */
+#define F_SETLKW64	35	/* Set record locking info (blocking).	*/
+
+#if defined __USE_BSD || defined __USE_UNIX98 || defined __USE_XOPEN2K8
+# define F_SETOWN	24	/* Get owner (process receiving SIGIO).  */
+# define F_GETOWN	23	/* Set owner (process receiving SIGIO).  */
+#endif
+
+#ifdef __USE_GNU
+# define F_SETSIG	10	/* Set number of signal to be sent.  */
+# define F_GETSIG	11	/* Get number of signal to be sent.  */
+# define F_SETOWN_EX	15	/* Get owner (thread receiving SIGIO).  */
+# define F_GETOWN_EX	16	/* Set owner (thread receiving SIGIO).  */
+#endif
+
+#ifdef __USE_GNU
+# define F_SETLEASE	1024	/* Set a lease.	 */
+# define F_GETLEASE	1025	/* Enquire what lease is active.  */
+# define F_NOTIFY	1026	/* Request notfications on a directory.	 */
+# define F_SETPIPE_SZ	1031	/* Set pipe page size array.  */
+# define F_GETPIPE_SZ	1032	/* Set pipe page size array.  */
+#endif
+#ifdef __USE_XOPEN2K8
+# define F_DUPFD_CLOEXEC 1030	/* Duplicate file descriptor with
+				   close-on-exit set.  */
+#endif
+
+/* For F_[GET|SET]FD.  */
+#define FD_CLOEXEC	1	/* actually anything with low bit set goes */
+
+/* For posix fcntl() and `l_type' field of a `struct flock' for lockf().  */
+#define F_RDLCK		0	/* Read lock.  */
+#define F_WRLCK		1	/* Write lock.	*/
+#define F_UNLCK		2	/* Remove lock.	 */
+
+/* For old implementation of bsd flock().  */
+#define F_EXLCK		4	/* or 3 */
+#define F_SHLCK		8	/* or 4 */
+
+#ifdef __USE_BSD
+/* Operations for bsd flock(), also used by the kernel implementation.	*/
+# define LOCK_SH	1	/* shared lock */
+# define LOCK_EX	2	/* exclusive lock */
+# define LOCK_NB	4	/* or'd with one of the above to prevent
+				   blocking */
+# define LOCK_UN	8	/* remove lock */
+#endif
+
+#ifdef __USE_GNU
+# define LOCK_MAND	32	/* This is a mandatory flock:	*/
+# define LOCK_READ	64	/* ... which allows concurrent read operations.	 */
+# define LOCK_WRITE	128	/* ... which allows concurrent write operations.  */
+# define LOCK_RW	192	/* ... Which allows concurrent read & write operations.	 */
+#endif
+
+#ifdef __USE_GNU
+/* Types of directory notifications that may be requested with F_NOTIFY.  */
+# define DN_ACCESS	0x00000001	/* File accessed.  */
+# define DN_MODIFY	0x00000002	/* File modified.  */
+# define DN_CREATE	0x00000004	/* File created.  */
+# define DN_DELETE	0x00000008	/* File removed.  */
+# define DN_RENAME	0x00000010	/* File renamed.  */
+# define DN_ATTRIB	0x00000020	/* File changed attibutes.  */
+# define DN_MULTISHOT	0x80000000	/* Don't remove notifier.  */
+#endif
+
+struct flock
+  {
+    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*/
+    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+#ifndef __USE_FILE_OFFSET64
+    __off_t l_start;	/* Offset where the lock begins.  */
+    __off_t l_len;	/* Size of the locked area; zero means until EOF.  */
+#if _RISCV_SIM != _ABI64
+    /* The 64-bit flock structure, used by the n64 ABI, and for 64-bit
+       fcntls in o32 and n32, never has this field.  */
+    long int l_sysid;
+#endif
+#else
+    __off64_t l_start;	/* Offset where the lock begins.  */
+    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
+#endif
+    __pid_t l_pid;	/* Process holding the lock.  */
+#if ! defined __USE_FILE_OFFSET64 && _RISCV_SIM != _ABI64
+    /* The 64-bit flock structure, used by the n64 ABI, and for 64-bit
+       flock in o32 and n32, never has this field.  */
+    long int pad[4];
+#endif
+  };
+typedef struct flock flock_t;
+
+#ifdef __USE_LARGEFILE64
+struct flock64
+  {
+    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*/
+    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+    __off64_t l_start;	/* Offset where the lock begins.  */
+    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
+    __pid_t l_pid;	/* Process holding the lock.  */
+  };
+#endif
+
+#ifdef __USE_GNU
+/* Owner types.  */
+enum __pid_type
+  {
+    F_OWNER_TID = 0,		/* Kernel thread.  */
+    F_OWNER_PID,		/* Process.  */
+    F_OWNER_PGRP,		/* Process group.  */
+    F_OWNER_GID = F_OWNER_PGRP	/* Alternative, obsolete name.  */
+  };
+
+/* Structure to use with F_GETOWN_EX and F_SETOWN_EX.  */
+struct f_owner_ex
+  {
+    enum __pid_type type;	/* Owner type of ID.  */
+    __pid_t pid;		/* ID of owner.  */
+  };
+#endif
+
+/* Define some more compatibility macros to be backward compatible with
+   BSD systems which did not managed to hide these kernel macros.  */
+#ifdef	__USE_BSD
+# define FAPPEND	O_APPEND
+# define FFSYNC		O_FSYNC
+# define FASYNC		O_ASYNC
+# define FNONBLOCK	O_NONBLOCK
+# define FNDELAY	O_NDELAY
+#endif /* Use BSD.  */
+
+/* Advise to `posix_fadvise'.  */
+#ifdef __USE_XOPEN2K
+# define POSIX_FADV_NORMAL	0 /* No further special treatment.  */
+# define POSIX_FADV_RANDOM	1 /* Expect random page references.  */
+# define POSIX_FADV_SEQUENTIAL	2 /* Expect sequential page references.	 */
+# define POSIX_FADV_WILLNEED	3 /* Will need these pages.  */
+# define POSIX_FADV_DONTNEED	4 /* Don't need these pages.  */
+# define POSIX_FADV_NOREUSE	5 /* Data will be accessed once.  */
+#endif
+
+
+#ifdef __USE_GNU
+/* Flags for SYNC_FILE_RANGE.  */
+# define SYNC_FILE_RANGE_WAIT_BEFORE	1 /* Wait upon writeout of all pages
+					     in the range before performing the
+					     write.  */
+# define SYNC_FILE_RANGE_WRITE		2 /* Initiate writeout of all those
+					     dirty pages in the range which are
+					     not presently under writeback.  */
+# define SYNC_FILE_RANGE_WAIT_AFTER	4 /* Wait upon writeout of all pages in
+					     the range after performing the
+					     write.  */
+
+/* Flags for SPLICE and VMSPLICE.  */
+# define SPLICE_F_MOVE		1	/* Move pages instead of copying.  */
+# define SPLICE_F_NONBLOCK	2	/* Don't block on the pipe splicing
+					   (but we may still block on the fd
+					   we splice from/to).  */
+# define SPLICE_F_MORE		4	/* Expect more data.  */
+# define SPLICE_F_GIFT		8	/* Pages passed in are a gift.  */
+#endif
+
+__BEGIN_DECLS
+
+#ifdef __USE_GNU
+
+/* Provide kernel hint to read ahead.  */
+extern ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
+    __THROW;
+
+
+/* Selective file content synch'ing.  */
+extern int sync_file_range (int __fd, __off64_t __offset, __off64_t __count,
+			    unsigned int __flags);
+
+
+/* Splice address range into a pipe.  */
+extern ssize_t vmsplice (int __fdout, const struct iovec *__iov,
+			 size_t __count, unsigned int __flags);
+
+/* Splice two files together.  */
+extern ssize_t splice (int __fdin, __off64_t *__offin, int __fdout,
+		       __off64_t *__offout, size_t __len,
+		       unsigned int __flags);
+
+/* In-kernel implementation of tee for pipe buffers.  */
+extern ssize_t tee (int __fdin, int __fdout, size_t __len,
+		    unsigned int __flags);
+
+/* Reserve storage for the data of the file associated with FD.  */
+# ifndef __USE_FILE_OFFSET64
+extern int fallocate (int __fd, int __mode, __off_t __offset, __off_t __len);
+# else
+#  ifdef __REDIRECT
+extern int __REDIRECT (fallocate, (int __fd, int __mode, __off64_t __offset,
+				   __off64_t __len),
+		       fallocate64);
+#  else
+#   define fallocate fallocate64
+#  endif
+# endif
+# ifdef __USE_LARGEFILE64
+extern int fallocate64 (int __fd, int __mode, __off64_t __offset,
+			__off64_t __len);
+# endif
+
+#endif
+
+__END_DECLS
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/bits/ioctl-types.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/ioctl-types.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/bits/ioctl-types.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/ioctl-types.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,76 @@
+/* Structure types for pre-termios terminal ioctls.  Linux/MIPS version.
+   Copyright (C) 1997, 1999, 2000, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_IOCTL_H
+# error "Never use <bits/ioctl-types.h> directly; include <sys/ioctl.h> instead."
+#endif
+
+/* Get definition of constants for use with `ioctl'.  */
+#include <asm/ioctls.h>
+
+struct winsize
+  {
+    unsigned short int ws_row;
+    unsigned short int ws_col;
+    unsigned short int ws_xpixel;
+    unsigned short int ws_ypixel;
+  };
+
+#define NCC	8
+struct termio
+  {
+    unsigned short int c_iflag;		/* input mode flags */
+    unsigned short int c_oflag;		/* output mode flags */
+    unsigned short int c_cflag;		/* control mode flags */
+    unsigned short int c_lflag;		/* local mode flags */
+    char c_line;			/* line discipline */
+    /* Yes, this is really NCCS.  */
+    unsigned char c_cc[32 /* NCCS */]; /* control characters */
+  };
+
+/* modem lines */
+#define TIOCM_LE	0x001		/* line enable */
+#define TIOCM_DTR	0x002		/* data terminal ready */
+#define TIOCM_RTS	0x004		/* request to send */
+#define TIOCM_ST	0x010		/* secondary transmit */
+#define TIOCM_SR	0x020		/* secondary receive */
+#define TIOCM_CTS	0x040		/* clear to send */
+#define TIOCM_CAR	0x100		/* carrier detect */
+#define TIOCM_CD	TIOCM_CAR
+#define TIOCM_RNG	0x200		/* ring */
+#define TIOCM_RI	TIOCM_RNG
+#define TIOCM_DSR	0x400		/* data set ready */
+
+/* line disciplines */
+#define N_TTY		0
+#define N_SLIP		1
+#define N_MOUSE		2
+#define N_PPP		3
+#define N_STRIP		4
+#define N_AX25		5
+#define N_X25		6	/* X.25 async  */
+#define N_6PACK		7
+#define N_MASC		8	/* Mobitex module  */
+#define N_R3964		9	/* Simatic R3964 module  */
+#define N_PROFIBUS_FDL	10	/* Profibus  */
+#define N_IRDA		11	/* Linux IR  */
+#define N_SMSBLOCK	12	/* SMS block mode  */
+#define N_HDLC		13	/* synchronous HDLC  */
+#define N_SYNC_PPP	14	/* synchronous PPP  */
+#define	N_HCI		15	/* Bluetooth HCI UART  */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/bits/ipc.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/ipc.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/bits/ipc.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/ipc.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,55 @@
+/* Copyright (C) 1995, 96, 97, 98, 99, 2000, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_IPC_H
+# error "Never use <bits/ipc.h> directly; include <sys/ipc.h> instead."
+#endif
+
+#include <bits/types.h>
+
+/* Mode bits for `msgget', `semget', and `shmget'.  */
+#define IPC_CREAT	01000		/* Create key if key does not exist. */
+#define IPC_EXCL	02000		/* Fail if key exists.	*/
+#define IPC_NOWAIT	04000		/* Return error on wait.  */
+
+/* Control commands for `msgctl', `semctl', and `shmctl'.  */
+#define IPC_RMID	0		/* Remove identifier.  */
+#define IPC_SET		1		/* Set `ipc_perm' options.  */
+#define IPC_STAT	2		/* Get `ipc_perm' options.  */
+#ifdef __USE_GNU
+# define IPC_INFO	3		/* See ipcs.  */
+#endif
+
+/* Special key values.	*/
+#define IPC_PRIVATE	((__key_t) 0)	/* Private key.	 */
+
+
+/* Data structure used to pass permission information to IPC operations.  */
+struct ipc_perm
+  {
+    __key_t __key;			/* Key.  */
+    unsigned int uid;			/* Owner's user ID.  */
+    unsigned int gid;			/* Owner's group ID.  */
+    unsigned int cuid;			/* Creator's user ID.  */
+    unsigned int cgid;			/* Creator's group ID.	*/
+    unsigned int mode;			/* Read/write permission.  */
+    unsigned short int __seq;		/* Sequence number.  */
+    unsigned short int __pad1;
+    unsigned long int __unused1;
+    unsigned long int __unused2;
+};
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/bits/mman.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/mman.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/bits/mman.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/mman.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,111 @@
+/* Definitions for POSIX memory map interface.  Linux/MIPS version.
+   Copyright (C) 1997, 2000, 2003, 2004, 2005, 2006, 2009, 2011
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_MMAN_H
+# error "Never use <bits/mman.h> directly; include <sys/mman.h> instead."
+#endif
+
+/* The following definitions basically come from the kernel headers.
+   But the kernel header is not namespace clean.  */
+
+
+/* Protections are chosen from these bits, OR'd together.  The
+   implementation does not necessarily support PROT_EXEC or PROT_WRITE
+   without PROT_READ.  The only guarantees are that no writing will be
+   allowed without PROT_WRITE and no access will be allowed for PROT_NONE. */
+
+#define PROT_READ	0x1		/* Page can be read.  */
+#define PROT_WRITE	0x2		/* Page can be written.  */
+#define PROT_EXEC	0x4		/* Page can be executed.  */
+#define PROT_NONE	0x0		/* Page can not be accessed.  */
+#define PROT_GROWSDOWN	0x01000000	/* Extend change to start of
+					   growsdown vma (mprotect only).  */
+#define PROT_GROWSUP	0x02000000	/* Extend change to start of
+					   growsup vma (mprotect only).  */
+
+/* Sharing types (must choose one and only one of these).  */
+#define MAP_SHARED	0x01		/* Share changes.  */
+#define MAP_PRIVATE	0x02		/* Changes are private.  */
+#ifdef __USE_MISC
+# define MAP_TYPE	0x0f		/* Mask for type of mapping.  */
+#endif
+
+/* Other flags.  */
+#define MAP_FIXED	0x10		/* Interpret addr exactly.  */
+#ifdef __USE_MISC
+# define MAP_FILE	0
+# define MAP_ANONYMOUS	0x0800		/* Don't use a file.  */
+# define MAP_ANON	MAP_ANONYMOUS
+# define MAP_RENAME	MAP_ANONYMOUS
+#endif
+
+/* These are Linux-specific.  */
+#ifdef __USE_MISC
+# define MAP_NORESERVE	0x0400		/* don't check for reservations */
+# define MAP_ANONYMOUS	0x0800		/* don't use a file */
+# define MAP_GROWSDOWN	0x1000		/* stack-like segment */
+# define MAP_DENYWRITE	0x2000		/* ETXTBSY */
+# define MAP_EXECUTABLE	0x4000		/* mark it as an executable */
+# define MAP_LOCKED	0x8000		/* pages are locked */
+# define MAP_POPULATE   0x10000         /* populate (prefault) pagetables */
+# define MAP_NONBLOCK   0x20000         /* do not block on IO */
+#endif
+
+/* Flags to `msync'.  */
+#define MS_ASYNC	1		/* Sync memory asynchronously.  */
+#define MS_SYNC		4		/* Synchronous memory sync.  */
+#define MS_INVALIDATE	2		/* Invalidate the caches.  */
+
+/* Flags for `mlockall'.  */
+#define MCL_CURRENT	1		/* Lock all currently mapped pages.  */
+#define MCL_FUTURE	2		/* Lock all additions to address
+					   space.  */
+
+/* Flags for `mremap'.  */
+#ifdef __USE_GNU
+# define MREMAP_MAYMOVE	1
+# define MREMAP_FIXED	2
+#endif
+
+/* Advice to `madvise'.  */
+#ifdef __USE_BSD
+# define MADV_NORMAL	  0	/* No further special treatment.  */
+# define MADV_RANDOM	  1	/* Expect random page references.  */
+# define MADV_SEQUENTIAL  2	/* Expect sequential page references.  */
+# define MADV_WILLNEED	  3	/* Will need these pages.  */
+# define MADV_DONTNEED	  4	/* Don't need these pages.  */
+# define MADV_REMOVE	  9	/* Remove these pages and resources.  */
+# define MADV_DONTFORK	  10	/* Do not inherit across fork.  */
+# define MADV_DOFORK	  11	/* Do inherit across fork.  */
+# define MADV_MERGEABLE	  12	/* KSM may merge identical pages.  */
+# define MADV_UNMERGEABLE 13	/* KSM may not merge identical pages.  */
+# define MADV_HUGEPAGE	  14	/* Worth backing with hugepages.  */
+# define MADV_NOHUGEPAGE  15	/* Not worth backing with hugepages.  */
+# define MADV_HWPOISON	  100	/* Poison a page for testing.  */
+#endif
+
+/* The POSIX people had to invent similar names for the same things.  */
+#ifdef __USE_XOPEN2K
+# define POSIX_MADV_NORMAL	0 /* No further special treatment.  */
+# define POSIX_MADV_RANDOM	1 /* Expect random page references.  */
+# define POSIX_MADV_SEQUENTIAL	2 /* Expect sequential page references.  */
+# define POSIX_MADV_WILLNEED	3 /* Will need these pages.  */
+# define POSIX_MADV_DONTNEED	4 /* Don't need these pages.  */
+#endif
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/bits/msq.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/msq.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/bits/msq.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/msq.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,92 @@
+/* Copyright (C) 2002, 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_MSG_H
+# error "Never use <bits/msq.h> directly; include <sys/msg.h> instead."
+#endif
+
+#include <bits/types.h>
+
+/* Define options for message queue functions.  */
+#define MSG_NOERROR	010000	/* no error if message is too big */
+#ifdef __USE_GNU
+# define MSG_EXCEPT	020000	/* recv any msg except of specified type */
+#endif
+
+/* Types used in the structure definition.  */
+typedef unsigned long int msgqnum_t;
+typedef unsigned long int msglen_t;
+
+
+/* Structure of record for one message inside the kernel.
+   The type `struct msg' is opaque.  */
+struct msqid_ds
+{
+  struct ipc_perm msg_perm;	/* structure describing operation permission */
+#if __WORDSIZE == 32 && defined (__MIPSEB__)
+  unsigned long int __unused1;
+#endif
+  __time_t msg_stime;		/* time of last msgsnd command */
+#if __WORDSIZE == 32 && defined (__MIPSEL__)
+  unsigned long int __unused1;
+#endif
+#if __WORDSIZE == 32 && defined (__MIPSEB__)
+  unsigned long int __unused2;
+#endif
+  __time_t msg_rtime;		/* time of last msgrcv command */
+#if __WORDSIZE == 32 && defined (__MIPSEL__)
+  unsigned long int __unused2;
+#endif
+#if __WORDSIZE == 32 && defined (__MIPSEB__)
+  unsigned long int __unused3;
+#endif
+  __time_t msg_ctime;		/* time of last change */
+#if __WORDSIZE == 32 && defined (__MIPSEL__)
+  unsigned long int __unused3;
+#endif
+  unsigned long int __msg_cbytes; /* current number of bytes on queue */
+  msgqnum_t msg_qnum;		/* number of messages currently on queue */
+  msglen_t msg_qbytes;		/* max number of bytes allowed on queue */
+  __pid_t msg_lspid;		/* pid of last msgsnd() */
+  __pid_t msg_lrpid;		/* pid of last msgrcv() */
+  unsigned long int __unused4;
+  unsigned long int __unused5;
+};
+
+#ifdef __USE_MISC
+
+# define msg_cbytes	__msg_cbytes
+
+/* ipcs ctl commands */
+# define MSG_STAT 11
+# define MSG_INFO 12
+
+/* buffer for msgctl calls IPC_INFO, MSG_INFO */
+struct msginfo
+  {
+    int msgpool;
+    int msgmap;
+    int msgmax;
+    int msgmnb;
+    int msgmni;
+    int msgssz;
+    int msgtql;
+    unsigned short int msgseg;
+  };
+
+#endif /* __USE_MISC */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/bits/poll.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/poll.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/bits/poll.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/poll.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,50 @@
+/* Copyright (C) 1997, 2001, 2006, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_POLL_H
+# error "Never use <bits/poll.h> directly; include <sys/poll.h> instead."
+#endif
+
+/* Event types that can be polled for.  These bits may be set in `events'
+   to indicate the interesting event types; they will appear in `revents'
+   to indicate the status of the file descriptor.  */
+#define POLLIN		0x001		/* There is data to read.  */
+#define POLLPRI		0x002		/* There is urgent data to read.  */
+#define POLLOUT		0x004		/* Writing now will not block.  */
+
+#if defined __USE_XOPEN || defined __USE_XOPEN2K8
+/* These values are defined in XPG4.2.  */
+# define POLLRDNORM	0x040		/* Normal data may be read.  */
+# define POLLRDBAND	0x080		/* Priority data may be read.  */
+# define POLLWRNORM	POLLOUT		/* Writing now will not block.  */
+# define POLLWRBAND	0x100		/* Priority data may be written.  */
+#endif
+
+#ifdef __USE_GNU
+/* These are extensions for Linux.  */
+# define POLLMSG	0x400
+# define POLLREMOVE	0x1000
+# define POLLRDHUP	0x2000
+#endif
+
+/* Event types always implicitly polled for.  These bits need not be set in
+   `events', but they will appear in `revents' to indicate the status of
+   the file descriptor.  */
+#define POLLERR		0x008		/* Error condition.  */
+#define POLLHUP		0x010		/* Hung up.  */
+#define POLLNVAL	0x020		/* Invalid polling request.  */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/bits/resource.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/resource.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/bits/resource.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/resource.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,270 @@
+/* Bit values & structures for resource limits.  Linux/MIPS version.
+   Copyright (C) 1994, 1996, 1997, 1998, 1999, 2000, 2004, 2005, 2006, 2008,
+   2009, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_RESOURCE_H
+# error "Never use <bits/resource.h> directly; include <sys/resource.h> instead."
+#endif
+
+#include <bits/types.h>
+
+/* Transmute defines to enumerations.  The macro re-definitions are
+   necessary because some programs want to test for operating system
+   features with #ifdef RUSAGE_SELF.  In ISO C the reflexive
+   definition is a no-op.  */
+
+/* Kinds of resource limit.  */
+enum __rlimit_resource
+{
+  /* Per-process CPU limit, in seconds.  */
+  RLIMIT_CPU = 0,
+#define RLIMIT_CPU RLIMIT_CPU
+
+  /* Largest file that can be created, in bytes.  */
+  RLIMIT_FSIZE = 1,
+#define	RLIMIT_FSIZE RLIMIT_FSIZE
+
+  /* Maximum size of data segment, in bytes.  */
+  RLIMIT_DATA = 2,
+#define	RLIMIT_DATA RLIMIT_DATA
+
+  /* Maximum size of stack segment, in bytes.  */
+  RLIMIT_STACK = 3,
+#define	RLIMIT_STACK RLIMIT_STACK
+
+  /* Largest core file that can be created, in bytes.  */
+  RLIMIT_CORE = 4,
+#define	RLIMIT_CORE RLIMIT_CORE
+
+  /* Largest resident set size, in bytes.
+     This affects swapping; processes that are exceeding their
+     resident set size will be more likely to have physical memory
+     taken from them.  */
+  __RLIMIT_RSS = 7,
+#define	RLIMIT_RSS __RLIMIT_RSS
+
+  /* Number of open files.  */
+  RLIMIT_NOFILE = 5,
+  __RLIMIT_OFILE = RLIMIT_NOFILE, /* BSD name for same.  */
+#define RLIMIT_NOFILE RLIMIT_NOFILE
+#define RLIMIT_OFILE __RLIMIT_OFILE
+
+  /* Address space limit (?) */
+  RLIMIT_AS = 6,
+#define RLIMIT_AS RLIMIT_AS
+
+  /* Number of processes.  */
+  __RLIMIT_NPROC = 8,
+#define RLIMIT_NPROC __RLIMIT_NPROC
+
+  /* Locked-in-memory address space.  */
+  __RLIMIT_MEMLOCK = 9,
+#define RLIMIT_MEMLOCK __RLIMIT_MEMLOCK
+
+  /* Maximum number of file locks.  */
+  __RLIMIT_LOCKS = 10,
+#define RLIMIT_LOCKS __RLIMIT_LOCKS
+
+  /* Maximum number of pending signals.  */
+  __RLIMIT_SIGPENDING = 11,
+#define RLIMIT_SIGPENDING __RLIMIT_SIGPENDING
+
+  /* Maximum bytes in POSIX message queues.  */
+  __RLIMIT_MSGQUEUE = 12,
+#define RLIMIT_MSGQUEUE __RLIMIT_MSGQUEUE
+
+  /* Maximum nice priority allowed to raise to.
+     Nice levels 19 .. -20 correspond to 0 .. 39
+     values of this resource limit.  */
+  __RLIMIT_NICE = 13,
+#define RLIMIT_NICE __RLIMIT_NICE
+
+  /* Maximum realtime priority allowed for non-priviledged
+     processes.  */
+  __RLIMIT_RTPRIO = 14,
+#define RLIMIT_RTPRIO __RLIMIT_RTPRIO
+
+  __RLIMIT_NLIMITS = 15,
+  __RLIM_NLIMITS = __RLIMIT_NLIMITS
+#define RLIMIT_NLIMITS __RLIMIT_NLIMITS
+#define RLIM_NLIMITS __RLIM_NLIMITS
+};
+
+/* Value to indicate that there is no limit.  */
+#if _RISCV_SIM == _ABI64
+/* The N64 syscall uses this value.  */
+# define RLIM_INFINITY 0xffffffffffffffffUL
+# ifdef __USE_LARGEFILE64
+#  define RLIM64_INFINITY 0xffffffffffffffffUL
+# endif
+#else
+/* The O32 and N32 syscalls use 0x7fffffff.  */
+# ifndef __USE_FILE_OFFSET64
+#  define RLIM_INFINITY ((long int)(~0UL >> 1))
+# else
+#  define RLIM_INFINITY 0x7fffffffffffffffULL
+# endif
+# ifdef __USE_LARGEFILE64
+#  define RLIM64_INFINITY 0x7fffffffffffffffULL
+# endif
+#endif
+
+/* We can represent all limits.  */
+#define RLIM_SAVED_MAX	RLIM_INFINITY
+#define RLIM_SAVED_CUR	RLIM_INFINITY
+
+
+/* Type for resource quantity measurement.  */
+#ifndef __USE_FILE_OFFSET64
+typedef __rlim_t rlim_t;
+#else
+typedef __rlim64_t rlim_t;
+#endif
+#ifdef __USE_LARGEFILE64
+typedef __rlim64_t rlim64_t;
+#endif
+
+struct rlimit
+  {
+    /* The current (soft) limit.  */
+    rlim_t rlim_cur;
+    /* The hard limit.  */
+    rlim_t rlim_max;
+  };
+
+#ifdef __USE_LARGEFILE64
+struct rlimit64
+  {
+    /* The current (soft) limit.  */
+    rlim64_t rlim_cur;
+    /* The hard limit.  */
+    rlim64_t rlim_max;
+ };
+#endif
+
+/* Whose usage statistics do you want?  */
+enum __rusage_who
+{
+  /* The calling process.  */
+  RUSAGE_SELF = 0,
+#define RUSAGE_SELF RUSAGE_SELF
+
+  /* All of its terminated child processes.  */
+  RUSAGE_CHILDREN = -1
+#define RUSAGE_CHILDREN RUSAGE_CHILDREN
+
+#ifdef __USE_GNU
+  ,
+  /* The calling thread.  */
+  RUSAGE_THREAD = 1
+# define RUSAGE_THREAD RUSAGE_THREAD
+  /* Name for the same functionality on Solaris.  */
+# define RUSAGE_LWP RUSAGE_THREAD
+#endif
+};
+
+#define __need_timeval
+#include <bits/time.h>		/* For `struct timeval'.  */
+
+/* Structure which says how much of each resource has been used.  */
+struct rusage
+  {
+    /* Total amount of user time used.  */
+    struct timeval ru_utime;
+    /* Total amount of system time used.  */
+    struct timeval ru_stime;
+    /* Maximum resident set size (in kilobytes).  */
+    long int ru_maxrss;
+    /* Amount of sharing of text segment memory
+       with other processes (kilobyte-seconds).  */
+    long int ru_ixrss;
+    /* Amount of data segment memory used (kilobyte-seconds).  */
+    long int ru_idrss;
+    /* Amount of stack memory used (kilobyte-seconds).  */
+    long int ru_isrss;
+    /* Number of soft page faults (i.e. those serviced by reclaiming
+       a page from the list of pages awaiting reallocation.  */
+    long int ru_minflt;
+    /* Number of hard page faults (i.e. those that required I/O).  */
+    long int ru_majflt;
+    /* Number of times a process was swapped out of physical memory.  */
+    long int ru_nswap;
+    /* Number of input operations via the file system.  Note: This
+       and `ru_oublock' do not include operations with the cache.  */
+    long int ru_inblock;
+    /* Number of output operations via the file system.  */
+    long int ru_oublock;
+    /* Number of IPC messages sent.  */
+    long int ru_msgsnd;
+    /* Number of IPC messages received.  */
+    long int ru_msgrcv;
+    /* Number of signals delivered.  */
+    long int ru_nsignals;
+    /* Number of voluntary context switches, i.e. because the process
+       gave up the process before it had to (usually to wait for some
+       resource to be available).  */
+    long int ru_nvcsw;
+    /* Number of involuntary context switches, i.e. a higher priority process
+       became runnable or the current process used up its time slice.  */
+    long int ru_nivcsw;
+  };
+
+/* Priority limits.  */
+#define PRIO_MIN	-20	/* Minimum priority a process can have.  */
+#define PRIO_MAX	20	/* Maximum priority a process can have.  */
+
+/* The type of the WHICH argument to `getpriority' and `setpriority',
+   indicating what flavor of entity the WHO argument specifies.  */
+enum __priority_which
+{
+  PRIO_PROCESS = 0,		/* WHO is a process ID.  */
+#define PRIO_PROCESS PRIO_PROCESS
+  PRIO_PGRP = 1,		/* WHO is a process group ID.  */
+#define PRIO_PGRP PRIO_PGRP
+  PRIO_USER = 2			/* WHO is a user ID.  */
+#define PRIO_USER PRIO_USER
+};
+
+
+__BEGIN_DECLS
+
+#ifdef __USE_GNU
+/* Modify and return resource limits of a process atomically.  */
+# ifndef __USE_FILE_OFFSET64
+extern int prlimit (__pid_t __pid, enum __rlimit_resource __resource,
+		    __const struct rlimit *__new_limit,
+		    struct rlimit *__old_limit) __THROW;
+# else
+#  ifdef __REDIRECT_NTH
+extern int __REDIRECT_NTH (prlimit, (__pid_t __pid,
+				     enum __rlimit_resource __resource,
+				     __const struct rlimit *__new_limit,
+				     struct rlimit *__old_limit), prlimit64);
+#  else
+#   define prlimit prlimit64
+#  endif
+# endif
+# ifdef __USE_LARGEFILE64
+extern int prlimit64 (__pid_t __pid, enum __rlimit_resource __resource,
+		      __const struct rlimit64 *__new_limit,
+		      struct rlimit64 *__old_limit) __THROW;
+# endif
+#endif
+
+__END_DECLS
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/bits/sem.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/sem.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/bits/sem.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/sem.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,85 @@
+/* Copyright (C) 1995, 1996, 1997, 1998, 2000, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_SEM_H
+# error "Never include <bits/sem.h> directly; use <sys/sem.h> instead."
+#endif
+
+#include <sys/types.h>
+
+/* Flags for `semop'.  */
+#define SEM_UNDO	0x1000		/* undo the operation on exit */
+
+/* Commands for `semctl'.  */
+#define GETPID		11		/* get sempid */
+#define GETVAL		12		/* get semval */
+#define GETALL		13		/* get all semval's */
+#define GETNCNT		14		/* get semncnt */
+#define GETZCNT		15		/* get semzcnt */
+#define SETVAL		16		/* set semval */
+#define SETALL		17		/* set all semval's */
+
+
+/* Data structure describing a set of semaphores.  */
+struct semid_ds
+{
+  struct ipc_perm sem_perm;		/* operation permission struct */
+  __time_t sem_otime;			/* last semop() time */
+  __time_t sem_ctime;			/* last time changed by semctl() */
+  unsigned long int sem_nsems;		/* number of semaphores in set */
+  unsigned long int __unused1;
+  unsigned long int __unused2;
+};
+
+/* The user should define a union like the following to use it for arguments
+   for `semctl'.
+
+   union semun
+   {
+     int val;				<= value for SETVAL
+     struct semid_ds *buf;		<= buffer for IPC_STAT & IPC_SET
+     unsigned short int *array;		<= array for GETALL & SETALL
+     struct seminfo *__buf;		<= buffer for IPC_INFO
+   };
+
+   Previous versions of this file used to define this union but this is
+   incorrect.  One can test the macro _SEM_SEMUN_UNDEFINED to see whether
+   one must define the union or not.  */
+#define _SEM_SEMUN_UNDEFINED	1
+
+#ifdef __USE_MISC
+
+/* ipcs ctl cmds */
+# define SEM_STAT 18
+# define SEM_INFO 19
+
+struct  seminfo
+{
+  int semmap;
+  int semmni;
+  int semmns;
+  int semmnu;
+  int semmsl;
+  int semopm;
+  int semume;
+  int semusz;
+  int semvmx;
+  int semaem;
+};
+
+#endif /* __USE_MISC */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/bits/shm.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/shm.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/bits/shm.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/shm.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,95 @@
+/* Copyright (C) 1995,1996,1997,2000,2001,2002,2003,2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_SHM_H
+# error "Never include <bits/shm.h> directly; use <sys/shm.h> instead."
+#endif
+
+#include <bits/types.h>
+
+/* Permission flag for shmget.  */
+#define SHM_R		0400		/* or S_IRUGO from <linux/stat.h> */
+#define SHM_W		0200		/* or S_IWUGO from <linux/stat.h> */
+
+/* Flags for `shmat'.  */
+#define SHM_RDONLY	010000		/* attach read-only else read-write */
+#define SHM_RND		020000		/* round attach address to SHMLBA */
+#define SHM_REMAP	040000		/* take-over region on attach */
+#define SHM_EXEC	0100000		/* execution access */
+
+/* Commands for `shmctl'.  */
+#define SHM_LOCK	11		/* lock segment (root only) */
+#define SHM_UNLOCK	12		/* unlock segment (root only) */
+
+/* Segment low boundary address multiple.  */
+#define SHMLBA		0x40000
+
+
+/* Type to count number of attaches.  */
+typedef unsigned long int shmatt_t;
+
+/* Data structure describing a shared memory segment.  */
+struct shmid_ds
+  {
+    struct ipc_perm shm_perm;		/* operation permission struct */
+    size_t shm_segsz;			/* size of segment in bytes */
+    __time_t shm_atime;			/* time of last shmat() */
+    __time_t shm_dtime;			/* time of last shmdt() */
+    __time_t shm_ctime;			/* time of last change by shmctl() */
+    __pid_t shm_cpid;			/* pid of creator */
+    __pid_t shm_lpid;			/* pid of last shmop */
+    shmatt_t shm_nattch;		/* number of current attaches */
+    unsigned long int __unused1;
+    unsigned long int __unused2;
+  };
+
+#ifdef __USE_MISC
+
+/* ipcs ctl commands */
+# define SHM_STAT	13
+# define SHM_INFO	14
+
+/* shm_mode upper byte flags */
+# define SHM_DEST	01000	/* segment will be destroyed on last detach */
+# define SHM_LOCKED	02000   /* segment will not be swapped */
+# define SHM_HUGETLB	04000	/* segment is mapped via hugetlb */
+
+struct shminfo
+  {
+    unsigned long int shmmax;
+    unsigned long int shmmin;
+    unsigned long int shmmni;
+    unsigned long int shmseg;
+    unsigned long int shmall;
+    unsigned long int __unused1;
+    unsigned long int __unused2;
+    unsigned long int __unused3;
+    unsigned long int __unused4;
+  };
+
+struct shm_info
+  {
+    int used_ids;
+    unsigned long int shm_tot;  /* total allocated shm */
+    unsigned long int shm_rss;  /* total resident shm */
+    unsigned long int shm_swp;  /* total swapped shm */
+    unsigned long int swap_attempts;
+    unsigned long int swap_successes;
+  };
+
+#endif /* __USE_MISC */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/bits/sigaction.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/sigaction.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/bits/sigaction.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/sigaction.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,91 @@
+/* The proper definitions for Linux/MIPS's sigaction.
+   Copyright (C) 1993, 1994, 1995, 1997, 1998, 1999, 2000, 2003, 2010
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SIGNAL_H
+# error "Never include <bits/sigaction.h> directly; use <signal.h> instead."
+#endif
+
+/* Structure describing the action to be taken when a signal arrives.  */
+struct sigaction
+  {
+    /* Special flags.  */
+    unsigned int sa_flags;
+
+    /* Signal handler.  */
+#ifdef __USE_POSIX199309
+    union
+      {
+	/* Used if SA_SIGINFO is not set.  */
+	__sighandler_t sa_handler;
+	/* Used if SA_SIGINFO is set.  */
+	void (*sa_sigaction) (int, siginfo_t *, void *);
+      }
+    __sigaction_handler;
+# define sa_handler    __sigaction_handler.sa_handler
+# define sa_sigaction  __sigaction_handler.sa_sigaction
+#else
+    __sighandler_t sa_handler;
+#endif
+    /* Additional set of signals to be blocked.  */
+    __sigset_t sa_mask;
+
+    /* The ABI says here are two unused ints following. */
+    /* Restore handler.  */
+    void (*sa_restorer) (void);
+
+#if _RISCV_SZPTR < 64
+    int sa_resv[1];
+#endif
+  };
+
+/* Bits in `sa_flags'.  */
+/* Please note that some Linux kernels versions use different values for these
+   flags which is a bug in those kernel versions.  */
+#define SA_NOCLDSTOP  0x00000001 /* Don't send SIGCHLD when children stop.  */
+#define SA_NOCLDWAIT  0x00010000 /* Don't create zombie on child death.  */
+#define SA_SIGINFO    0x00000008 /* Invoke signal-catching function with
+				    three arguments instead of one.  */
+#if defined __USE_UNIX98 || defined __USE_MISC
+# define SA_ONSTACK   0x08000000 /* Use signal stack by using `sa_restorer'. */
+#endif
+#if defined __USE_UNIX98 || defined __USE_MISC || defined __USE_XOPEN2K8
+# define SA_RESETHAND 0x80000000 /* Reset to SIG_DFL on entry to handler.  */
+# define SA_RESTART   0x10000000 /* Restart syscall on signal return.  */
+# define SA_NODEFER   0x40000000 /* Don't automatically block the signal when
+				    its handler is being executed.  */
+#endif
+#ifdef __USE_MISC
+# define SA_INTERRUPT 0x20000000 /* Historical no-op.  */
+
+/* Some aliases for the SA_ constants.  */
+# define SA_NOMASK    SA_NODEFER
+# define SA_ONESHOT   SA_RESETHAND
+# define SA_STACK     SA_ONSTACK
+#endif
+
+/* Values for the HOW argument to `sigprocmask'.  */
+#define SIG_NOP	      0		/* 0 is unused to catch errors */
+#define	SIG_BLOCK     1		/* Block signals.  */
+#define	SIG_UNBLOCK   2		/* Unblock signals.  */
+#define	SIG_SETMASK   3		/* Set the set of blocked signals.  */
+#ifdef __USE_MISC
+# define SIG_SETMASK32 256	/* Goodie from SGI for BSD compatibility:
+				   set only the low 32 bit of the sigset.  */
+#endif
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/bits/sigcontext.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/sigcontext.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/bits/sigcontext.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/sigcontext.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,84 @@
+/* Copyright (C) 1996, 1997, 1998, 2003, 2004, 2006 Free Software
+   Foundation, Inc.  This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_SIGCONTEXT_H
+#define _BITS_SIGCONTEXT_H 1
+
+#if !defined _SIGNAL_H && !defined _SYS_UCONTEXT_H
+# error "Never use <bits/sigcontext.h> directly; include <signal.h> instead."
+#endif
+
+#include <sgidefs.h>
+
+#if _RISCV_SIM == _ABIO32
+
+/* Certain unused fields were replaced with new ones in 2.6.12-rc4.
+   The changes were as follows:
+
+   sc_cause -> sc_hi1
+   sc_badvaddr -> sc_lo1
+   sc_sigset[0] -> sc_hi2
+   sc_sigset[1] -> sc_lo2
+   sc_sigset[2] -> sc_hi3
+   sc_sigset[3] -> sc_lo3
+
+   sc_regmask, sc_ownedfp and sc_fpc_eir are not used.  */
+struct sigcontext {
+  unsigned int sc_regmask;
+  unsigned int sc_status;
+  unsigned long long sc_pc;
+  unsigned long long sc_regs[32];
+  unsigned long long sc_fpregs[32];
+  unsigned int sc_ownedfp;
+  unsigned int sc_fpc_csr;
+  unsigned int sc_fpc_eir;
+  unsigned int sc_used_math;
+  unsigned int sc_dsp;
+  unsigned long long sc_mdhi;
+  unsigned long long sc_mdlo;
+  unsigned long sc_hi1;
+  unsigned long sc_lo1;
+  unsigned long sc_hi2;
+  unsigned long sc_lo2;
+  unsigned long sc_hi3;
+  unsigned long sc_lo3;
+};
+
+#else
+
+/* This structure changed in 2.6.12-rc4 when DSP support was added.  */
+struct sigcontext {
+  unsigned long long sc_regs[32];
+  unsigned long long sc_fpregs[32];
+  unsigned long long sc_mdhi;
+  unsigned long long sc_hi1;
+  unsigned long long sc_hi2;
+  unsigned long long sc_hi3;
+  unsigned long long sc_mdlo;
+  unsigned long long sc_lo1;
+  unsigned long long sc_lo2;
+  unsigned long long sc_lo3;
+  unsigned long long sc_pc;
+  unsigned int sc_fpc_csr;
+  unsigned int sc_used_math;
+  unsigned int sc_dsp;
+  unsigned int sc_reserved;
+};
+
+#endif /* _RISCV_SIM != _ABIO32 */
+#endif
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/bits/siginfo.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/siginfo.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/bits/siginfo.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/siginfo.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,319 @@
+/* siginfo_t, sigevent and constants.  Linux/MIPS version.
+   Copyright (C) 1997, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2008
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SIGNAL_H && !defined __need_siginfo_t \
+    && !defined __need_sigevent_t
+# error "Never include this file directly.  Use <signal.h> instead"
+#endif
+
+#include <bits/wordsize.h>
+
+#define HAVE_PSIGNAL
+
+#if (!defined __have_sigval_t \
+     && (defined _SIGNAL_H || defined __need_siginfo_t \
+	 || defined __need_sigevent_t))
+# define __have_sigval_t	1
+
+/* Type for data associated with a signal.  */
+typedef union sigval
+  {
+    int sival_int;
+    void *sival_ptr;
+  } sigval_t;
+#endif
+
+#if (!defined __have_siginfo_t \
+     && (defined _SIGNAL_H || defined __need_siginfo_t))
+# define __have_siginfo_t	1
+
+# define __SI_MAX_SIZE		128
+# if __WORDSIZE == 64
+#  define __SI_PAD_SIZE		((__SI_MAX_SIZE / sizeof (int)) - 4)
+# else
+#  define __SI_PAD_SIZE		((__SI_MAX_SIZE / sizeof (int)) - 3)
+# endif
+
+
+typedef struct siginfo
+  {
+    int si_signo;		/* Signal number.  */
+    int si_code;		/* Signal code.  */
+    int si_errno;		/* If non-zero, an errno value associated with
+				   this signal, as defined in <errno.h>.  */
+    int __pad0[__SI_MAX_SIZE / sizeof (int) - __SI_PAD_SIZE - 3];
+				/* Explicit padding.  */
+
+    union
+      {
+	int _pad[__SI_PAD_SIZE];
+
+	 /* kill().  */
+	struct
+	  {
+	    __pid_t si_pid;	/* Sending process ID.  */
+	    __uid_t si_uid;	/* Real user ID of sending process.  */
+	  } _kill;
+
+	/* POSIX.1b timers.  */
+	struct
+	  {
+	    int si_tid;		/* Timer ID.  */
+	    int si_overrun;	/* Overrun count.  */
+	    sigval_t si_sigval;	/* Signal value.  */
+	  } _timer;
+
+	/* POSIX.1b signals.  */
+	struct
+	  {
+	    __pid_t si_pid;	/* Sending process ID.  */
+	    __uid_t si_uid;	/* Real user ID of sending process.  */
+	    sigval_t si_sigval;	/* Signal value.  */
+	  } _rt;
+
+	/* SIGCHLD.  */
+	struct
+	  {
+	    __pid_t si_pid;	/* Which child.  */
+	    __uid_t si_uid;	/* Real user ID of sending process.  */
+	    int si_status;	/* Exit value or signal.  */
+	    __clock_t si_utime;
+	    __clock_t si_stime;
+	  } _sigchld;
+
+	/* SIGILL, SIGFPE, SIGSEGV, SIGBUS.  */
+	struct
+	  {
+	    void *si_addr;	/* Faulting insn/memory ref.  */
+	  } _sigfault;
+
+	/* SIGPOLL.  */
+	struct
+	  {
+	    long int si_band;	/* Band event for SIGPOLL.  */
+	    int si_fd;
+	  } _sigpoll;
+      } _sifields;
+  } siginfo_t;
+
+
+/* X/Open requires some more fields with fixed names.  */
+# define si_pid		_sifields._kill.si_pid
+# define si_uid		_sifields._kill.si_uid
+# define si_timerid	_sifields._timer.si_tid
+# define si_overrun	_sifields._timer.si_overrun
+# define si_status	_sifields._sigchld.si_status
+# define si_utime	_sifields._sigchld.si_utime
+# define si_stime	_sifields._sigchld.si_stime
+# define si_value	_sifields._rt.si_sigval
+# define si_int		_sifields._rt.si_sigval.sival_int
+# define si_ptr		_sifields._rt.si_sigval.sival_ptr
+# define si_addr	_sifields._sigfault.si_addr
+# define si_band	_sifields._sigpoll.si_band
+# define si_fd		_sifields._sigpoll.si_fd
+
+
+/* Values for `si_code'.  Positive values are reserved for kernel-generated
+   signals.  */
+enum
+{
+  SI_ASYNCNL = -60,		/* Sent by asynch name lookup completion.  */
+# define SI_ASYNCNL	SI_ASYNCNL
+  SI_TKILL = -6,		/* Sent by tkill.  */
+# define SI_TKILL	SI_TKILL
+  SI_SIGIO,			/* Sent by queued SIGIO.  */
+# define SI_SIGIO	SI_SIGIO
+  SI_MESGQ,			/* Sent by real time mesq state change.  */
+# define SI_MESGQ	SI_MESGQ
+  SI_TIMER,			/* Sent by real time mesq state change.  */
+# define SI_TIMER	SI_TIMER
+  SI_ASYNCIO,			/* Sent by AIO completion.  */
+# define SI_ASYNCIO	SI_ASYNCIO
+  SI_QUEUE,			/* Sent by sigqueue.  */
+# define SI_QUEUE	SI_QUEUE
+  SI_USER,			/* Sent by kill, sigsend, raise.  */
+# define SI_USER	SI_USER
+  SI_KERNEL = 0x80		/* Send by kernel.  */
+#define SI_KERNEL	SI_KERNEL
+};
+
+
+/* `si_code' values for SIGILL signal.  */
+enum
+{
+  ILL_ILLOPC = 1,		/* Illegal opcode.  */
+# define ILL_ILLOPC	ILL_ILLOPC
+  ILL_ILLOPN,			/* Illegal operand.  */
+# define ILL_ILLOPN	ILL_ILLOPN
+  ILL_ILLADR,			/* Illegal addressing mode.  */
+# define ILL_ILLADR	ILL_ILLADR
+  ILL_ILLTRP,			/* Illegal trap.  */
+# define ILL_ILLTRP	ILL_ILLTRP
+  ILL_PRVOPC,			/* Privileged opcode.  */
+# define ILL_PRVOPC	ILL_PRVOPC
+  ILL_PRVREG,			/* Privileged register.  */
+# define ILL_PRVREG	ILL_PRVREG
+  ILL_COPROC,			/* Coprocessor error.  */
+# define ILL_COPROC	ILL_COPROC
+  ILL_BADSTK			/* Internal stack error.  */
+# define ILL_BADSTK	ILL_BADSTK
+};
+
+/* `si_code' values for SIGFPE signal.  */
+enum
+{
+  FPE_INTDIV = 1,		/* Integer divide by zero.  */
+# define FPE_INTDIV	FPE_INTDIV
+  FPE_INTOVF,			/* Integer overflow.  */
+# define FPE_INTOVF	FPE_INTOVF
+  FPE_FLTDIV,			/* Floating point divide by zero.  */
+# define FPE_FLTDIV	FPE_FLTDIV
+  FPE_FLTOVF,			/* Floating point overflow.  */
+# define FPE_FLTOVF	FPE_FLTOVF
+  FPE_FLTUND,			/* Floating point underflow.  */
+# define FPE_FLTUND	FPE_FLTUND
+  FPE_FLTRES,			/* Floating point inexact result.  */
+# define FPE_FLTRES	FPE_FLTRES
+  FPE_FLTINV,			/* Floating point invalid operation.  */
+# define FPE_FLTINV	FPE_FLTINV
+  FPE_FLTSUB			/* Subscript out of range.  */
+# define FPE_FLTSUB	FPE_FLTSUB
+};
+
+/* `si_code' values for SIGSEGV signal.  */
+enum
+{
+  SEGV_MAPERR = 1,		/* Address not mapped to object.  */
+# define SEGV_MAPERR	SEGV_MAPERR
+  SEGV_ACCERR			/* Invalid permissions for mapped object.  */
+# define SEGV_ACCERR	SEGV_ACCERR
+};
+
+/* `si_code' values for SIGBUS signal.  */
+enum
+{
+  BUS_ADRALN = 1,		/* Invalid address alignment.  */
+# define BUS_ADRALN	BUS_ADRALN
+  BUS_ADRERR,			/* Non-existant physical address.  */
+# define BUS_ADRERR	BUS_ADRERR
+  BUS_OBJERR			/* Object specific hardware error.  */
+# define BUS_OBJERR	BUS_OBJERR
+};
+
+/* `si_code' values for SIGTRAP signal.  */
+enum
+{
+  TRAP_BRKPT = 1,		/* Process breakpoint.  */
+# define TRAP_BRKPT	TRAP_BRKPT
+  TRAP_TRACE			/* Process trace trap.  */
+# define TRAP_TRACE	TRAP_TRACE
+};
+
+/* `si_code' values for SIGCHLD signal.  */
+enum
+{
+  CLD_EXITED = 1,		/* Child has exited.  */
+# define CLD_EXITED	CLD_EXITED
+  CLD_KILLED,			/* Child was killed.  */
+# define CLD_KILLED	CLD_KILLED
+  CLD_DUMPED,			/* Child terminated abnormally.  */
+# define CLD_DUMPED	CLD_DUMPED
+  CLD_TRAPPED,			/* Traced child has trapped.  */
+# define CLD_TRAPPED	CLD_TRAPPED
+  CLD_STOPPED,			/* Child has stopped.  */
+# define CLD_STOPPED	CLD_STOPPED
+  CLD_CONTINUED			/* Stopped child has continued.  */
+# define CLD_CONTINUED	CLD_CONTINUED
+};
+
+/* `si_code' values for SIGPOLL signal.  */
+enum
+{
+  POLL_IN = 1,			/* Data input available.  */
+# define POLL_IN	POLL_IN
+  POLL_OUT,			/* Output buffers available.  */
+# define POLL_OUT	POLL_OUT
+  POLL_MSG,			/* Input message available.   */
+# define POLL_MSG	POLL_MSG
+  POLL_ERR,			/* I/O error.  */
+# define POLL_ERR	POLL_ERR
+  POLL_PRI,			/* High priority input available.  */
+# define POLL_PRI	POLL_PRI
+  POLL_HUP			/* Device disconnected.  */
+# define POLL_HUP	POLL_HUP
+};
+
+# undef __need_siginfo_t
+#endif	/* !have siginfo_t && (have _SIGNAL_H || need siginfo_t).  */
+
+
+#if (defined _SIGNAL_H || defined __need_sigevent_t) \
+    && !defined __have_sigevent_t
+# define __have_sigevent_t	1
+
+/* Structure to transport application-defined values with signals.  */
+# define __SIGEV_MAX_SIZE	64
+# if __WORDSIZE == 64
+#  define __SIGEV_PAD_SIZE	((__SIGEV_MAX_SIZE / sizeof (int)) - 4)
+# else
+#  define __SIGEV_PAD_SIZE	((__SIGEV_MAX_SIZE / sizeof (int)) - 3)
+# endif
+
+typedef struct sigevent
+  {
+    sigval_t sigev_value;
+    int sigev_signo;
+    int sigev_notify;
+
+    union
+      {
+	int _pad[__SIGEV_PAD_SIZE];
+
+	/* When SIGEV_SIGNAL and SIGEV_THREAD_ID set, LWP ID of the
+	   thread to receive the signal.  */
+	__pid_t _tid;
+
+	struct
+	  {
+	    void (*_function) (sigval_t);	/* Function to start.  */
+	    void *_attribute;			/* Really pthread_attr_t.  */
+	  } _sigev_thread;
+      } _sigev_un;
+  } sigevent_t;
+
+/* POSIX names to access some of the members.  */
+# define sigev_notify_function   _sigev_un._sigev_thread._function
+# define sigev_notify_attributes _sigev_un._sigev_thread._attribute
+
+/* `sigev_notify' values.  */
+enum
+{
+  SIGEV_SIGNAL = 0,		/* Notify via signal.  */
+# define SIGEV_SIGNAL	SIGEV_SIGNAL
+  SIGEV_NONE,			/* Other notification: meaningless.  */
+# define SIGEV_NONE	SIGEV_NONE
+  SIGEV_THREAD,			/* Deliver via thread creation.  */
+# define SIGEV_THREAD	SIGEV_THREAD
+
+  SIGEV_THREAD_ID = 4		/* Send signal to specific thread.  */
+#define SIGEV_THREAD_ID	SIGEV_THREAD_ID
+};
+
+#endif	/* have _SIGNAL_H.  */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/bits/signum.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/signum.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/bits/signum.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/signum.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,79 @@
+/* Signal number definitions.  Linux version.
+   Copyright (C) 1995, 1997, 1998 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifdef	_SIGNAL_H
+
+/* Fake signal functions.  */
+#define SIG_ERR ((__sighandler_t) -1)		/* Error return.  */
+#define SIG_DFL ((__sighandler_t) 0)		/* Default action.  */
+#define SIG_IGN ((__sighandler_t) 1)		/* Ignore signal.  */
+
+#ifdef __USE_UNIX98
+# define SIG_HOLD	((__sighandler_t) 2)	/* Add signal to hold mask.  */
+#endif
+
+
+#define SIGHUP		 1	/* Hangup (POSIX).  */
+#define SIGINT		 2	/* Interrupt (ANSI).  */
+#define SIGQUIT		 3	/* Quit (POSIX).  */
+#define SIGILL		 4	/* Illegal instruction (ANSI).  */
+#define SIGTRAP		 5	/* Trace trap (POSIX).  */
+#define SIGIOT		 6	/* IOT trap (4.2 BSD).  */
+#define SIGABRT		 SIGIOT	/* Abort (ANSI).  */
+#define SIGEMT		 7
+#define SIGFPE		 8	/* Floating-point exception (ANSI).  */
+#define SIGKILL		 9	/* Kill, unblockable (POSIX).  */
+#define SIGBUS		10	/* BUS error (4.2 BSD).  */
+#define SIGSEGV		11	/* Segmentation violation (ANSI).  */
+#define SIGSYS		12
+#define SIGPIPE		13	/* Broken pipe (POSIX).  */
+#define SIGALRM		14	/* Alarm clock (POSIX).  */
+#define SIGTERM		15	/* Termination (ANSI).  */
+#define SIGUSR1		16	/* User-defined signal 1 (POSIX).  */
+#define SIGUSR2		17	/* User-defined signal 2 (POSIX).  */
+#define SIGCHLD		18	/* Child status has changed (POSIX).  */
+#define SIGCLD		SIGCHLD	/* Same as SIGCHLD (System V).  */
+#define SIGPWR		19	/* Power failure restart (System V).  */
+#define SIGWINCH	20	/* Window size change (4.3 BSD, Sun).  */
+#define SIGURG		21	/* Urgent condition on socket (4.2 BSD).  */
+#define SIGIO		22	/* I/O now possible (4.2 BSD).  */
+#define SIGPOLL		SIGIO	/* Pollable event occurred (System V).  */
+#define SIGSTOP		23	/* Stop, unblockable (POSIX).  */
+#define SIGTSTP		24	/* Keyboard stop (POSIX).  */
+#define SIGCONT		25	/* Continue (POSIX).  */
+#define SIGTTIN		26	/* Background read from tty (POSIX).  */
+#define SIGTTOU		27	/* Background write to tty (POSIX).  */
+#define SIGVTALRM	28	/* Virtual alarm clock (4.2 BSD).  */
+#define SIGPROF		29	/* Profiling alarm clock (4.2 BSD).  */
+#define SIGXCPU		30	/* CPU limit exceeded (4.2 BSD).  */
+#define SIGXFSZ		31	/* File size limit exceeded (4.2 BSD).  */
+
+
+#define _NSIG		128	/* Biggest signal number + 1
+				   (including real-time signals).  */
+
+#define SIGRTMIN	(__libc_current_sigrtmin ())
+#define SIGRTMAX	(__libc_current_sigrtmax ())
+
+/* These are the hard limits of the kernel.  These values should not be
+   used directly at user level.  */
+#define __SIGRTMIN	32
+#define __SIGRTMAX	(_NSIG - 1)
+
+#endif	/* <signal.h> included.  */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/bits/sigstack.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/sigstack.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/bits/sigstack.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/sigstack.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,55 @@
+/* sigstack, sigaltstack definitions.
+   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SIGNAL_H
+# error "Never include this file directly.  Use <signal.h> instead"
+#endif
+
+
+/* Structure describing a signal stack (obsolete).  */
+struct sigstack
+  {
+    void *ss_sp;		/* Signal stack pointer.  */
+    int ss_onstack;		/* Nonzero if executing on this stack.  */
+  };
+
+
+/* Possible values for `ss_flags.'.  */
+enum
+{
+  SS_ONSTACK = 1,
+#define SS_ONSTACK	SS_ONSTACK
+  SS_DISABLE
+#define SS_DISABLE	SS_DISABLE
+};
+
+/* Minimum stack size for a signal handler.  */
+#define MINSIGSTKSZ	2048
+
+/* System default stack size.  */
+#define SIGSTKSZ	8192
+
+
+/* Alternate, preferred interface.  */
+typedef struct sigaltstack
+  {
+    void *ss_sp;
+    size_t ss_size;
+    int ss_flags;
+  } stack_t;
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/bits/statfs.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/statfs.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/bits/statfs.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/statfs.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,74 @@
+/* Copyright (C) 1997, 2000, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_STATFS_H
+# error "Never include <bits/statfs.h> directly; use <sys/statfs.h> instead."
+#endif
+
+#include <bits/types.h>  /* for __fsid_t and __fsblkcnt_t*/
+
+struct statfs
+  {
+    long int f_type;
+#define f_fstyp f_type
+    long int f_bsize;
+    long int f_frsize;	/* Fragment size - unsupported */
+#ifndef __USE_FILE_OFFSET64
+    __fsblkcnt_t f_blocks;
+    __fsblkcnt_t f_bfree;
+    __fsblkcnt_t f_files;
+    __fsblkcnt_t f_ffree;
+    __fsblkcnt_t f_bavail;
+#else
+    __fsblkcnt64_t f_blocks;
+    __fsblkcnt64_t f_bfree;
+    __fsblkcnt64_t f_files;
+    __fsblkcnt64_t f_ffree;
+    __fsblkcnt64_t f_bavail;
+#endif
+
+	/* Linux specials */
+    __fsid_t f_fsid;
+    long int f_namelen;
+    long int f_flags;
+    long int f_spare[5];
+  };
+
+#ifdef __USE_LARGEFILE64
+struct statfs64
+  {
+    long int f_type;
+#define f_fstyp f_type
+    long int f_bsize;
+    long int f_frsize;	/* Fragment size - unsupported */
+    __fsblkcnt64_t f_blocks;
+    __fsblkcnt64_t f_bfree;
+    __fsblkcnt64_t f_files;
+    __fsblkcnt64_t f_ffree;
+    __fsblkcnt64_t f_bavail;
+
+	/* Linux specials */
+    __fsid_t f_fsid;
+    long int f_namelen;
+    long int f_flags;
+    long int f_spare[5];
+  };
+#endif
+
+/* Tell code we have these members.  */
+#define _STATFS_F_NAMELEN
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/bits/stat.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/stat.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/bits/stat.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/stat.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,265 @@
+/* Copyright (C) 1992, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004,
+	2007, 2009, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SYS_STAT_H && !defined _FCNTL_H
+# error "Never include <bits/stat.h> directly; use <sys/stat.h> instead."
+#endif
+
+#ifndef _BITS_STAT_H
+#define _BITS_STAT_H	1
+
+#include <sgidefs.h>
+
+/* Versions of the `struct stat' data structure.  */
+#define _STAT_VER_LINUX_OLD	1
+#define _STAT_VER_KERNEL	1
+#define _STAT_VER_SVR4		2
+#define _STAT_VER_LINUX		3
+#define _STAT_VER		_STAT_VER_LINUX /* The one defined below.  */
+
+/* Versions of the `xmknod' interface.  */
+#define _MKNOD_VER_LINUX	1
+#define _MKNOD_VER_SVR4		2
+#define _MKNOD_VER		_MKNOD_VER_LINUX /* The bits defined below.  */
+
+
+#if _RISCV_SIM == _ABIO32
+/* Structure describing file characteristics.  */
+struct stat
+  {
+    unsigned long int st_dev;
+    long int st_pad1[3];
+#ifndef __USE_FILE_OFFSET64
+    __ino_t st_ino;		/* File serial number.		*/
+#else
+    __ino64_t st_ino;		/* File serial number.		*/
+#endif
+    __mode_t st_mode;		/* File mode.  */
+    __nlink_t st_nlink;		/* Link count.  */
+    __uid_t st_uid;		/* User ID of the file's owner.	*/
+    __gid_t st_gid;		/* Group ID of the file's group.*/
+    unsigned long int st_rdev;	/* Device number, if device.  */
+#ifndef __USE_FILE_OFFSET64
+    long int st_pad2[2];
+    __off_t st_size;		/* Size of file, in bytes.  */
+    /* SVR4 added this extra long to allow for expansion of off_t.  */
+    long int st_pad3;
+#else
+    long int st_pad2[3];
+    __off64_t st_size;		/* Size of file, in bytes.  */
+#endif
+#if defined __USE_MISC || defined __USE_XOPEN2K8
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;            /* Time of last access.  */
+    struct timespec st_mtim;            /* Time of last modification.  */
+    struct timespec st_ctim;            /* Time of last status change.  */
+# define st_atime st_atim.tv_sec        /* Backward compatibility.  */
+# define st_mtime st_mtim.tv_sec
+# define st_ctime st_ctim.tv_sec
+#else
+    __time_t st_atime;		/* Time of last access.  */
+    long int __reserved0;
+    __time_t st_mtime;		/* Time of last modification.  */
+    long int __reserved1;
+    __time_t st_ctime;		/* Time of last status change.  */
+    long int __reserved2;
+#endif
+    __blksize_t st_blksize;	/* Optimal block size for I/O.  */
+#ifndef __USE_FILE_OFFSET64
+    __blkcnt_t st_blocks;	/* Number of 512-byte blocks allocated.  */
+#else
+    long int st_pad4;
+    __blkcnt64_t st_blocks;	/* Number of 512-byte blocks allocated.  */
+#endif
+    long int st_pad5[14];
+  };
+
+#ifdef __USE_LARGEFILE64
+struct stat64
+  {
+    unsigned long int st_dev;
+    long int st_pad1[3];
+    __ino64_t st_ino;		/* File serial number.		*/
+    __mode_t st_mode;		/* File mode.  */
+    __nlink_t st_nlink;		/* Link count.  */
+    __uid_t st_uid;		/* User ID of the file's owner.	*/
+    __gid_t st_gid;		/* Group ID of the file's group.*/
+    unsigned long int st_rdev;	/* Device number, if device.  */
+    long int st_pad2[3];
+    __off64_t st_size;		/* Size of file, in bytes.  */
+# if defined __USE_MISC || defined __USE_XOPEN2K8
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;            /* Time of last access.  */
+    struct timespec st_mtim;            /* Time of last modification.  */
+    struct timespec st_ctim;            /* Time of last status change.  */
+# else
+    __time_t st_atime;		/* Time of last access.  */
+    long int __reserved0;
+    __time_t st_mtime;		/* Time of last modification.  */
+    long int __reserved1;
+    __time_t st_ctime;		/* Time of last status change.  */
+    long int __reserved2;
+# endif
+    __blksize_t st_blksize;	/* Optimal block size for I/O.  */
+    long int st_pad3;
+    __blkcnt64_t st_blocks;	/* Number of 512-byte blocks allocated.  */
+    long int st_pad4[14];
+  };
+#endif
+#else
+struct stat
+  {
+    __dev_t st_dev;
+    int	st_pad1[3];		/* Reserved for st_dev expansion  */
+#ifndef __USE_FILE_OFFSET64
+    __ino_t st_ino;
+#else
+    __ino64_t st_ino;
+#endif
+    __mode_t st_mode;
+    __nlink_t st_nlink;
+    __uid_t st_uid;
+    __gid_t st_gid;
+    __dev_t st_rdev;
+#if !defined __USE_FILE_OFFSET64
+    unsigned int st_pad2[2];	/* Reserved for st_rdev expansion  */
+    __off_t st_size;
+    int st_pad3;
+#else
+    unsigned int st_pad2[3];	/* Reserved for st_rdev expansion  */
+    __off64_t st_size;
+#endif
+#if defined __USE_MISC || defined __USE_XOPEN2K8
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;            /* Time of last access.  */
+    struct timespec st_mtim;            /* Time of last modification.  */
+    struct timespec st_ctim;            /* Time of last status change.  */
+# define st_atime st_atim.tv_sec        /* Backward compatibility.  */
+# define st_mtime st_mtim.tv_sec
+# define st_ctime st_ctim.tv_sec
+#else
+    __time_t st_atime;
+    int __reserved0;
+    __time_t st_mtime;
+    int __reserved1;
+    __time_t st_ctime;
+    int __reserved2;
+#endif
+    __blksize_t st_blksize;
+    unsigned int st_pad4;
+#ifndef __USE_FILE_OFFSET64
+    __blkcnt_t st_blocks;
+#else
+    __blkcnt64_t st_blocks;
+#endif
+    int st_pad5[14];
+  };
+
+#ifdef __USE_LARGEFILE64
+struct stat64
+  {
+    __dev_t st_dev;
+    unsigned int st_pad1[3];	/* Reserved for st_dev expansion  */
+    __ino64_t st_ino;
+    __mode_t st_mode;
+    __nlink_t st_nlink;
+    __uid_t st_uid;
+    __gid_t st_gid;
+    __dev_t st_rdev;
+    unsigned int st_pad2[3];	/* Reserved for st_rdev expansion  */
+    __off64_t st_size;
+# if defined __USE_MISC || defined __USE_XOPEN2K8
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;            /* Time of last access.  */
+    struct timespec st_mtim;            /* Time of last modification.  */
+    struct timespec st_ctim;            /* Time of last status change.  */
+# else
+    __time_t st_atime;
+    int __reserved0;
+    __time_t st_mtime;
+    int __reserved1;
+    __time_t st_ctime;
+    int __reserved2;
+# endif
+    __blksize_t st_blksize;
+    unsigned int st_pad3;
+    __blkcnt64_t st_blocks;
+    int st_pad4[14];
+};
+#endif
+#endif
+
+/* Tell code we have these members.  */
+#define	_STATBUF_ST_BLKSIZE
+#define	_STATBUF_ST_RDEV
+
+/* Encoding of the file mode.  */
+
+#define	__S_IFMT	0170000	/* These bits determine file type.  */
+
+/* File types.  */
+#define	__S_IFDIR	0040000	/* Directory.  */
+#define	__S_IFCHR	0020000	/* Character device.  */
+#define	__S_IFBLK	0060000	/* Block device.  */
+#define	__S_IFREG	0100000	/* Regular file.  */
+#define	__S_IFIFO	0010000	/* FIFO.  */
+#define	__S_IFLNK	0120000	/* Symbolic link.  */
+#define	__S_IFSOCK	0140000	/* Socket.  */
+
+/* POSIX.1b objects.  Note that these macros always evaluate to zero.  But
+   they do it by enforcing the correct use of the macros.  */
+#define __S_TYPEISMQ(buf)  ((buf)->st_mode - (buf)->st_mode)
+#define __S_TYPEISSEM(buf) ((buf)->st_mode - (buf)->st_mode)
+#define __S_TYPEISSHM(buf) ((buf)->st_mode - (buf)->st_mode)
+
+/* Protection bits.  */
+
+#define	__S_ISUID	04000	/* Set user ID on execution.  */
+#define	__S_ISGID	02000	/* Set group ID on execution.  */
+#define	__S_ISVTX	01000	/* Save swapped text after use (sticky).  */
+#define	__S_IREAD	0400	/* Read by owner.  */
+#define	__S_IWRITE	0200	/* Write by owner.  */
+#define	__S_IEXEC	0100	/* Execute by owner.  */
+
+#ifdef __USE_ATFILE
+# define UTIME_NOW	((1l << 30) - 1l)
+# define UTIME_OMIT	((1l << 30) - 2l)
+#endif
+
+#endif	/* bits/stat.h */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/bits/termios.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/termios.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/bits/termios.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/bits/termios.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,221 @@
+/* termios type and macro definitions.  Linux/MIPS version.
+   Copyright (C) 1993, 94, 95, 96, 97, 99, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _TERMIOS_H
+# error "Never include <bits/termios.h> directly; use <termios.h> instead."
+#endif
+
+typedef unsigned char	cc_t;
+typedef unsigned int	speed_t;
+typedef unsigned int	tcflag_t;
+
+#define NCCS 32
+struct termios
+  {
+    tcflag_t c_iflag;		/* input mode flags */
+    tcflag_t c_oflag;		/* output mode flags */
+    tcflag_t c_cflag;		/* control mode flags */
+    tcflag_t c_lflag;		/* local mode flags */
+    cc_t c_line;		/* line discipline */
+    cc_t c_cc[NCCS];		/* control characters */
+  };
+
+/* c_cc characters */
+#define VINTR		0	/* Interrupt character [ISIG].  */
+#define VQUIT		1	/* Quit character [ISIG].  */
+#define VERASE		2	/* Erase character [ICANON].  */
+#define VKILL		3	/* Kill-line character [ICANON].  */
+#define VMIN		4	/* Minimum number of bytes read at once [!ICANON].  */
+#define VTIME		5	/* Time-out value (tenths of a second) [!ICANON].  */
+#define VEOL2		6	/* Second EOL character [ICANON].  */
+#define VSWTC		7
+#define VSWTCH		VSWTC
+#define VSTART		8	/* Start (X-ON) character [IXON, IXOFF].  */
+#define VSTOP		9	/* Stop (X-OFF) character [IXON, IXOFF].  */
+#define VSUSP		10	/* Suspend character [ISIG].  */
+				/* VDSUSP is not supported on Linux. */
+/* #define VDSUSP	11	/ * Delayed suspend character [ISIG].  */
+#define VREPRINT	12	/* Reprint-line character [ICANON].  */
+#define VDISCARD	13	/* Discard character [IEXTEN].  */
+#define VWERASE		14	/* Word-erase character [ICANON].  */
+#define VLNEXT		15	/* Literal-next character [IEXTEN].  */
+#define VEOF		16	/* End-of-file character [ICANON].  */
+#define VEOL		17	/* End-of-line character [ICANON].  */
+
+/* c_iflag bits */
+#define IGNBRK	0000001		/* Ignore break condition.  */
+#define BRKINT	0000002		/* Signal interrupt on break.  */
+#define IGNPAR	0000004		/* Ignore characters with parity errors.  */
+#define PARMRK	0000010		/* Mark parity and framing errors.  */
+#define INPCK	0000020		/* Enable input parity check.  */
+#define ISTRIP	0000040		/* Strip 8th bit off characters.  */
+#define INLCR	0000100		/* Map NL to CR on input.  */
+#define IGNCR	0000200		/* Ignore CR.  */
+#define ICRNL	0000400		/* Map CR to NL on input.  */
+#define IUCLC	0001000		/* Map upper case to lower case on input.  */
+#define IXON	0002000		/* Enable start/stop output control.  */
+#define IXANY	0004000		/* Any character will restart after stop.  */
+#define IXOFF	0010000		/* Enable start/stop input control.  */
+#define IMAXBEL 0020000		/* Ring bell when input queue is full.  */
+#define IUTF8	0040000		/* Input is UTF8.  */
+
+/* c_oflag bits */
+#define OPOST	0000001		/* Perform output processing.  */
+#define OLCUC	0000002		/* Map lower case to upper case on output.  */
+#define ONLCR	0000004		/* Map NL to CR-NL on output.  */
+#define OCRNL	0000010
+#define ONOCR	0000020
+#define ONLRET	0000040
+#define OFILL	0000100
+#define OFDEL	0000200
+#if defined __USE_MISC || defined __USE_XOPEN
+# define NLDLY	0000400
+# define   NL0	0000000
+# define   NL1	0000400
+# define CRDLY	0003000
+# define   CR0	0000000
+# define   CR1	0001000
+# define   CR2	0002000
+# define   CR3	0003000
+# define TABDLY	0014000
+# define   TAB0	0000000
+# define   TAB1	0004000
+# define   TAB2	0010000
+# define   TAB3	0014000
+# define BSDLY	0020000
+# define   BS0	0000000
+# define   BS1	0020000
+# define FFDLY	0100000
+# define   FF0	0000000
+# define   FF1	0100000
+#endif
+
+#define VTDLY	0040000
+#define   VT0	0000000
+#define   VT1	0040000
+
+#ifdef __USE_MISC
+# define XTABS  0014000
+#endif
+
+/* c_cflag bit meaning */
+#ifdef __USE_MISC
+# define CBAUD	0010017
+#endif
+#define  B0	0000000		/* hang up */
+#define  B50	0000001
+#define  B75	0000002
+#define  B110	0000003
+#define  B134	0000004
+#define  B150	0000005
+#define  B200	0000006
+#define  B300	0000007
+#define  B600	0000010
+#define  B1200	0000011
+#define  B1800	0000012
+#define  B2400	0000013
+#define  B4800	0000014
+#define  B9600	0000015
+#define  B19200	0000016
+#define  B38400	0000017
+#ifdef __USE_MISC
+# define EXTA B19200
+# define EXTB B38400
+#endif
+#define CSIZE	0000060		/* Number of bits per byte (mask).  */
+#define   CS5	0000000		/* 5 bits per byte.  */
+#define   CS6	0000020		/* 6 bits per byte.  */
+#define   CS7	0000040		/* 7 bits per byte.  */
+#define   CS8	0000060		/* 8 bits per byte.  */
+#define CSTOPB	0000100		/* Two stop bits instead of one.  */
+#define CREAD	0000200		/* Enable receiver.  */
+#define PARENB	0000400		/* Parity enable.  */
+#define PARODD	0001000		/* Odd parity instead of even.  */
+#define HUPCL	0002000		/* Hang up on last close.  */
+#define CLOCAL	0004000		/* Ignore modem status lines.  */
+#ifdef __USE_MISC
+# define CBAUDEX   0010000
+#endif
+#define  B57600   0010001
+#define  B115200  0010002
+#define  B230400  0010003
+#define  B460800  0010004
+#define  B500000  0010005
+#define  B576000  0010006
+#define  B921600  0010007
+#define  B1000000 0010010
+#define  B1152000 0010011
+#define  B1500000 0010012
+#define  B2000000 0010013
+#define  B2500000 0010014
+#define  B3000000 0010015
+#define  B3500000 0010016
+#define  B4000000 0010017
+#define __MAX_BAUD B4000000
+#ifdef __USE_MISC
+# define CIBAUD	  002003600000	/* input baud rate (not used) */
+# define CRTSCTS  020000000000		/* flow control */
+#endif
+
+/* c_lflag bits */
+#define ISIG	0000001		/* Enable signals.  */
+#define ICANON	0000002		/* Do erase and kill processing.  */
+#if defined __USE_MISC || defined __USE_XOPEN
+# define XCASE	0000004
+#endif
+#define ECHO	0000010		/* Enable echo.  */
+#define ECHOE	0000020		/* Visual erase for ERASE.  */
+#define ECHOK	0000040		/* Echo NL after KILL.  */
+#define ECHONL	0000100		/* Echo NL even if ECHO is off.  */
+#define NOFLSH	0000200		/* Disable flush after interrupt.  */
+#define IEXTEN	0000400		/* Enable DISCARD and LNEXT.  */
+#ifdef __USE_MISC
+# define ECHOCTL 0001000	/* Echo control characters as ^X.  */
+# define ECHOPRT 0002000	/* Hardcopy visual erase.  */
+# define ECHOKE	 0004000	/* Visual erase for KILL.  */
+# define FLUSHO	0020000
+# define PENDIN	0040000		/* Retype pending input (state).  */
+#endif
+#define TOSTOP	0100000		/* Send SIGTTOU for background output.  */
+#define ITOSTOP	TOSTOP
+#ifdef __USE_BSD
+# define EXTPROC 0200000
+#endif
+
+/* ioctl (fd, TIOCSERGETLSR, &result) where result may be as below */
+#define TIOCSER_TEMT    0x01	/* Transmitter physically empty */
+
+/* tcflow() and TCXONC use these */
+#define	TCOOFF		0	/* Suspend output.  */
+#define	TCOON		1	/* Restart suspended output.  */
+#define	TCIOFF		2	/* Send a STOP character.  */
+#define	TCION		3	/* Send a START character.  */
+
+/* tcflush() and TCFLSH use these */
+#define	TCIFLUSH	0	/* Discard data received but not yet read.  */
+#define	TCOFLUSH	1	/* Discard data written but not yet sent.  */
+#define	TCIOFLUSH	2	/* Discard all pending data.  */
+
+/* tcsetattr uses these */
+#define	TCSANOW		0x540e	/* Same as TCSETS; change immediately.  */
+#define	TCSADRAIN	0x540f	/* Same as TCSETSW; change when pending output is written.  */
+#define	TCSAFLUSH	0x5410	/* Same as TCSETSF; flush pending input before changing.  */
+
+#define _IOT_termios /* Hurd ioctl type field.  */ \
+  _IOT (_IOTS (cflag_t), 4, _IOTS (cc_t), NCCS, _IOTS (speed_t), 2)
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/brk.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/brk.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/brk.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/brk.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,60 @@
+/* brk system call for Linux/MIPS.
+   Copyright (C) 2000, 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <unistd.h>
+#include <sysdep.h>
+
+void *__curbrk = 0;
+
+/* Old braindamage in GCC's crtstuff.c requires this symbol in an attempt
+   to work around different old braindamage in the old Linux/x86 ELF
+   dynamic linker.  Sigh.  */
+weak_alias (__curbrk, ___brk_addr)
+
+int
+__brk (void *addr)
+{
+  void *newbrk;
+
+  {
+    register long res asm ("v0");
+    register void*  arg asm ("a0");
+
+    res = SYS_ify (brk);
+    arg = addr;
+
+    asm ("syscall"		/* Perform the system call.  */
+	 : "+r" (res)
+	 : "r" (arg)
+	 : "a3", __SYSCALL_CLOBBERS);
+
+    newbrk = (void *) res;
+  }
+  __curbrk = newbrk;
+
+  if (newbrk < addr)
+    {
+      __set_errno (ENOMEM);
+      return -1;
+    }
+
+  return 0;
+}
+weak_alias (__brk, brk)
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/clone.S glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/clone.S
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/clone.S	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/clone.S	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,124 @@
+/* Copyright (C) 1996, 1997, 2000, 2003, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ralf Baechle <ralf@linux-mips.org>, 1996.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* clone() is even more special than fork() as it mucks with stacks
+   and invokes a function in the right context after its all over.  */
+
+#include <sys/asm.h>
+#include <sysdep.h>
+#define _ERRNO_H	1
+#include <bits/errno.h>
+#ifdef RESET_PID
+#include <tls.h>
+#include "tcb-offsets.h"
+#endif
+
+#define CLONE_VM      0x00000100
+#define CLONE_THREAD  0x00010000
+
+/* int clone(int (*fn)(void *arg), void *child_stack, int flags, void *arg,
+	     void *parent_tidptr, void *tls, void *child_tidptr) */
+
+	.text
+LEAF(__clone)
+
+	/* Sanity check arguments.  */
+	li		v0,EINVAL
+	beqz		a0,L(error)	/* No NULL function pointers.  */
+	beqz		a1,L(error)	/* No NULL stack pointers.  */
+
+	addi		a1,a1,-32		/* Reserve argument save space.  */
+	REG_S		a0,0(a1)	/* Save function pointer.  */
+	REG_S		a3,PTRSIZE(a1)	/* Save argument pointer.  */
+#ifdef RESET_PID
+	REG_S		a2,(PTRSIZE*2)(a1)	/* Save clone flags.  */
+#endif
+
+	move		a0,a2
+
+	/* Shuffle in the last three arguments - arguments 5, 6, and 7 to
+	   this function, but arguments 3, 4, and 5 to the syscall.  */
+	move		a2,a4
+	move		a3,a5
+	move		a4,a6
+
+	/* Do the system call */
+	li		v0,__NR_clone
+	syscall
+
+	bnez		a3,L(error)
+	beqz		v0,L(thread_start)
+
+	/* Successful return from the parent */
+	ret
+
+	/* Something bad happened -- no child created */
+L(error):
+	PIC_J(__syscall_error)
+	END(__clone)
+
+/* Load up the arguments to the function.  Put this block of code in
+   its own function so that we can terminate the stack trace with our
+   debug info.  */
+
+ENTRY(__thread_start)
+L(thread_start):
+	/* The stackframe has been created on entry of clone().  */
+
+#ifdef RESET_PID
+	/* Check and see if we need to reset the PID.  */
+	REG_L		a0,(PTRSIZE*2)(sp)
+	li		a1,CLONE_THREAD
+	and		a1,a0,a1
+	beqz		a1,L(restore_pid)
+L(donepid):
+#endif
+
+	/* Restore the arg for user's function.  */
+	REG_L		t7,0(sp)	/* Function pointer.  */
+	REG_L		a0,SZREG(sp)	/* Argument pointer.  */
+
+	/* Call the user's function.  */
+	jalr		t7
+
+	/* Call _exit rather than doing it inline for breakpoint purposes.  */
+	move		a0,v0
+	SETUP_GPX64(t6, t7)
+	PIC_JAL(t6, _exit)
+
+#ifdef RESET_PID
+L(restore_pid):
+	and		a1,a0,CLONE_VM
+	li		v0,-1
+	bnez		a1,L(gotpid)
+	li		v0,__NR_getpid
+	syscall
+L(gotpid):
+	lui		t0,%hi(PID_OFFSET)
+	add		t0,t0,tp
+	sw		v0,%lo(PID_OFFSET)(t0)
+	lui		t0,%hi(PID_OFFSET)
+	add		t0,t0,tp
+	sw		v0,%lo(TID_OFFSET)(t0)
+	b		L(donepid)
+#endif
+
+	END(__thread_start)
+
+weak_alias (__clone, clone)
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/configure glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/configure
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/configure	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/configure	2011-11-07 20:22:30.000000000 -0800
@@ -0,0 +1,28 @@
+# This file is generated from configure.in by Autoconf.  DO NOT EDIT!
+ # Local configure fragment for sysdeps/unix/sysv/linux/riscv.
+
+case "$prefix" in
+/usr | /usr/)
+  # 32-bit libraries on bi-arch platforms go in /lib32 instead of /lib.
+  # Allow earlier configure scripts to handle libc_cv_slibdir, libdir,
+  # and libc_cv_localedir.
+  test -n "$libc_cv_slibdir" || \
+  case $machine in
+  riscv/rv32* )
+    libc_cv_slibdir="/lib32"
+    if test "$libdir" = '${exec_prefix}/lib'; then
+      libdir='${exec_prefix}/lib32';
+      # Locale data can be shared between 32bit and 64bit libraries
+      libc_cv_localedir='${exec_prefix}/lib/locale'
+    fi
+    ;;
+  *)
+    libc_cv_slibdir="/lib"
+    ;;
+  esac
+esac
+
+if test -z "$arch_minimum_kernel"; then
+  arch_minimum_kernel=2.4.1
+  libc_cv_gcc_unwind_find_fde=yes
+fi
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/configure.in glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/configure.in
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/configure.in	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/configure.in	2011-11-07 20:22:37.000000000 -0800
@@ -0,0 +1,29 @@
+sinclude(./aclocal.m4)dnl Autoconf lossage
+GLIBC_PROVIDES dnl See aclocal.m4 in the top level source directory.
+# Local configure fragment for sysdeps/unix/sysv/linux/riscv.
+
+case "$prefix" in
+/usr | /usr/)
+  # 32-bit libraries on bi-arch platforms go in /lib32 instead of /lib.
+  # Allow earlier configure scripts to handle libc_cv_slibdir, libdir,
+  # and libc_cv_localedir.
+  test -n "$libc_cv_slibdir" || \
+  case $machine in
+  riscv/rv32* )
+    libc_cv_slibdir="/lib32"
+    if test "$libdir" = '${exec_prefix}/lib'; then
+      libdir='${exec_prefix}/lib32';
+      # Locale data can be shared between 32bit and 64bit libraries
+      libc_cv_localedir='${exec_prefix}/lib/locale'
+    fi
+    ;;
+  *)
+    libc_cv_slibdir="/lib"
+    ;;
+  esac
+esac
+
+if test -z "$arch_minimum_kernel"; then
+  arch_minimum_kernel=2.4.1
+  libc_cv_gcc_unwind_find_fde=yes
+fi
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/dl-cache.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/dl-cache.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/dl-cache.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/dl-cache.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,57 @@
+/* Support for reading /etc/ld.so.cache files written by Linux ldconfig.
+   Copyright (C) 2003, 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <ldconfig.h>
+
+/* Redefine the cache ID for new ABIs; o32 keeps using the generic check.  */
+#if _RISCV_SIM == _ABI64
+# define _DL_CACHE_DEFAULT_ID	(FLAG_MIPS64_LIBN64 | FLAG_ELF_LIBC6)
+#elif _RISCV_SIM == _ABIN32
+# define _DL_CACHE_DEFAULT_ID	(FLAG_MIPS64_LIBN32 | FLAG_ELF_LIBC6)
+#endif
+
+#ifdef _DL_CACHE_DEFAULT_ID
+# define _dl_cache_check_flags(flags) \
+  ((flags) == _DL_CACHE_DEFAULT_ID)
+#endif
+
+#define add_system_dir(dir) \
+  do								\
+    {								\
+      size_t len = strlen (dir);				\
+      char path[len + 3];					\
+      memcpy (path, dir, len + 1);				\
+      if (len >= 6						\
+	  && (! memcmp (path + len - 6, "/lib64", 6)		\
+	      || ! memcmp (path + len - 6, "/lib32", 6)))	\
+	{							\
+	  len -= 2;						\
+	  path[len] = '\0';					\
+	}							\
+      add_dir (path);						\
+      if (len >= 4 && ! memcmp (path + len - 4, "/lib", 4))	\
+	{							\
+	  memcpy (path + len, "32", 3);				\
+	  add_dir (path);					\
+	  memcpy (path + len, "64", 3);				\
+	  add_dir (path);					\
+	}							\
+    } while (0)
+
+#include_next <dl-cache.h>
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/dl-static.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/dl-static.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/dl-static.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/dl-static.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,92 @@
+/* Variable initialization.  MIPS version.
+   Copyright (C) 2001, 2002, 2003, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <ldsodefs.h>
+
+#ifdef SHARED
+
+void
+_dl_var_init (void *array[])
+{
+  /* It has to match "variables" below. */
+  enum
+    {
+      DL_PAGESIZE = 0
+    };
+
+  GLRO(dl_pagesize) = *((size_t *) array[DL_PAGESIZE]);
+}
+
+#else
+#include <bits/libc-lock.h>
+
+__libc_lock_define_initialized_recursive (static, _dl_static_lock)
+
+static void *variables[] =
+{
+  &GLRO(dl_pagesize)
+};
+
+static void
+_dl_unprotect_relro (struct link_map *l)
+{
+  ElfW(Addr) start = ((l->l_addr + l->l_relro_addr)
+		      & ~(GLRO(dl_pagesize) - 1));
+  ElfW(Addr) end = ((l->l_addr + l->l_relro_addr + l->l_relro_size)
+		    & ~(GLRO(dl_pagesize) - 1));
+
+  if (start != end)
+    __mprotect ((void *) start, end - start, PROT_READ | PROT_WRITE);
+}
+
+void
+_dl_static_init (struct link_map *l)
+{
+  struct link_map *rtld_map = l;
+  struct r_scope_elem **scope;
+  const ElfW(Sym) *ref = NULL;
+  lookup_t loadbase;
+  void (*f) (void *[]);
+  size_t i;
+
+  __libc_lock_lock_recursive (_dl_static_lock);
+
+  loadbase = _dl_lookup_symbol_x ("_dl_var_init", l, &ref, l->l_local_scope,
+				  NULL, 0, 1, NULL);
+  
+  for (scope = l->l_local_scope; *scope != NULL; scope++)
+    for (i = 0; i < (*scope)->r_nlist; i++)
+      if ((*scope)->r_list[i] == loadbase)
+	{
+	  rtld_map = (*scope)->r_list[i];
+	  break;
+	}
+
+  if (ref != NULL)
+    {
+      f = (void (*) (void *[])) DL_SYMBOL_ADDRESS (loadbase, ref);
+      _dl_unprotect_relro (rtld_map);
+      f (variables);
+      _dl_protect_relro (rtld_map);
+    }
+
+  __libc_lock_unlock_recursive (_dl_static_lock);
+}
+
+#endif
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/fcntl.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/fcntl.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/fcntl.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/fcntl.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/fcntl.c>
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/ftruncate64.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/ftruncate64.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/ftruncate64.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/ftruncate64.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,76 @@
+/* Copyright (C) 1997,1998,1999,2000,2001,2002,2003,2005,2006
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/types.h>
+#include <errno.h>
+#include <endian.h>
+#include <unistd.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+
+#include <kernel-features.h>
+
+#ifdef __NR_ftruncate64
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+/* The variable is shared between all wrappers around *truncate64 calls.  */
+extern int __have_no_truncate64;
+#endif
+
+/* Truncate the file FD refers to to LENGTH bytes.  */
+int
+__ftruncate64 (int fd, off64_t length)
+{
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+  if (! __have_no_truncate64)
+#endif
+    {
+      unsigned int low = length & 0xffffffff;
+      unsigned int high = length >> 32;
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+      int saved_errno = errno;
+#endif
+      int result = INLINE_SYSCALL (ftruncate64, 4, fd, 0,
+				   __LONG_LONG_PAIR (high, low));
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+      if (result != -1 || errno != ENOSYS)
+#endif
+	return result;
+
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+      __set_errno (saved_errno);
+      __have_no_truncate64 = 1;
+#endif
+    }
+
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+  if ((off_t) length != length)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+  return __ftruncate (fd, (off_t) length);
+#endif
+}
+weak_alias (__ftruncate64, ftruncate64)
+
+#else
+/* Use the generic implementation.  */
+# include <misc/ftruncate64.c>
+#endif
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/getcontext.S glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/getcontext.S
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/getcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/getcontext.S	2011-11-02 01:26:28.000000000 -0700
@@ -0,0 +1,83 @@
+/* Save current context.
+   Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Maciej W. Rozycki <macro@codesourcery.com>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#include <sysdep.h>
+#include <sys/asm.h>
+
+#include "ucontext_i.h"
+
+/* int getcontext (ucontext_t *ucp) */
+
+	.text
+LEAF (__getcontext)
+	/* Store a magic flag.	*/
+	li	v1, 1
+	REG_S	v1, ( 0 * SZREG + MCONTEXT_GREGS)(a0)	/* zero */
+
+	REG_S	ra, MCONTEXT_PC(a0)
+	REG_S	ra, ( 1 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s0, (20 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s1, (21 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s2, (22 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s3, (23 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s4, (24 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s5, (25 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s6, (26 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s7, (27 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s8, (28 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s9, (29 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	sp, (30 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	tp, (31 * SZREG + MCONTEXT_GREGS)(a0)
+
+#ifdef __riscv_hard_float
+  mffsr v1
+
+	fsd	fs0, (20 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs1, (21 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs2, (22 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs3, (23 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs4, (24 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs5, (25 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs6, (26 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs7, (27 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs8, (28 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs9, (29 * 8 + MCONTEXT_FPREGS)(a0)
+
+	sw	v1, MCONTEXT_FSR(a0)
+#endif /* __mips_hard_float */
+
+/* rt_sigprocmask (SIG_BLOCK, NULL, &ucp->uc_sigmask, _NSIG8) */
+	li	a3, _NSIG8
+	add     a2, a0, UCONTEXT_SIGMASK
+	move	a1, zero
+	li	a0, SIG_BLOCK
+
+	li	v0, SYS_ify (rt_sigprocmask)
+	syscall
+	bnez	a3, 99f
+
+	move	v0, zero
+	ret
+
+99:	PIC_J(__syscall_error)
+
+PSEUDO_END (__getcontext)
+
+weak_alias (__getcontext, getcontext)
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/getmsg.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/getmsg.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/getmsg.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/getmsg.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/getmsg.c>
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/getsysstats.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/getsysstats.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/getsysstats.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/getsysstats.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,37 @@
+/* Determine various system internal values, Linux/MIPS version.
+   Copyright (C) 2001, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+
+/* We need to define a special parser for /proc/cpuinfo.  */
+#define GET_NPROCS_PARSER(FD, BUFFER, CP, RE, BUFFER_END, RESULT)	  \
+  do									  \
+    {									  \
+      (RESULT) = 0;							  \
+      /* Read all lines and count the lines starting with the string	  \
+	 "cpu model".  We don't have to fear extremely long lines since	  \
+	 the kernel will not generate them.  8192 bytes are really	  \
+	 enough.  */							  \
+      char *l;								  \
+      while ((l = next_line (FD, BUFFER, &CP, &RE, BUFFER_END)) != NULL)  \
+	if (strncmp (l, "cpu model", 9) == 0)				  \
+	  ++(RESULT);							  \
+    }									  \
+  while (0)
+
+#include <sysdeps/unix/sysv/linux/getsysstats.c>
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/Implies glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/Implies
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/Implies	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/Implies	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,2 @@
+# This needs to change to support rv32
+unix/sysv/linux/riscv/rv64
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/ipc_priv.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/ipc_priv.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/ipc_priv.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/ipc_priv.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/powerpc/ipc_priv.h>
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/kernel-features.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/kernel-features.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/kernel-features.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/kernel-features.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,46 @@
+/* Set flags signalling availability of kernel features based on given
+   kernel version number.
+   Copyright (C) 1999-2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sgidefs.h>
+
+/* Linux 2.3.39 introduced 32bit UID/GIDs.  Some platforms had 32
+   bit type all along.  */
+#define __ASSUME_32BITUIDS		1
+
+/* MIPS platforms had IPC64 all along.  */
+#define __ASSUME_IPC64		1
+
+#if _RISCV_SIM == _ABIN32
+# define __ASSUME_FCNTL64		1
+#endif
+
+/* Support for the eventfd2 and signalfd4 syscalls was added in 2.6.27.  */
+#if __LINUX_KERNEL_VERSION >= 0x02061c
+# define __ASSUME_EVENTFD2	1
+# define __ASSUME_SIGNALFD4	1
+#endif
+
+#include_next <kernel-features.h>
+
+/* The n32 syscall ABI did not have a getdents64 syscall until
+   2.6.35.  */
+#if _RISCV_SIM == _ABIN32 && __LINUX_KERNEL_VERSION < 0x020623
+# undef __ASSUME_GETDENTS64_SYSCALL
+#endif
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/kernel_rt_sigframe.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/kernel_rt_sigframe.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/kernel_rt_sigframe.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/kernel_rt_sigframe.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,10 @@
+/* Linux kernel RT signal frame. */
+typedef struct kernel_rt_sigframe
+  {
+    uint32_t rs_ass[4];
+    uint32_t rs_code[2];
+    struct siginfo rs_info;
+    struct ucontext rs_uc;
+    uint32_t rs_altcode[8] __attribute__ ((__aligned__ (1 << 7)));
+  }
+kernel_rt_sigframe_t;
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/kernel_sigaction.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/kernel_sigaction.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/kernel_sigaction.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/kernel_sigaction.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,40 @@
+/* This is the sigaction structure from the Linux 2.1.24 kernel.  */
+
+#include <sgidefs.h>
+
+#define HAVE_SA_RESTORER
+
+struct old_kernel_sigaction {
+	unsigned int	sa_flags;
+	__sighandler_t	k_sa_handler;
+	unsigned long	sa_mask;
+	unsigned int    __pad0[3]; /* reserved, keep size constant */
+
+	/* Abi says here follows reserved int[2] */
+	void		(*sa_restorer)(void);
+#if (_RISCV_SZPTR < 64)
+	/*
+	 * For 32 bit code we have to pad struct sigaction to get
+	 * constant size for the ABI
+	 */
+	int		pad1[1]; /* reserved */
+#endif
+};
+
+
+#define _KERNEL_NSIG	       128
+#define _KERNEL_NSIG_BPW       _RISCV_SZLONG
+#define _KERNEL_NSIG_WORDS     (_KERNEL_NSIG / _KERNEL_NSIG_BPW)
+
+typedef struct {
+	unsigned long sig[_KERNEL_NSIG_WORDS];
+} kernel_sigset_t;
+
+/* This is the sigaction structure from the Linux 2.1.68 kernel.  */
+struct kernel_sigaction {
+	unsigned int	sa_flags;
+	__sighandler_t	k_sa_handler;
+	kernel_sigset_t	sa_mask;
+	void		(*sa_restorer)(void);
+	int		s_resv[1]; /* reserved */
+};
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/kernel_stat.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/kernel_stat.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/kernel_stat.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/kernel_stat.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,57 @@
+#include <sgidefs.h>
+/* As tempting as it is to define XSTAT_IS_XSTAT64 for n64, the
+   userland data structures are not identical, because of different
+   padding.  */
+/* Definition of `struct stat' used in the kernel.  */
+#if _RISCV_SIM != _ABIO32
+struct kernel_stat
+  {
+    unsigned int st_dev;
+    unsigned int __pad1[3];
+    unsigned long long st_ino;
+    unsigned int st_mode;
+    unsigned int st_nlink;
+    int st_uid;
+    int st_gid;
+    unsigned int st_rdev;
+    unsigned int __pad2[3];
+    long long st_size;
+    unsigned int st_atime_sec;
+    unsigned int st_atime_nsec;
+    unsigned int st_mtime_sec;
+    unsigned int st_mtime_nsec;
+    unsigned int st_ctime_sec;
+    unsigned int st_ctime_nsec;
+    unsigned int st_blksize;
+    unsigned int __pad3;
+    unsigned long long st_blocks;
+  };
+#else
+struct kernel_stat
+  {
+    unsigned long int st_dev;
+    long int __pad1[3];			/* Reserved for network id */
+    unsigned long int st_ino;
+    unsigned long int st_mode;
+    unsigned long int st_nlink;
+    long int st_uid;
+    long int st_gid;
+    unsigned long int st_rdev;
+    long int __pad2[2];
+    long int st_size;
+    long int __pad3;
+    unsigned int st_atime_sec;
+    unsigned int st_atime_nsec;
+    unsigned int st_mtime_sec;
+    unsigned int st_mtime_nsec;
+    unsigned int st_ctime_sec;
+    unsigned int st_ctime_nsec;
+    long int st_blksize;
+    long int st_blocks;
+    char st_fstype[16];			/* Filesystem type name, unsupported */
+    long st_pad4[8];
+    /* Linux specific fields */
+    unsigned int st_flags;
+    unsigned int st_gen;
+  };
+#endif
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/kernel_termios.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/kernel_termios.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/kernel_termios.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/kernel_termios.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,35 @@
+/* Copyright (C) 1997 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _KERNEL_TERMIOS_H
+#define _KERNEL_TERMIOS_H 1
+/* The following corresponds to the values from the Linux 2.1.24 kernel.  */
+
+#define __KERNEL_NCCS 23
+
+struct __kernel_termios
+  {
+    tcflag_t c_iflag;		/* input mode flags */
+    tcflag_t c_oflag;		/* output mode flags */
+    tcflag_t c_cflag;		/* control mode flags */
+    tcflag_t c_lflag;		/* local mode flags */
+    cc_t c_line;		/* line discipline */
+    cc_t c_cc[__KERNEL_NCCS];	/* control characters */
+  };
+
+#endif /* kernel_termios.h */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/ldsodefs.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/ldsodefs.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/ldsodefs.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/ldsodefs.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,41 @@
+/* Run-time dynamic linker data structures for loaded ELF shared objects. MIPS.
+   Copyright (C) 2001, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_LDSODEFS_H
+
+/* Get the real definitions.  */
+#include_next <ldsodefs.h>
+
+/* Now define our stuff.  */
+
+/* We need special support to initialize DSO loaded for statically linked
+   binaries.  */
+extern void _dl_static_init (struct link_map *map);
+#undef DL_STATIC_INIT
+#define DL_STATIC_INIT(map) _dl_static_init (map)
+
+/* Allow ABIVERSION == 1, meaning PLTs and copy relocations are
+   required, with ELFOSABI_SYSV.  */
+#undef VALID_ELF_ABIVERSION
+#define VALID_ELF_ABIVERSION(osabi,ver)			\
+  (ver == 0						\
+   || (osabi == ELFOSABI_SYSV && ver < 2)		\
+   || (osabi == ELFOSABI_LINUX && ver < LIBC_ABI_MAX))
+
+#endif /* ldsodefs.h */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/libc-abis glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/libc-abis
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/libc-abis	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/libc-abis	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,13 @@
+# See the copy of this file in libc for detailed explanations.  This
+# copy needs to include all libc definitions applicable to MIPS; only
+# one copy will be used.
+#
+# Feature Name	Configuration
+# ------------	-------------
+#
+# MIPS PLTs.
+MIPS_PLT	mips*-*-linux*
+#
+# Unique symbol definitions for C++.
+# Architecture independent, all ELF targets (== all targets)
+UNIQUE
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/lockf64.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/lockf64.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/lockf64.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/lockf64.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/lockf64.c>
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/____longjmp_chk.S glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/____longjmp_chk.S
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/____longjmp_chk.S	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/____longjmp_chk.S	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,2 @@
+#define __longjmp ____longjmp_chk
+#include <__longjmp.S>
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/makecontext.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/makecontext.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/makecontext.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/makecontext.c	2011-10-27 22:23:54.000000000 -0700
@@ -0,0 +1,34 @@
+#include <sysdep.h>
+#include <sys/asm.h>
+#include <sys/ucontext.h>
+#include <stdarg.h>
+
+void __makecontext (ucontext_t *ucp, void (*func) (), int argc, ...)
+{
+  extern void __start_context(void);
+  int i, reg_args;
+  long sp;
+  va_list vl;
+  va_start(vl, argc);
+
+  /* Store a magic flag in x0's save slot */
+  ucp->uc_mcontext.gregs[0] = 1;
+
+  /* Set up the stack. */
+  sp = ((long)ucp->uc_stack.ss_sp + ucp->uc_stack.ss_size) & ALMASK;
+  reg_args = argc < 8 ? argc : 8;
+  sp = (sp - (argc - reg_args) * sizeof(long)) & ALMASK;
+
+  /* Put args in a0-a7, then put any remaining args on the stack. */
+  for (i = 0; i < reg_args; i++)
+    ucp->uc_mcontext.gregs[4 + i] = va_arg(vl, long);
+  for (i = 0; i < argc - reg_args; i++)
+    ((long*)sp)[i] = va_arg(vl, long);
+
+  ucp->uc_mcontext.gregs[1] = (long)&__start_context;
+  ucp->uc_mcontext.gregs[20] = (long)ucp->uc_link;
+  ucp->uc_mcontext.gregs[30] = sp;
+  ucp->uc_mcontext.pc = (long)func;
+}
+
+weak_alias (__makecontext, makecontext)
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/Makefile glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/Makefile
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/Makefile	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,139 @@
+ifeq ($(subdir),signal)
+#sysdep_routines += sigsuspend
+endif
+
+ifeq ($(subdir),misc)
+
+no_syscall_list_h = 1
+
+# A callable macro that expands to a shell command.  Preprocess file $(1)
+# using ABI option $(2) and see which macros it defines.  Print FOO for each
+# macro of the form __NR$(3)_FOO, filtering out ABI-specific __NR macros
+# that have a prefix other than $(3).
+mips_list_syscalls =	$(filter-out -m%,$(CC)) -E -x c $(+includes) \
+			    $(sysincludes) -D_LIBC -dM -mabi=$(2) $(1) | \
+			sed -n 's@^\#define __NR$(3)_\([^ ]*\) .*@\1@p' | \
+			sed -e '/^[ON]32_/d' -e '/^N64_/d' -e '/^64_/d' | \
+			LC_ALL=C sort
+
+# Generate a list of SYS_* macros from the linux __NR macros.
+#
+# Before version 2.6, linux had separate 32-bit and 64-bit MIPS ports,
+# each with its own set of headers.  The ports were merged for 2.6 and
+# this merged port defines the syscalls in a slightly different way.
+# There are therefore three sets of headers that we need to consider:
+#
+#    (1) Headers from the separate 32-bit MIPS port.  They just define
+#	 a single list of __NR macros.
+#
+#    (2) Headers from the separate 64-bit MIPS port.  They unconditionally
+#	 define syscalls for all three ABIs, with o32 syscalls prefixed
+#	 by __NR_O32, n32 syscalls prefixed by __NR_N32 and n64 syscalls
+#	 prefixed by plain __NR.
+#
+#    (3) Headers from the combined port.  They use the _RISCV_SIM macro to
+#	 define the right set of syscalls for the current ABI.  The syscalls
+#	 themselves have no special ABI prefix, but the headers also define:
+#
+#	    __NR_O32_Linux{,_syscalls}
+#	    __NR_N32_Linux{,_syscalls}
+#	    __NR_64_Linux{,_syscalls}
+#
+# In case (1) we just want a simple list of SYS_* macros.  In cases (2)
+# and (3) we want a file that will work for all three ABIs, regardless
+# of which ABI we are currently using.  We also want the file to work
+# if the user later moves from (2) to (3).  Thus the file we create
+# for (2) and (3) has the form:
+#
+#    #if _RISCV_SIM == _ABIN32
+#    # ifdef __NR_N32_open
+#    #  define SYS_n32syscall1 __NR_N32_n32syscall1
+#    #  ...
+#    # else
+#    #  define SYS_n32syscall1 __NR_n32syscall1
+#    #  ...
+#    # endif
+#    #elif _RISCV_SIM == _ABI64
+#    # define SYS_n64syscall1 __NR_n64syscall1
+#    # ...
+#    #else
+#    # ifdef __NR_O32_open
+#    #  define SYS_o32syscall1 __NR_O32_o32syscall1
+#    #  ...
+#    # else
+#    #  define SYS_o32syscall1 __NR_o32syscall1
+#    #  ...
+#    # endif
+#    #endif
+#
+# Here, __NR_N32_open and __NR_O32_open are used to detect case (2)
+# over case (3).  The n64 SYS_* macros can always use the normal
+# ABI-less names.
+$(objpfx)syscall-%.h $(objpfx)syscall-%.d: ../sysdeps/unix/sysv/linux/mips/sys/syscall.h
+	$(make-target-directory)
+	$(CC) -E -x c $(+includes) $(sysincludes) -D_LIBC $< -MD -MP \
+	      -MF $(@:.h=.d)-t -MT '$(@:.d=.h) $(@:.h=.d)' > /dev/null
+	{ \
+	 echo '/* Generated at libc build time from kernel syscall list.  */';\
+	 echo ''; \
+	 echo '#ifndef _SYSCALL_H'; \
+	 echo '# error "Never use <bits/syscall.h> directly; include <sys/syscall.h> instead."'; \
+	 echo '#endif'; \
+	 echo ''; \
+	 echo '#include <sgidefs.h>'; \
+	 rm -f $(@:.d=.h).new32 $(@:.d=.h).newn32 $(@:.d=.h).new64; \
+	 $(call mips_list_syscalls,$<,n32,_N32) > $(@:.d=.h).newn32; \
+	 if test -s $(@:.d=.h).newn32; then \
+	   if grep open $(@:.d=.h).newn32 > /dev/null; then \
+	     $(call mips_list_syscalls,$<,32,_O32) > $(@:.d=.h).new32; \
+	     $(call mips_list_syscalls,$<,64,) > $(@:.d=.h).new64; \
+	   else \
+	     $(call mips_list_syscalls,$<,32,) > $(@:.d=.h).new32; \
+	     $(call mips_list_syscalls,$<,n32,) > $(@:.d=.h).newn32; \
+	     $(call mips_list_syscalls,$<,64,) > $(@:.d=.h).new64; \
+	   fi; \
+	   echo '#if _RISCV_SIM == _ABIN32'; \
+	   echo '# ifdef __NR_N32_open'; \
+	   sed 's@\(.*\)@#  define SYS_\1 __NR_N32_\1@' < $(@:.d=.h).newn32; \
+	   echo '# else'; \
+	   sed 's@\(.*\)@#  define SYS_\1 __NR_\1@' < $(@:.d=.h).newn32; \
+	   echo '# endif'; \
+	   echo '#elif _RISCV_SIM == _ABI64'; \
+	   sed 's@\(.*\)@# define SYS_\1 __NR_\1@' < $(@:.d=.h).new64; \
+	   echo '#else'; \
+	   echo '# ifdef __NR_O32_open'; \
+	   sed 's@\(.*\)@#  define SYS_\1 __NR_O32_\1@' < $(@:.d=.h).new32; \
+	   echo '# else'; \
+	   sed 's@\(.*\)@#  define SYS_\1 __NR_\1@' < $(@:.d=.h).new32; \
+	   echo '# endif'; \
+	   echo '#endif'; \
+	 else \
+	   $(CC) -E -x c $(+includes) $(sysincludes) -D_LIBC -dM $< | \
+	   sed -n 's@^\#define __NR_\([^ ]*\) .*@\#define SYS_\1 __NR_\1@p' | \
+	   LC_ALL=C sort; \
+	 fi; \
+	 rm -f $(@:.d=.h).new32 $(@:.d=.h).newn32 $(@:.d=.h).new64; \
+	} > $(@:.d=.h).new
+	mv -f $(@:.d=.h).new $(@:.d=.h)
+ifneq (,$(objpfx))
+	sed $(sed-remove-objpfx) $(@:.h=.d)-t > $(@:.h=.d)-t2
+	rm -f $(@:.h=.d)-t
+	mv -f $(@:.h=.d)-t2 $(@:.h=.d)
+else
+	mv -f $(@:.h=.d)-t $(@:.h=.d)
+endif
+endif
+
+ifeq ($(subdir),elf)
+ifeq ($(build-shared),yes)
+# This is needed for DSO loading from static binaries.
+sysdep-dl-routines += dl-static
+sysdep_routines += dl-static
+sysdep-rtld-routines += dl-static
+endif
+endif
+
+ifeq ($(subdir),stdlib)
+sysdep_routines += __start_context
+gen-as-const-headers += ucontext_i.sym
+endif
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/nptl/bits/local_lim.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/bits/local_lim.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/nptl/bits/local_lim.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/bits/local_lim.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,101 @@
+/* Minimum guaranteed maximum values for system limits.  MIPS Linux version.
+   Copyright (C) 1993-1998,2000,2002,2003,2004,2007,2008
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* The kernel header pollutes the namespace with the NR_OPEN symbol
+   and defines LINK_MAX although filesystems have different maxima.  A
+   similar thing is true for OPEN_MAX: the limit can be changed at
+   runtime and therefore the macro must not be defined.  Remove this
+   after including the header if necessary.  */
+#ifndef NR_OPEN
+# define __undef_NR_OPEN
+#endif
+#ifndef LINK_MAX
+# define __undef_LINK_MAX
+#endif
+#ifndef OPEN_MAX
+# define __undef_OPEN_MAX
+#endif
+#ifndef ARG_MAX
+# define __undef_ARG_MAX
+#endif
+
+/* The kernel sources contain a file with all the needed information.  */
+#include <linux/limits.h>
+
+/* Have to remove NR_OPEN?  */
+#ifdef __undef_NR_OPEN
+# undef NR_OPEN
+# undef __undef_NR_OPEN
+#endif
+/* Have to remove LINK_MAX?  */
+#ifdef __undef_LINK_MAX
+# undef LINK_MAX
+# undef __undef_LINK_MAX
+#endif
+/* Have to remove OPEN_MAX?  */
+#ifdef __undef_OPEN_MAX
+# undef OPEN_MAX
+# undef __undef_OPEN_MAX
+#endif
+/* Have to remove ARG_MAX?  */
+#ifdef __undef_ARG_MAX
+# undef ARG_MAX
+# undef __undef_ARG_MAX
+#endif
+
+/* The number of data keys per process.  */
+#define _POSIX_THREAD_KEYS_MAX	128
+/* This is the value this implementation supports.  */
+#define PTHREAD_KEYS_MAX	1024
+
+/* Controlling the iterations of destructors for thread-specific data.  */
+#define _POSIX_THREAD_DESTRUCTOR_ITERATIONS	4
+/* Number of iterations this implementation does.  */
+#define PTHREAD_DESTRUCTOR_ITERATIONS	_POSIX_THREAD_DESTRUCTOR_ITERATIONS
+
+/* The number of threads per process.  */
+#define _POSIX_THREAD_THREADS_MAX	64
+/* We have no predefined limit on the number of threads.  */
+#undef PTHREAD_THREADS_MAX
+
+/* Maximum amount by which a process can descrease its asynchronous I/O
+   priority level.  */
+#define AIO_PRIO_DELTA_MAX	20
+
+/* Minimum size for a thread.  At least two pages with 64k pages.  */
+#define PTHREAD_STACK_MIN	131072
+
+/* Maximum number of timer expiration overruns.  */
+#define DELAYTIMER_MAX	2147483647
+
+/* Maximum tty name length.  */
+#define TTY_NAME_MAX		32
+
+/* Maximum login name length.  This is arbitrary.  */
+#define LOGIN_NAME_MAX		256
+
+/* Maximum host name length.  */
+#define HOST_NAME_MAX		64
+
+/* Maximum message queue priority level.  */
+#define MQ_PRIO_MAX		32768
+
+/* Maximum value the semaphore can have.  */
+#define SEM_VALUE_MAX   (2147483647)
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/nptl/bits/pthreadtypes.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/bits/pthreadtypes.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/nptl/bits/pthreadtypes.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/bits/pthreadtypes.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,229 @@
+/* Machine-specific pthread type layouts.  MIPS version.
+   Copyright (C) 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_PTHREADTYPES_H
+#define _BITS_PTHREADTYPES_H	1
+
+#include <endian.h>
+
+#if _RISCV_SIM == _ABI64
+# define __SIZEOF_PTHREAD_ATTR_T 56
+# define __SIZEOF_PTHREAD_MUTEX_T 40
+# define __SIZEOF_PTHREAD_MUTEXATTR_T 4
+# define __SIZEOF_PTHREAD_COND_T 48
+# define __SIZEOF_PTHREAD_CONDATTR_T 4
+# define __SIZEOF_PTHREAD_RWLOCK_T 56
+# define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
+# define __SIZEOF_PTHREAD_BARRIER_T 32
+# define __SIZEOF_PTHREAD_BARRIERATTR_T 4
+#else
+# define __SIZEOF_PTHREAD_ATTR_T 36
+# define __SIZEOF_PTHREAD_MUTEX_T 24
+# define __SIZEOF_PTHREAD_MUTEXATTR_T 4
+# define __SIZEOF_PTHREAD_COND_T 48
+# define __SIZEOF_PTHREAD_CONDATTR_T 4
+# define __SIZEOF_PTHREAD_RWLOCK_T 32
+# define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
+# define __SIZEOF_PTHREAD_BARRIER_T 20
+# define __SIZEOF_PTHREAD_BARRIERATTR_T 4
+#endif
+
+
+/* Thread identifiers.  The structure of the attribute type is
+   deliberately not exposed.  */
+typedef unsigned long int pthread_t;
+
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_ATTR_T];
+  long int __align;
+} pthread_attr_t;
+
+
+#if _RISCV_SIM == _ABI64
+typedef struct __pthread_internal_list
+{
+  struct __pthread_internal_list *__prev;
+  struct __pthread_internal_list *__next;
+} __pthread_list_t;
+#else
+typedef struct __pthread_internal_slist
+{
+  struct __pthread_internal_slist *__next;
+} __pthread_slist_t;
+#endif
+
+
+/* Data structures for mutex handling.  The structure of the attribute
+   type is deliberately not exposed.  */
+typedef union
+{
+  struct __pthread_mutex_s
+  {
+    int __lock;
+    unsigned int __count;
+    int __owner;
+#if _RISCV_SIM == _ABI64
+    unsigned int __nusers;
+#endif
+    /* KIND must stay at this position in the structure to maintain
+       binary compatibility.  */
+    int __kind;
+#if _RISCV_SIM == _ABI64
+    int __spins;
+    __pthread_list_t __list;
+# define __PTHREAD_MUTEX_HAVE_PREV	1
+#else
+    unsigned int __nusers;
+    __extension__ union
+    {
+      int __spins;
+      __pthread_slist_t __list;
+    };
+#endif
+  } __data;
+  char __size[__SIZEOF_PTHREAD_MUTEX_T];
+  long int __align;
+} pthread_mutex_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_MUTEXATTR_T];
+  int __align;
+} pthread_mutexattr_t;
+
+
+/* Data structure for conditional variable handling.  The structure of
+   the attribute type is deliberately not exposed.  */
+typedef union
+{
+  struct
+  {
+    int __lock;
+    unsigned int __futex;
+    __extension__ unsigned long long int __total_seq;
+    __extension__ unsigned long long int __wakeup_seq;
+    __extension__ unsigned long long int __woken_seq;
+    void *__mutex;
+    unsigned int __nwaiters;
+    unsigned int __broadcast_seq;
+  } __data;
+  char __size[__SIZEOF_PTHREAD_COND_T];
+  __extension__ long long int __align;
+} pthread_cond_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_CONDATTR_T];
+  int __align;
+} pthread_condattr_t;
+
+
+/* Keys for thread-specific data */
+typedef unsigned int pthread_key_t;
+
+
+/* Once-only execution */
+typedef int pthread_once_t;
+
+
+#if defined __USE_UNIX98 || defined __USE_XOPEN2K
+/* Data structure for read-write lock variable handling.  The
+   structure of the attribute type is deliberately not exposed.  */
+typedef union
+{
+# if _RISCV_SIM == _ABI64
+  struct
+  {
+    int __lock;
+    unsigned int __nr_readers;
+    unsigned int __readers_wakeup;
+    unsigned int __writer_wakeup;
+    unsigned int __nr_readers_queued;
+    unsigned int __nr_writers_queued;
+    int __writer;
+    int __shared;
+    unsigned long int __pad1;
+    unsigned long int __pad2;
+    /* FLAGS must stay at this position in the structure to maintain
+       binary compatibility.  */
+    unsigned int __flags;
+  } __data;
+# else
+  struct
+  {
+    int __lock;
+    unsigned int __nr_readers;
+    unsigned int __readers_wakeup;
+    unsigned int __writer_wakeup;
+    unsigned int __nr_readers_queued;
+    unsigned int __nr_writers_queued;
+#if __BYTE_ORDER == __BIG_ENDIAN
+    unsigned char __pad1;
+    unsigned char __pad2;
+    unsigned char __shared;
+    /* FLAGS must stay at this position in the structure to maintain
+       binary compatibility.  */
+    unsigned char __flags;
+#else
+    /* FLAGS must stay at this position in the structure to maintain
+       binary compatibility.  */
+    unsigned char __flags;
+    unsigned char __shared;
+    unsigned char __pad1;
+    unsigned char __pad2;
+#endif
+    int __writer;
+  } __data;
+# endif
+  char __size[__SIZEOF_PTHREAD_RWLOCK_T];
+  long int __align;
+} pthread_rwlock_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_RWLOCKATTR_T];
+  long int __align;
+} pthread_rwlockattr_t;
+#endif
+
+
+#ifdef __USE_XOPEN2K
+/* POSIX spinlock data type.  */
+typedef volatile int pthread_spinlock_t;
+
+
+/* POSIX barriers data type.  The structure of the type is
+   deliberately not exposed.  */
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_BARRIER_T];
+  long int __align;
+} pthread_barrier_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_BARRIERATTR_T];
+  int __align;
+} pthread_barrierattr_t;
+#endif
+
+
+#endif	/* bits/pthreadtypes.h */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/nptl/bits/semaphore.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/bits/semaphore.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/nptl/bits/semaphore.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/bits/semaphore.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,37 @@
+/* Copyright (C) 2002, 2005, 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SEMAPHORE_H
+# error "Never use <bits/semaphore.h> directly; include <semaphore.h> instead."
+#endif
+
+#if _RISCV_SIM == _ABI64
+# define __SIZEOF_SEM_T	32
+#else
+# define __SIZEOF_SEM_T	16
+#endif
+
+/* Value returned if `sem_open' failed.  */
+#define SEM_FAILED      ((sem_t *) 0)
+
+
+typedef union
+{
+  char __size[__SIZEOF_SEM_T];
+  long int __align;
+} sem_t;
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/nptl/clone.S glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/clone.S
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/nptl/clone.S	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/clone.S	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,2 @@
+#define RESET_PID
+#include <sysdeps/unix/sysv/linux/riscv/clone.S>
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/nptl/createthread.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/createthread.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/nptl/createthread.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/createthread.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,24 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Value passed to 'clone' for initialization of the thread register.  */
+#define TLS_VALUE ((void *) (pd) \
+		   + TLS_TCB_OFFSET + TLS_PRE_TCB_SIZE)
+
+/* Get the real implementation.	 */
+#include <nptl/sysdeps/pthread/createthread.c>
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/nptl/fork.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/fork.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/nptl/fork.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/fork.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/fork.c>
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/nptl/lowlevellock.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/lowlevellock.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/nptl/lowlevellock.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/lowlevellock.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,293 @@
+/* Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008,
+   2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _LOWLEVELLOCK_H
+#define _LOWLEVELLOCK_H	1
+
+#include <time.h>
+#include <sys/param.h>
+#include <bits/pthreadtypes.h>
+#include <atomic.h>
+#include <sysdep.h>
+#include <kernel-features.h>
+
+#define FUTEX_WAIT		0
+#define FUTEX_WAKE		1
+#define FUTEX_REQUEUE		3
+#define FUTEX_CMP_REQUEUE	4
+#define FUTEX_WAKE_OP		5
+#define FUTEX_OP_CLEAR_WAKE_IF_GT_ONE	((4 << 24) | 1)
+#define FUTEX_LOCK_PI		6
+#define FUTEX_UNLOCK_PI		7
+#define FUTEX_TRYLOCK_PI	8
+#define FUTEX_WAIT_BITSET	9
+#define FUTEX_WAKE_BITSET	10
+#define FUTEX_PRIVATE_FLAG	128
+#define FUTEX_CLOCK_REALTIME	256
+
+#define FUTEX_BITSET_MATCH_ANY	0xffffffff
+
+/* Values for 'private' parameter of locking macros.  Yes, the
+   definition seems to be backwards.  But it is not.  The bit will be
+   reversed before passing to the system call.  */
+#define LLL_PRIVATE	0
+#define LLL_SHARED	FUTEX_PRIVATE_FLAG
+
+
+#if !defined NOT_IN_libc || defined IS_IN_rtld
+/* In libc.so or ld.so all futexes are private.  */
+# ifdef __ASSUME_PRIVATE_FUTEX
+#  define __lll_private_flag(fl, private) \
+  ((fl) | FUTEX_PRIVATE_FLAG)
+# else
+#  define __lll_private_flag(fl, private) \
+  ((fl) | THREAD_GETMEM (THREAD_SELF, header.private_futex))
+# endif
+#else
+# ifdef __ASSUME_PRIVATE_FUTEX
+#  define __lll_private_flag(fl, private) \
+  (((fl) | FUTEX_PRIVATE_FLAG) ^ (private))
+# else
+#  define __lll_private_flag(fl, private) \
+  (__builtin_constant_p (private)					      \
+   ? ((private) == 0							      \
+      ? ((fl) | THREAD_GETMEM (THREAD_SELF, header.private_futex))	      \
+      : (fl))								      \
+   : ((fl) | (((private) ^ FUTEX_PRIVATE_FLAG)				      \
+	      & THREAD_GETMEM (THREAD_SELF, header.private_futex))))
+# endif	      
+#endif
+
+
+#define lll_futex_wait(futexp, val, private) \
+  lll_futex_timed_wait(futexp, val, NULL, private)
+
+#define lll_futex_timed_wait(futexp, val, timespec, private) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 4, (long) (futexp),		      \
+			      __lll_private_flag (FUTEX_WAIT, private),	      \
+			      (val), (timespec));			      \
+    INTERNAL_SYSCALL_ERROR_P (__ret, __err) ? -__ret : __ret;		      \
+  })
+
+#define lll_futex_wake(futexp, nr, private) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 4, (long) (futexp),		      \
+			      __lll_private_flag (FUTEX_WAKE, private),	      \
+			      (nr), 0);	      \
+    INTERNAL_SYSCALL_ERROR_P (__ret, __err) ? -__ret : __ret;		      \
+  })
+
+#define lll_robust_dead(futexv, private) \
+  do									      \
+    {									      \
+      int *__futexp = &(futexv);					      \
+      atomic_or (__futexp, FUTEX_OWNER_DIED);				      \
+      lll_futex_wake (__futexp, 1, private);				      \
+    }									      \
+  while (0)
+
+/* Returns non-zero if error happened, zero if success.  */
+#define lll_futex_requeue(futexp, nr_wake, nr_move, mutex, val, private) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 6, (long) (futexp),		      \
+			      __lll_private_flag (FUTEX_CMP_REQUEUE, private),\
+			      (nr_wake), (nr_move), (mutex), (val));	      \
+    INTERNAL_SYSCALL_ERROR_P (__ret, __err);				      \
+  })
+
+/* Returns non-zero if error happened, zero if success.  */
+#define lll_futex_wake_unlock(futexp, nr_wake, nr_wake2, futexp2, private) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+									      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 6, (futexp),		      \
+			      __lll_private_flag (FUTEX_WAKE_OP, private),    \
+			      (nr_wake), (nr_wake2), (futexp2),		      \
+			      FUTEX_OP_CLEAR_WAKE_IF_GT_ONE);		      \
+    INTERNAL_SYSCALL_ERROR_P (__ret, __err);				      \
+  })
+
+static inline int
+__attribute__ ((always_inline))
+__lll_trylock (int *futex)
+{
+  return atomic_compare_and_exchange_val_24_acq (futex, 1, 0) != 0;
+}
+#define lll_trylock(futex) __lll_trylock (&(futex))
+
+static inline int
+__attribute__ ((always_inline))
+__lll_cond_trylock (int *futex)
+{
+  return atomic_compare_and_exchange_val_24_acq (futex, 2, 0) != 0;
+}
+#define lll_cond_trylock(futex) __lll_cond_trylock (&(futex))
+
+static inline int
+__attribute__ ((always_inline))
+__lll_robust_trylock (int *futex, int id)
+{
+  return atomic_compare_and_exchange_val_acq (futex, id, 0) != 0;
+}
+#define lll_robust_trylock(futex, id) \
+  __lll_robust_trylock (&(futex), id)
+
+
+extern void __lll_lock_wait_private (int *futex) attribute_hidden;
+extern void __lll_lock_wait (int *futex, int private) attribute_hidden;
+extern int __lll_robust_lock_wait (int *futex, int private) attribute_hidden;
+
+static inline void
+__attribute__ ((always_inline))
+__lll_lock (int *futex, int private)
+{
+  int val = atomic_compare_and_exchange_val_24_acq (futex, 1, 0);
+
+  if (__builtin_expect (val != 0, 0))
+    {
+      if (__builtin_constant_p (private) && private == LLL_PRIVATE)
+	__lll_lock_wait_private (futex);
+      else
+	__lll_lock_wait (futex, private);
+    }
+}
+#define lll_lock(futex, private) __lll_lock (&(futex), private)
+
+static inline int
+__attribute__ ((always_inline))
+__lll_robust_lock (int *futex, int id, int private)
+{
+  int result = 0;
+  if (atomic_compare_and_exchange_bool_acq (futex, id, 0) != 0)
+    result = __lll_robust_lock_wait (futex, private);
+  return result;
+}
+#define lll_robust_lock(futex, id, private) \
+  __lll_robust_lock (&(futex), id, private)
+
+static inline void
+__attribute__ ((always_inline))
+__lll_cond_lock (int *futex, int private)
+{
+  int val = atomic_compare_and_exchange_val_24_acq (futex, 2, 0);
+
+  if (__builtin_expect (val != 0, 0))
+    __lll_lock_wait (futex, private);
+}
+#define lll_cond_lock(futex, private) __lll_cond_lock (&(futex), private)
+
+#define lll_robust_cond_lock(futex, id, private) \
+  __lll_robust_lock (&(futex), (id) | FUTEX_WAITERS, private)
+
+
+extern int __lll_timedlock_wait (int *futex, const struct timespec *,
+				 int private) attribute_hidden;
+extern int __lll_robust_timedlock_wait (int *futex, const struct timespec *,
+					int private) attribute_hidden;
+
+static inline int
+__attribute__ ((always_inline))
+__lll_timedlock (int *futex, const struct timespec *abstime, int private)
+{
+  int val = atomic_compare_and_exchange_val_24_acq (futex, 1, 0);
+  int result = 0;
+
+  if (__builtin_expect (val != 0, 0))
+    result = __lll_timedlock_wait (futex, abstime, private);
+  return result;
+}
+#define lll_timedlock(futex, abstime, private) \
+  __lll_timedlock (&(futex), abstime, private)
+
+static inline int
+__attribute__ ((always_inline))
+__lll_robust_timedlock (int *futex, const struct timespec *abstime,
+			int id, int private)
+{
+  int result = 0;
+  if (atomic_compare_and_exchange_bool_acq (futex, id, 0) != 0)
+    result = __lll_robust_timedlock_wait (futex, abstime, private);
+  return result;
+}
+#define lll_robust_timedlock(futex, abstime, id, private) \
+  __lll_robust_timedlock (&(futex), abstime, id, private)
+
+#define lll_unlock(lock, private) \
+  ((void) ({								      \
+    int *__futex = &(lock);						      \
+    int __val = atomic_exchange_24_rel (__futex, 0);			      \
+    if (__builtin_expect (__val > 1, 0))				      \
+      lll_futex_wake (__futex, 1, private);				      \
+  }))
+
+#define lll_robust_unlock(lock, private) \
+  ((void) ({								      \
+    int *__futex = &(lock);						      \
+    int __val = atomic_exchange_rel (__futex, 0);			      \
+    if (__builtin_expect (__val & FUTEX_WAITERS, 0))			      \
+      lll_futex_wake (__futex, 1, private);				      \
+  }))
+
+#define lll_islocked(futex) \
+  (futex != 0)
+
+
+/* Our internal lock implementation is identical to the binary-compatible
+   mutex implementation. */
+
+/* Initializers for lock.  */
+#define LLL_LOCK_INITIALIZER		(0)
+#define LLL_LOCK_INITIALIZER_LOCKED	(1)
+
+/* The states of a lock are:
+    0  -  untaken
+    1  -  taken by one user
+   >1  -  taken by more users */
+
+/* The kernel notifies a process which uses CLONE_CLEARTID via futex
+   wakeup when the clone terminates.  The memory location contains the
+   thread ID while the clone is running and is reset to zero
+   afterwards.	*/
+#define lll_wait_tid(tid) \
+  do {							\
+    __typeof (tid) __tid;				\
+    while ((__tid = (tid)) != 0)			\
+      lll_futex_wait (&(tid), __tid, LLL_SHARED);	\
+  } while (0)
+
+extern int __lll_timedwait_tid (int *, const struct timespec *)
+     attribute_hidden;
+
+#define lll_timedwait_tid(tid, abstime) \
+  ({							\
+    int __res = 0;					\
+    if ((tid) != 0)					\
+      __res = __lll_timedwait_tid (&(tid), (abstime));	\
+    __res;						\
+  })
+
+#endif	/* lowlevellock.h */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/nptl/pt-vfork.S glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/pt-vfork.S
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/nptl/pt-vfork.S	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/pt-vfork.S	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,40 @@
+/* Copyright (C) 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <tls.h>
+#include "tcb-offsets.h"
+
+/* Save the PID value.  */
+#define SAVE_PID \
+	lui	t0, %hi(PID_OFFSET);                                   	\
+	add	t0, t0, tp;                                            	\
+	lw	a2, %lo(PID_OFFSET)(t0);/* Load the saved PID.  */	\
+	neg	a2, a2;		        /* Negate it.  */		\
+	sw	a2, %lo(PID_OFFSET)(t0);/* Store the temporary PID.  */
+
+/* Restore the old PID value in the parent.  */
+#define RESTORE_PID \
+	beqz	v0, 1f;			/* If we are the parent... */	\
+	lui	t0, %hi(PID_OFFSET);                                   	\
+	add	t0, t0, tp;                                            	\
+	lw	a2, %lo(PID_OFFSET)(t0);/* Load the saved PID.  */	\
+	neg	a2, a2;		        /* Re-negate it.  */		\
+	sw	a2, %lo(PID_OFFSET)(t0);/* Restore the PID.  */		\
+1:
+
+#include <sysdeps/unix/sysv/linux/riscv/vfork.S>
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/nptl/sysdep-cancel.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/sysdep-cancel.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/nptl/sysdep-cancel.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/sysdep-cancel.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,161 @@
+/* Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <sysdeps/generic/sysdep.h>
+#include <tls.h>
+#ifndef __ASSEMBLER__
+# include <nptl/pthreadP.h>
+#endif
+#include <sys/asm.h>
+
+/* Gas will put the initial save of $gp into the CIE, because it appears to
+   happen before any instructions.  So we use cfi_same_value instead of
+   cfi_restore.  */
+
+#if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
+
+#ifdef __PIC__
+# undef PSEUDO
+# define PSEUDO(name, syscall_name, args)				      \
+      .align 2;								      \
+  L(pseudo_start):							      \
+      cfi_startproc;							      \
+      cfi_adjust_cfa_offset (STKSPACE);					      \
+  99: RESTORESTK;							      \
+      PIC_J(__syscall_error);						      \
+  .type __##syscall_name##_nocancel, @function;				      \
+  .globl __##syscall_name##_nocancel;					      \
+  __##syscall_name##_nocancel:						      \
+    SAVESTK;								      \
+    li v0, SYS_ify(syscall_name);					      \
+    syscall;								      \
+    bnez a3, SYSCALL_ERROR_LABEL;			       		      \
+    RESTORESTK;								      \
+    ret;								      \
+  .size __##syscall_name##_nocancel,.-__##syscall_name##_nocancel;	      \
+  ENTRY (name)								      \
+    SAVESTK;								      \
+    SINGLE_THREAD_P(v1);						      \
+    bnez v1, L(pseudo_cancel);  					      \
+    li v0, SYS_ify(syscall_name);					      \
+    syscall;								      \
+    bnez a3, SYSCALL_ERROR_LABEL;			       		      \
+    RESTORESTK;								      \
+    ret;								      \
+  L(pseudo_cancel):							      \
+    cfi_adjust_cfa_offset (STKSPACE);					      \
+    REG_S ra, STKOFF_RA(sp);						      \
+    cfi_rel_offset (ra, STKOFF_RA);					      \
+      PUSHARGS_##args;			/* save syscall args */	      	      \
+      CENABLE;								      \
+      REG_S v0, STKOFF_SVMSK(sp);		/* save mask */			      \
+      POPARGS_##args;			/* restore syscall args */	      \
+      li v0, SYS_ify (syscall_name);				      	      \
+      syscall;								      \
+      REG_S v0, STKOFF_SC_V0(sp);		/* save syscall result */             \
+      REG_S a3, STKOFF_SC_ERR(sp);	/* save syscall error flag */	      \
+      REG_L a0, STKOFF_SVMSK(sp);		/* pass mask as arg1 */		      \
+      CDISABLE;								      \
+      REG_L a3, STKOFF_SC_ERR(sp);	/* restore syscall error flag */      \
+      REG_L ra, STKOFF_RA(sp);		/* restore return address */	      \
+      REG_L v0, STKOFF_SC_V0(sp);		/* restore syscall result */          \
+      bnez a3, SYSCALL_ERROR_LABEL;					      \
+      RESTORESTK;								      \
+    L(pseudo_end):
+
+
+  # undef PSEUDO_END
+  # define PSEUDO_END(sym) cfi_endproc; .end sym; .size sym,.-sym
+
+  #endif
+
+# define PUSHARGS_0	/* nothing to do */
+# define PUSHARGS_1	PUSHARGS_0 REG_S a0, STKOFF_A0(sp); cfi_rel_offset (a0, STKOFF_A0);
+# define PUSHARGS_2	PUSHARGS_1 REG_S a1, STKOFF_A1(sp); cfi_rel_offset (a1, STKOFF_A1);
+# define PUSHARGS_3	PUSHARGS_2 REG_S a2, STKOFF_A2(sp); cfi_rel_offset (a2, STKOFF_A2);
+# define PUSHARGS_4	PUSHARGS_3 REG_S a3, STKOFF_A3(sp); cfi_rel_offset (a3, STKOFF_A3);
+# define PUSHARGS_5	PUSHARGS_4 REG_S a4, STKOFF_A4(sp); cfi_rel_offset (a3, STKOFF_A4);
+# define PUSHARGS_6	PUSHARGS_5 REG_S a5, STKOFF_A5(sp); cfi_rel_offset (a3, STKOFF_A5);
+
+# define POPARGS_0	/* nothing to do */
+# define POPARGS_1	POPARGS_0 REG_L a0, STKOFF_A0(sp);
+# define POPARGS_2	POPARGS_1 REG_L a1, STKOFF_A1(sp);
+# define POPARGS_3	POPARGS_2 REG_L a2, STKOFF_A2(sp);
+# define POPARGS_4	POPARGS_3 REG_L a3, STKOFF_A3(sp);
+# define POPARGS_5	POPARGS_4 REG_L a4, STKOFF_A4(sp);
+# define POPARGS_6	POPARGS_5 REG_L a5, STKOFF_A5(sp);
+
+/* Save an even number of slots.  Should be 0 if an even number of slots
+   are used below, or SZREG if an odd number are used.  */
+# define STK_PAD	0
+
+/* Place values that we are more likely to use later in this sequence, i.e.
+   closer to the SP at function entry.  If you do that, the are more
+   likely to already be in your d-cache.  */
+# define STKOFF_A5	(STK_PAD)
+# define STKOFF_A4	(STKOFF_A5 + SZREG)
+# define STKOFF_A3	(STKOFF_A4 + SZREG)
+# define STKOFF_A2	(STKOFF_A3 + SZREG)	/* MT and more args.  */
+# define STKOFF_A1	(STKOFF_A2 + SZREG)	/* MT and 2 args.  */
+# define STKOFF_A0	(STKOFF_A1 + SZREG)	/* MT and 1 arg.  */
+# define STKOFF_RA	(STKOFF_A0 + SZREG)	/* Used if MT.  */
+# define STKOFF_SC_V0	(STKOFF_RA + SZREG)	/* Used if MT.  */
+# define STKOFF_SC_ERR	(STKOFF_SC_V0 + SZREG)	/* Used if MT.  */
+# define STKOFF_SVMSK	(STKOFF_SC_ERR + SZREG)	/* Used if MT.  */
+
+# define STKSPACE	(STKOFF_SVMSK + SZREG)
+# define SAVESTK 	addi sp, sp, -STKSPACE; cfi_adjust_cfa_offset(STKSPACE)
+# define RESTORESTK 	addi sp, sp, STKSPACE; cfi_adjust_cfa_offset(-STKSPACE)
+
+# ifdef IS_IN_libpthread
+#  define CENABLE  SETUP_GPX64(t6, t7); PIC_JAL(t6, __pthread_enable_asynccancel)
+#  define CDISABLE SETUP_GPX64(t6, t7); PIC_JAL(t6, __pthread_disable_asynccancel)
+# elif defined IS_IN_librt
+#  define CENABLE  SETUP_GPX64(t6, t7); PIC_JAL(t6, __librt_enable_asynccancel)
+#  define CDISABLE SETUP_GPX64(t6, t7); PIC_JAL(t6, __librt_disable_asynccancel)
+# else
+#  define CENABLE  SETUP_GPX64(t6, t7); PIC_JAL(t6, __libc_enable_asynccancel)
+#  define CDISABLE SETUP_GPX64(t6, t7); PIC_JAL(t6, __libc_disable_asynccancel)
+# endif
+
+# ifndef __ASSEMBLER__
+#  define SINGLE_THREAD_P						\
+	__builtin_expect (THREAD_GETMEM (THREAD_SELF,			\
+					 header.multiple_threads)	\
+			  == 0, 1)
+# else
+#  include "tcb-offsets.h"
+#  define SINGLE_THREAD_P(reg)						\
+	lui reg, %hi(MULTIPLE_THREADS_OFFSET);				\
+	add reg, reg, tp;                				\
+	lw reg, %lo(MULTIPLE_THREADS_OFFSET)(reg)
+#endif
+
+#elif !defined __ASSEMBLER__
+
+# define SINGLE_THREAD_P 1
+# define NO_CANCELLATION 1
+
+#endif
+
+#ifndef __ASSEMBLER__
+# define RTLD_SINGLE_THREAD_P \
+  __builtin_expect (THREAD_GETMEM (THREAD_SELF, \
+				   header.multiple_threads) == 0, 1)
+#endif
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/nptl/vfork.S glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/vfork.S
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/nptl/vfork.S	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/nptl/vfork.S	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,45 @@
+/* Copyright (C) 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <tls.h>
+#include "tcb-offsets.h"
+
+/* Save the PID value.  */
+#define SAVE_PID \
+	lui	t0, %hi(PID_OFFSET);                                   	\
+	add	t0, t0, tp;                                            	\
+	lw	a2, %lo(PID_OFFSET)(t0);/* Load the saved PID.  */	\
+	neg	a2, a2;		        /* Negate it.  */		\
+	bnez	a2, 1f;			/* If it was zero... */		\
+	li	a2, 0x80000000;		/* use 0x80000000 instead.  */	\
+1:	sw	a2, %lo(PID_OFFSET)(t0);/* Store the temporary PID.  */
+
+/* Restore the old PID value in the parent.  */
+#define RESTORE_PID \
+	beqz	v0, 1f;			/* If we are the parent... */	\
+	lui	t0, %hi(PID_OFFSET);                                   	\
+	add	t0, t0, tp;                                            	\
+	lw	a2, %lo(PID_OFFSET)(t0);/* Load the saved PID.  */	\
+	neg	a2, a2;		        /* Re-negate it.  */		\
+	li	a0, 0x80000000;		/* Load 0x80000000... */	\
+	bne	a2, a0, 2f;		/* ... compare against it... */	\
+	li	a2, 0;			/* ... use 0 instead.  */	\
+2:	sw	a2, %lo(PID_OFFSET)(t0);/* Restore the PID.  */		\
+1:
+
+#include <sysdeps/unix/sysv/linux/riscv/vfork.S>
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/pipe.S glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/pipe.S
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/pipe.S	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/pipe.S	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1 @@
+#include <sysdeps/unix/riscv/pipe.S>
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/pread64.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/pread64.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/pread64.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/pread64.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,107 @@
+/* Copyright (C) 1997, 1998, 2000, 2002, 2003, 2004
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#ifndef NO_SGIDEFS_H
+#include <sgidefs.h>
+#endif
+#include <unistd.h>
+#include <endian.h>
+
+#include <sysdep-cancel.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+#include <kernel-features.h>
+
+#ifdef __NR_pread64	     /* Newer kernels renamed but it's the same.  */
+# ifdef __NR_pread
+#  error "__NR_pread and __NR_pread64 both defined???"
+# endif
+# define __NR_pread __NR_pread64
+#endif
+
+#if defined __NR_pread || __ASSUME_PREAD_SYSCALL > 0
+
+# if __ASSUME_PREAD_SYSCALL == 0
+static ssize_t __emulate_pread64 (int fd, void *buf, size_t count,
+				  off64_t offset) internal_function;
+# endif
+
+ssize_t
+__libc_pread64 (fd, buf, count, offset)
+     int fd;
+     void *buf;
+     size_t count;
+     off64_t offset;
+{
+  ssize_t result;
+
+
+  if (SINGLE_THREAD_P)
+    {
+     /* First try the syscall.  */
+#if _RISCV_SIM == _ABIN32 || _RISCV_SIM == _ABI64
+      result = INLINE_SYSCALL (pread, 4, fd, CHECK_N (buf, count), count,
+			       offset);
+#else
+     result = INLINE_SYSCALL (pread, 6, fd, CHECK_N (buf, count), count, 0,
+			      __LONG_LONG_PAIR ((off_t) (offset >> 32),
+			      (off_t) (offset & 0xffffffff)));
+#endif
+# if __ASSUME_PREAD_SYSCALL == 0
+     if (result == -1 && errno == ENOSYS)
+     /* No system call available.  Use the emulation.  */
+     result = __emulate_pread64 (fd, buf, count, offset);
+# endif
+     return result;
+    }
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  /* First try the syscall.  */
+#if _RISCV_SIM == _ABIN32 || _RISCV_SIM == _ABI64
+  result = INLINE_SYSCALL (pread, 4, fd, CHECK_N (buf, count), count, offset);
+#else
+  result = INLINE_SYSCALL (pread, 6, fd, CHECK_N (buf, count), count, 0,
+			   __LONG_LONG_PAIR ((off_t) (offset >> 32),
+					     (off_t) (offset & 0xffffffff)));
+#endif
+# if __ASSUME_PREAD_SYSCALL == 0
+  if (result == -1 && errno == ENOSYS)
+    /* No system call available.  Use the emulation.  */
+    result = __emulate_pread64 (fd, buf, count, offset);
+# endif
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+
+weak_alias (__libc_pread64, __pread64)
+weak_alias (__libc_pread64, pread64)
+
+# define __libc_pread64(fd, buf, count, offset) \
+     static internal_function __emulate_pread64 (fd, buf, count, offset)
+#endif
+
+#if __ASSUME_PREAD_SYSCALL == 0
+# include <sysdeps/posix/pread64.c>
+#endif
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/pread.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/pread.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/pread.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/pread.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,109 @@
+/* Copyright (C) 1997, 1998, 2000, 2002, 2003, 2004
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <assert.h>
+#include <errno.h>
+#ifndef NO_SGIDEFS_H
+#include <sgidefs.h>
+#endif
+#include <unistd.h>
+#include <endian.h>
+
+#include <sysdep-cancel.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+#include <kernel-features.h>
+
+#ifdef __NR_pread64	     /* Newer kernels renamed but it's the same.  */
+# ifdef __NR_pread
+#  error "__NR_pread and __NR_pread64 both defined???"
+# endif
+# define __NR_pread __NR_pread64
+#endif
+
+#if defined __NR_pread || __ASSUME_PREAD_SYSCALL > 0
+
+# if __ASSUME_PREAD_SYSCALL == 0
+static ssize_t __emulate_pread (int fd, void *buf, size_t count,
+				off_t offset) internal_function;
+# endif
+
+ssize_t
+__libc_pread (fd, buf, count, offset)
+     int fd;
+     void *buf;
+     size_t count;
+     off_t offset;
+{
+  ssize_t result;
+
+#if _RISCV_SIM != _ABI64
+  assert (sizeof (offset) == 4);
+#endif
+
+  if (SINGLE_THREAD_P)
+    {
+      /* First try the syscall.  */
+#if _RISCV_SIM == _ABIN32 || _RISCV_SIM == _ABI64
+      result = INLINE_SYSCALL (pread, 4, fd, CHECK_N (buf, count), count,
+			       offset);
+#else
+      result = INLINE_SYSCALL (pread, 6, fd, CHECK_N (buf, count), count, 0,
+			       __LONG_LONG_PAIR (offset >> 31, offset));
+#endif
+# if __ASSUME_PREAD_SYSCALL == 0
+      if (result == -1 && errno == ENOSYS)
+	/* No system call available.  Use the emulation.  */
+	result = __emulate_pread (fd, buf, count, offset);
+# endif
+      return result;
+    }
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  /* First try the syscall.  */
+#if _RISCV_SIM == _ABIN32 || _RISCV_SIM == _ABI64
+  result = INLINE_SYSCALL (pread, 4, fd, CHECK_N (buf, count), count, offset);
+#else
+  result = INLINE_SYSCALL (pread, 6, fd, CHECK_N (buf, count), count, 0,
+			   __LONG_LONG_PAIR (offset >> 31, offset));
+#endif
+# if __ASSUME_PREAD_SYSCALL == 0
+  if (result == -1 && errno == ENOSYS)
+    /* No system call available.  Use the emulation.  */
+    result = __emulate_pread (fd, buf, count, offset);
+# endif
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+
+strong_alias (__libc_pread, __pread)
+weak_alias (__libc_pread, pread)
+
+# define __libc_pread(fd, buf, count, offset) \
+     static internal_function __emulate_pread (fd, buf, count, offset)
+#endif
+
+#if __ASSUME_PREAD_SYSCALL == 0
+# include <sysdeps/posix/pread.c>
+#endif
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/profil-counter.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/profil-counter.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/profil-counter.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/profil-counter.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,2 @@
+/* We can use the ix86 version.  */
+#include <sysdeps/unix/sysv/linux/i386/profil-counter.h>
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/pthread_once.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/pthread_once.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/pthread_once.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/pthread_once.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1 @@
+#include <nptl/sysdeps/unix/sysv/linux/sparc/pthread_once.c>
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/putmsg.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/putmsg.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/putmsg.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/putmsg.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/putmsg.c>
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/pwrite64.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/pwrite64.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/pwrite64.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/pwrite64.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,108 @@
+/* Copyright (C) 1997, 1998, 2000, 2002, 2003, 2004
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ralf Baechle <ralf@gnu.org>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#ifndef NO_SGIDEFS_H
+#include <sgidefs.h>
+#endif
+#include <unistd.h>
+#include <endian.h>
+
+#include <sysdep-cancel.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+#include <kernel-features.h>
+
+#ifdef __NR_pwrite64	    /* Newer kernels renamed but it's the same.  */
+# ifdef __NR_pwrite
+#  error "__NR_pwrite and __NR_pwrite64 both defined???"
+# endif
+# define __NR_pwrite __NR_pwrite64
+#endif
+
+#if defined __NR_pwrite || __ASSUME_PWRITE_SYSCALL > 0
+
+# if __ASSUME_PWRITE_SYSCALL == 0
+static ssize_t __emulate_pwrite64 (int fd, const void *buf, size_t count,
+				   off64_t offset) internal_function;
+# endif
+
+ssize_t
+__libc_pwrite64 (fd, buf, count, offset)
+     int fd;
+     const void *buf;
+     size_t count;
+     off64_t offset;
+{
+  ssize_t result;
+
+  if (SINGLE_THREAD_P)
+    {
+     /* First try the syscall.  */
+#if _RISCV_SIM == _ABIN32 || _RISCV_SIM == _ABI64
+      result = INLINE_SYSCALL (pwrite, 4, fd, CHECK_N (buf, count), count,
+			       offset);
+#else
+     result = INLINE_SYSCALL (pwrite, 6, fd, CHECK_N (buf, count), count, 0,
+			      __LONG_LONG_PAIR ((off_t) (offset >> 32),
+			     (off_t) (offset & 0xffffffff)));
+#endif
+# if __ASSUME_PWRITE_SYSCALL == 0
+     if (result == -1 && errno == ENOSYS)
+     /* No system call available.  Use the emulation.  */
+     result = __emulate_pwrite64 (fd, buf, count, offset);
+# endif
+
+     return result;
+    }
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  /* First try the syscall.  */
+#if _RISCV_SIM == _ABIN32 || _RISCV_SIM == _ABI64
+  result = INLINE_SYSCALL (pwrite, 4, fd, CHECK_N (buf, count), count, offset);
+#else
+  result = INLINE_SYSCALL (pwrite, 6, fd, CHECK_N (buf, count), count, 0,
+			   __LONG_LONG_PAIR ((off_t) (offset >> 32),
+					     (off_t) (offset & 0xffffffff)));
+#endif
+# if __ASSUME_PWRITE_SYSCALL == 0
+  if (result == -1 && errno == ENOSYS)
+    /* No system call available.  Use the emulation.  */
+    result = __emulate_pwrite64 (fd, buf, count, offset);
+# endif
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+
+weak_alias (__libc_pwrite64, __pwrite64)
+libc_hidden_weak (__pwrite64)
+weak_alias (__libc_pwrite64, pwrite64)
+
+# define __libc_pwrite64(fd, buf, count, offset) \
+     static internal_function __emulate_pwrite64 (fd, buf, count, offset)
+#endif
+
+#if __ASSUME_PWRITE_SYSCALL == 0
+# include <sysdeps/posix/pwrite64.c>
+#endif
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/pwrite.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/pwrite.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/pwrite.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/pwrite.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,109 @@
+/* Copyright (C) 1997, 1998, 2000, 2002, 2003, 2004
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <assert.h>
+#include <errno.h>
+#ifndef NO_SGIDEFS_H
+#include <sgidefs.h>
+#endif
+#include <unistd.h>
+#include <endian.h>
+
+#include <sysdep-cancel.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+#include <kernel-features.h>
+
+#ifdef __NR_pwrite64	    /* Newer kernels renamed but it's the same.  */
+# ifdef __NR_pwrite
+#  error "__NR_pwrite and __NR_pwrite64 both defined???"
+# endif
+# define __NR_pwrite __NR_pwrite64
+#endif
+
+#if defined __NR_pwrite || __ASSUME_PWRITE_SYSCALL > 0
+
+# if __ASSUME_PWRITE_SYSCALL == 0
+static ssize_t __emulate_pwrite (int fd, const void *buf, size_t count,
+				 off_t offset) internal_function;
+# endif
+
+ssize_t
+__libc_pwrite (fd, buf, count, offset)
+     int fd;
+     const void *buf;
+     size_t count;
+     off_t offset;
+{
+  ssize_t result;
+
+#if _RISCV_SIM != _ABI64
+  assert (sizeof (offset) == 4);
+#endif
+
+  if (SINGLE_THREAD_P)
+    {
+      /* First try the syscall.  */
+#if _RISCV_SIM == _ABIN32 || _RISCV_SIM == _ABI64
+      result = INLINE_SYSCALL (pwrite, 4, fd, CHECK_N (buf, count), count,
+			       offset);
+#else
+      result = INLINE_SYSCALL (pwrite, 6, fd, CHECK_N (buf, count), count, 0,
+			       __LONG_LONG_PAIR (offset >> 31, offset));
+#endif
+# if __ASSUME_PWRITE_SYSCALL == 0
+      if (result == -1 && errno == ENOSYS)
+	/* No system call available.  Use the emulation.  */
+	result = __emulate_pwrite (fd, buf, count, offset);
+# endif
+      return result;
+    }
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  /* First try the syscall.  */
+#if _RISCV_SIM == _ABIN32 || _RISCV_SIM == _ABI64
+  result = INLINE_SYSCALL (pwrite, 4, fd, CHECK_N (buf, count), count, offset);
+#else
+  result = INLINE_SYSCALL (pwrite, 6, fd, CHECK_N (buf, count), count, 0,
+			   __LONG_LONG_PAIR (offset >> 31, offset));
+#endif
+# if __ASSUME_PWRITE_SYSCALL == 0
+  if (result == -1 && errno == ENOSYS)
+    /* No system call available.  Use the emulation.  */
+    result = __emulate_pwrite (fd, buf, count, offset);
+# endif
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+
+strong_alias (__libc_pwrite, __pwrite)
+weak_alias (__libc_pwrite, pwrite)
+
+# define __libc_pwrite(fd, buf, count, offset) \
+     static internal_function __emulate_pwrite (fd, buf, count, offset)
+#endif
+
+#if __ASSUME_PWRITE_SYSCALL == 0
+# include <sysdeps/posix/pwrite.c>
+#endif
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/readelflib.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/readelflib.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/readelflib.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/readelflib.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,74 @@
+/* Copyright (C) 1999, 2001, 2002, 2003, 2005, 2009
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Alexandre Oliva <aoliva@redhat.com>
+   Based on work ../x86_64/readelflib.c,
+   contributed by Andreas Jaeger <aj@suse.de>, 1999 and
+		  Jakub Jelinek <jakub@redhat.com>, 1999.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+
+int process_elf32_file (const char *file_name, const char *lib, int *flag,
+			unsigned int *osversion, char **soname,
+			void *file_contents, size_t file_length);
+int process_elf64_file (const char *file_name, const char *lib, int *flag,
+			unsigned int *osversion, char **soname,
+			void *file_contents, size_t file_length);
+
+/* Returns 0 if everything is ok, != 0 in case of error.  */
+int
+process_elf_file (const char *file_name, const char *lib, int *flag,
+		  unsigned int *osversion, char **soname, void *file_contents,
+		  size_t file_length)
+{
+  ElfW(Ehdr) *elf_header = (ElfW(Ehdr) *) file_contents;
+  int ret;
+
+  if (elf_header->e_ident [EI_CLASS] == ELFCLASS32)
+    {
+      Elf32_Ehdr *elf32_header = (Elf32_Ehdr *) elf_header;
+
+      ret = process_elf32_file (file_name, lib, flag, osversion, soname,
+				file_contents, file_length);
+
+      /* n32 libraries are always libc.so.6+.  */
+      if (!ret && (elf32_header->e_flags & EF_MIPS_ABI2) != 0)
+	*flag = FLAG_MIPS64_LIBN32|FLAG_ELF_LIBC6;
+    }
+  else
+    {
+      ret = process_elf64_file (file_name, lib, flag, osversion, soname,
+				file_contents, file_length);
+      /* n64 libraries are always libc.so.6+.  */
+      if (!ret)
+	*flag = FLAG_MIPS64_LIBN64|FLAG_ELF_LIBC6;
+    }
+
+  return ret;
+}
+
+#undef __ELF_NATIVE_CLASS
+#undef process_elf_file
+#define process_elf_file process_elf32_file
+#define __ELF_NATIVE_CLASS 32
+#include "elf/readelflib.c"
+
+#undef __ELF_NATIVE_CLASS
+#undef process_elf_file
+#define process_elf_file process_elf64_file
+#define __ELF_NATIVE_CLASS 64
+#include "elf/readelflib.c"
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/register-dump.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/register-dump.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/register-dump.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/register-dump.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,105 @@
+/* Dump registers.
+   Copyright (C) 2000, 2001, 2002, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/uio.h>
+#include <stdio-common/_itoa.h>
+
+/* We will print the register dump in this format:
+
+ R0   XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX
+ R8   XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX
+ R16  XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX
+ R24  XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX
+	    pc       lo       hi
+      XXXXXXXX XXXXXXXX XXXXXXXX
+ The FPU registers will not be printed.
+*/
+
+static void
+hexvalue (unsigned long int value, char *buf, size_t len)
+{
+  char *cp = _itoa_word (value, buf + len, 16, 0);
+  while (cp > buf)
+    *--cp = '0';
+}
+
+static void
+register_dump (int fd, struct sigcontext *ctx)
+{
+  char regs[38][8];
+  struct iovec iov[38 * 2 + 10];
+  size_t nr = 0;
+  int i;
+
+#define ADD_STRING(str) \
+  iov[nr].iov_base = (char *) str;					      \
+  iov[nr].iov_len = strlen (str);					      \
+  ++nr
+#define ADD_MEM(str, len) \
+  iov[nr].iov_base = str;						      \
+  iov[nr].iov_len = len;						      \
+  ++nr
+
+  /* Generate strings of register contents.  */
+  for (i = 0; i < 32; i++)
+    hexvalue (ctx->sc_regs[i], regs[i], 8);
+  hexvalue (ctx->sc_pc, regs[32], 8);
+  hexvalue (ctx->sc_mdhi, regs[33], 8);
+  hexvalue (ctx->sc_mdlo, regs[34], 8);
+
+  /* Generate the output.  */
+  ADD_STRING ("Register dump:\n\n R0   ");
+  for (i = 0; i < 8; i++)
+    {
+      ADD_MEM (regs[i], 8);
+      ADD_STRING (" ");
+    }
+  ADD_STRING ("\n R8   ");
+  for (i = 8; i < 16; i++)
+    {
+      ADD_MEM (regs[i], 8);
+      ADD_STRING (" ");
+    }
+  ADD_STRING ("\n R16  ");
+  for (i = 16; i < 24; i++)
+    {
+      ADD_MEM (regs[i], 8);
+      ADD_STRING (" ");
+    }
+  ADD_STRING ("\n R24  ");
+  for (i = 24; i < 32; i++)
+    {
+      ADD_MEM (regs[i], 8);
+      ADD_STRING (" ");
+    }
+  ADD_STRING ("\n	    pc       lo       hi\n      ");
+  for (i = 32; i < 35; i++)
+    {
+      ADD_MEM (regs[i], 8);
+      ADD_STRING (" ");
+    }
+  ADD_STRING ("\n");
+
+  /* Write the stuff out.  */
+  writev (fd, iov, nr);
+}
+
+
+#define REGISTER_DUMP register_dump (fd, ctx)
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv32/accept4.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/accept4.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv32/accept4.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/accept4.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,32 @@
+/* Copyright (C) 2008, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Avoid accept4.c trying to use a definition based on the socketcall
+   syscall and internal_accept4.S.  */
+
+#include <errno.h>
+#include <signal.h>
+#include <sys/socket.h>
+
+#include <sysdep-cancel.h>
+#include <sys/syscall.h>
+#include <kernel-features.h>
+
+#undef __NR_socketcall
+
+#include <sysdeps/unix/sysv/linux/accept4.c>
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv32/fxstatat.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/fxstatat.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv32/fxstatat.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/fxstatat.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/fxstatat.c>
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv32/internal_accept4.S glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/internal_accept4.S
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv32/internal_accept4.S	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/internal_accept4.S	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,2 @@
+/* MIPS does not have socket.S and the socketcall syscall should
+   generally be avoided, though it exists.  */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv32/internal_recvmmsg.S glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/internal_recvmmsg.S
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv32/internal_recvmmsg.S	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/internal_recvmmsg.S	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,2 @@
+/* MIPS does not have socket.S and the socketcall syscall should
+   generally be avoided, though it exists.  */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv32/posix_fadvise64.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/posix_fadvise64.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv32/posix_fadvise64.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/posix_fadvise64.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,61 @@
+/* Copyright (C) 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <sysdep.h>
+
+/* Advice the system about the expected behaviour of the application with
+   respect to the file associated with FD.  */
+
+int
+__posix_fadvise64_l64 (int fd, off64_t offset, off64_t len, int advise)
+{
+/* MIPS kernel only has NR_fadvise64 which acts as NR_fadvise64_64 */
+#ifdef __NR_fadvise64
+  INTERNAL_SYSCALL_DECL (err);
+  int ret = INTERNAL_SYSCALL (fadvise64, err, 7, fd, 0,
+			      __LONG_LONG_PAIR ((long) (offset >> 32),
+						(long) offset),
+			      __LONG_LONG_PAIR ((long) (len >> 32),
+						(long) len),
+			      advise);
+  if (INTERNAL_SYSCALL_ERROR_P (ret, err))
+    return INTERNAL_SYSCALL_ERRNO (ret, err);
+  return 0;
+#else
+  return ENOSYS;
+#endif
+}
+
+#include <shlib-compat.h>
+
+#if SHLIB_COMPAT(libc, GLIBC_2_2, GLIBC_2_3_3)
+
+int
+attribute_compat_text_section
+__posix_fadvise64_l32 (int fd, off64_t offset, size_t len, int advise)
+{
+  return __posix_fadvise64_l64 (fd, offset, len, advise);
+}
+
+versioned_symbol (libc, __posix_fadvise64_l64, posix_fadvise64, GLIBC_2_3_3);
+compat_symbol (libc, __posix_fadvise64_l32, posix_fadvise64, GLIBC_2_2);
+#else
+strong_alias (__posix_fadvise64_l64, posix_fadvise64);
+#endif
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv32/posix_fadvise.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/posix_fadvise.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv32/posix_fadvise.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/posix_fadvise.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,42 @@
+/* Copyright (C) 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <sysdep.h>
+
+/* Advice the system about the expected behaviour of the application with
+   respect to the file associated with FD.  */
+
+int
+posix_fadvise (int fd, off_t offset, off_t len, int advise)
+{
+/* MIPS kernel only has NR_fadvise64 which acts as NR_fadvise64_64 */
+#ifdef __NR_fadvise64
+  INTERNAL_SYSCALL_DECL (err);
+  int ret = INTERNAL_SYSCALL (fadvise64, err, 7, fd, 0,
+			      __LONG_LONG_PAIR (offset >> 31, offset),
+			      __LONG_LONG_PAIR (len >> 31, len),
+			      advise);
+  if (INTERNAL_SYSCALL_ERROR_P (ret, err))
+    return INTERNAL_SYSCALL_ERRNO (ret, err);
+  return 0;
+#else
+  return ENOSYS;
+#endif
+}
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv32/readahead.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/readahead.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv32/readahead.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/readahead.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/arm/eabi/readahead.c>
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv32/recvmmsg.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/recvmmsg.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv32/recvmmsg.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/recvmmsg.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,31 @@
+/* Copyright (C) 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Avoid recvmmsg.c trying to use a definition based on the socketcall
+   syscall and internal_recvmmsg.S.  */
+
+#include <errno.h>
+#include <sys/socket.h>
+
+#include <sysdep-cancel.h>
+#include <sys/syscall.h>
+#include <kernel-features.h>
+
+#undef __NR_socketcall
+
+#include <sysdeps/unix/sysv/linux/recvmmsg.c>
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv32/sync_file_range.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/sync_file_range.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv32/sync_file_range.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/sync_file_range.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,47 @@
+/* Selective file content synch'ing.
+   Copyright (C) 2006, 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/types.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+
+
+#ifdef __NR_sync_file_range
+int
+sync_file_range (int fd, __off64_t from, __off64_t to, unsigned int flags)
+{
+  return INLINE_SYSCALL (sync_file_range, 7, fd, 0,
+			 __LONG_LONG_PAIR ((long) (from >> 32), (long) from),
+			 __LONG_LONG_PAIR ((long) (to >> 32), (long) to),
+			 flags);
+}
+#else
+int
+sync_file_range (int fd, __off64_t from, __off64_t to, unsigned int flags)
+{
+  __set_errno (ENOSYS);
+  return -1;
+}
+stub_warning (sync_file_range)
+
+# include <stub-tag.h>
+#endif
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv32/syscalls.list glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/syscalls.list
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv32/syscalls.list	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv32/syscalls.list	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,5 @@
+# File name	Caller	Syscall name	# args	Strong name	Weak names
+
+prlimit64	EXTRA	prlimit64	i:iipp	prlimit64
+
+fanotify_mark	EXTRA	fanotify_mark	i:iiiiis	fanotify_mark
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv64/configure glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/configure
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv64/configure	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/configure	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,4 @@
+# This file is generated from configure.in by Autoconf.  DO NOT EDIT!
+ # Local configure fragment for sysdeps/unix/sysv/linux/mips/mips64.
+
+ldd_rewrite_script=$dest/ldd-rewrite.sed
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv64/configure.in glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/configure.in
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv64/configure.in	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/configure.in	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,5 @@
+sinclude(./aclocal.m4)dnl Autoconf lossage
+GLIBC_PROVIDES dnl See aclocal.m4 in the top level source directory.
+# Local configure fragment for sysdeps/unix/sysv/linux/mips/mips64.
+
+ldd_rewrite_script=$dest/ldd-rewrite.sed
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv64/fallocate64.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/fallocate64.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv64/fallocate64.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/fallocate64.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1 @@
+/* fallocate64 is in fallocate.c */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv64/fallocate.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/fallocate.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv64/fallocate.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/fallocate.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/wordsize-64/fallocate.c>
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv64/fxstatat64.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/fxstatat64.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv64/fxstatat64.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/fxstatat64.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,113 @@
+/* Copyright (C) 2005,2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <kernel_stat.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+#include <kernel-features.h>
+
+#include <xstatconv.h>
+
+/* Get information about the file NAME in BUF.  */
+
+int
+__fxstatat64 (int vers, int fd, const char *file, struct stat64 *st, int flag)
+{
+  if (__builtin_expect (vers != _STAT_VER_LINUX, 0))
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  int result;
+  INTERNAL_SYSCALL_DECL (err);
+  struct kernel_stat kst;
+
+#ifdef __NR_newfstatat
+# ifndef __ASSUME_ATFCTS
+  if (__have_atfcts >= 0)
+# endif
+    {
+      result = INTERNAL_SYSCALL (newfstatat, err, 4, fd, file, &kst, flag);
+# ifndef __ASSUME_ATFCTS
+      if (__builtin_expect (INTERNAL_SYSCALL_ERROR_P (result, err), 1)
+	  && INTERNAL_SYSCALL_ERRNO (result, err) == ENOSYS)
+	__have_atfcts = -1;
+      else
+# endif
+	if (!__builtin_expect (INTERNAL_SYSCALL_ERROR_P (result, err), 1))
+	  return __xstat64_conv (vers, &kst, st);
+	else
+	  {
+	    __set_errno (INTERNAL_SYSCALL_ERRNO (result, err));
+	    return -1;
+	  }
+    }
+#endif
+
+#ifndef __ASSUME_ATFCTS
+  if (flag & ~AT_SYMLINK_NOFOLLOW)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  char *buf = NULL;
+
+  if (fd != AT_FDCWD && file[0] != '/')
+    {
+      size_t filelen = strlen (file);
+      static const char procfd[] = "/proc/self/fd/%d/%s";
+      /* Buffer for the path name we are going to use.  It consists of
+	 - the string /proc/self/fd/
+	 - the file descriptor number
+	 - the file name provided.
+	 The final NUL is included in the sizeof.   A bit of overhead
+	 due to the format elements compensates for possible negative
+	 numbers.  */
+      size_t buflen = sizeof (procfd) + sizeof (int) * 3 + filelen;
+      buf = alloca (buflen);
+
+      __snprintf (buf, buflen, procfd, fd, file);
+      file = buf;
+    }
+
+  if (flag & AT_SYMLINK_NOFOLLOW)
+    result = INTERNAL_SYSCALL (lstat, err, 2, CHECK_STRING (file),
+			       __ptrvalue (&kst));
+  else
+    result = INTERNAL_SYSCALL (stat, err, 2, CHECK_STRING (file),
+			       __ptrvalue (&kst));
+
+  if (__builtin_expect (!INTERNAL_SYSCALL_ERROR_P (result, err), 1))
+    return __xstat64_conv (vers, &kst, st);
+
+  __atfct_seterrno (INTERNAL_SYSCALL_ERRNO (result, err), fd, buf);
+  return -1;
+#endif
+}
+libc_hidden_def (__fxstatat64)
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv64/glob64.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/glob64.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv64/glob64.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/glob64.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1 @@
+/* glob64 is in glob.c */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv64/ldconfig.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/ldconfig.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv64/ldconfig.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/ldconfig.h	2011-11-07 20:23:06.000000000 -0800
@@ -0,0 +1,26 @@
+/* Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdeps/generic/ldconfig.h>
+
+#define SYSDEP_KNOWN_INTERPRETER_NAMES \
+  { "/lib32/ld.so.1", FLAG_ELF_LIBC6 }, \
+  { "/lib/ld.so.1", FLAG_ELF_LIBC6 },
+#define SYSDEP_KNOWN_LIBRARY_NAMES \
+  { "libc.so.6", FLAG_ELF_LIBC6 },	\
+  { "libm.so.6", FLAG_ELF_LIBC6 },
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv64/ldd-rewrite.sed glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/ldd-rewrite.sed
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv64/ldd-rewrite.sed	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/ldd-rewrite.sed	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1 @@
+s_^\(RTLDLIST=\)\(.*lib\)\(\|32\|64\)\(/[^/]*\.so\.[0-9.]*\)[ 	]*$_\1"\232\4 \264\4 \2\4"_
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv64/llseek.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/llseek.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv64/llseek.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/llseek.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1 @@
+/* lseek() is 64-bit capable already.  */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv64/Makefile glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/Makefile
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv64/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/Makefile	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,9 @@
+ifeq ($(subdir),socket)
+CFLAGS-recv.c += -fexceptions
+CFLAGS-send.c += -fexceptions
+endif
+
+ifeq ($(subdir),nptl)
+CFLAGS-recv.c += -fexceptions
+CFLAGS-send.c += -fexceptions
+endif
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv64/posix_fadvise64.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/posix_fadvise64.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv64/posix_fadvise64.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/posix_fadvise64.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1 @@
+/* posix_fadvise64 is in posix_fadvise.c */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv64/posix_fadvise.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/posix_fadvise.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv64/posix_fadvise.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/posix_fadvise.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/wordsize-64/posix_fadvise.c>
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv64/posix_fallocate64.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/posix_fallocate64.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv64/posix_fallocate64.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/posix_fallocate64.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1 @@
+/* posix_fallocate64 is in posix_fallocate.c */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv64/posix_fallocate.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/posix_fallocate.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv64/posix_fallocate.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/posix_fallocate.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/wordsize-64/posix_fallocate.c>
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv64/preadv64.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/preadv64.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv64/preadv64.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/preadv64.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1 @@
+/* Empty since the preadv syscall is equivalent.  */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv64/pwritev64.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/pwritev64.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv64/pwritev64.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/pwritev64.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1 @@
+/* Empty since the pwritev syscall is equivalent.  */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv64/syscalls.list glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/syscalls.list
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv64/syscalls.list	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/syscalls.list	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,17 @@
+# File name	Caller	Syscall name	Args	Strong name	Weak names
+
+lseek		-	lseek		Ci:iii	__libc_lseek	__lseek lseek __llseek llseek __libc_lseek64 __lseek64 lseek64
+prlimit		EXTRA	prlimit64	i:iipp	prlimit		prlimit64
+fanotify_mark	EXTRA	fanotify_mark	i:iiiis	fanotify_mark
+
+# Semaphore and shm system calls.  msgctl, shmctl, and semctl have C
+# wrappers (to set __IPC_64).
+msgget		-	msgget		i:ii	__msgget	msgget
+msgrcv		-	msgrcv		Ci:ibnii __msgrcv	msgrcv
+msgsnd		-	msgsnd		Ci:ibni	__msgsnd	msgsnd
+shmat		-	shmat		i:ipi	__shmat		shmat
+shmdt		-	shmdt		i:s	__shmdt		shmdt
+shmget		-	shmget		i:iii	__shmget	shmget
+semop		-	semop		i:ipi	__semop		semop
+semtimedop	-	semtimedop	i:ipip	semtimedop
+semget		-	semget		i:iii	__semget	semget
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv64/umount.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/umount.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/rv64/umount.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/rv64/umount.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,31 @@
+/* Copyright (C) 2000, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by David Huggins-Daines <dhd@debian.org>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Since we don't have an oldumount system call, do what the kernel
+   does down here.  */
+
+extern long int __umount2 (const char *name, int flags);
+
+long int
+__umount (const char *name)
+{
+  return __umount2 (name, 0);
+}
+
+weak_alias (__umount, umount);
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/setcontext.S glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/setcontext.S
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/setcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/setcontext.S	2011-11-02 01:26:08.000000000 -0700
@@ -0,0 +1,131 @@
+/* Set current context.
+   Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Maciej W. Rozycki <macro@codesourcery.com>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#include <sysdep.h>
+#include <sys/asm.h>
+
+#include "ucontext_i.h"
+
+/* int setcontext (const ucontext_t *ucp) */
+
+	.text
+LEAF (__setcontext)
+
+	addi    sp, sp, -SZREG
+	REG_S	a0, 0(sp)
+
+	/* Check for the magic flag.  */
+	li	v0, 1
+	REG_L	v1, (0 * SZREG + MCONTEXT_GREGS)(a0)	/* zero */
+	bne	v0, v1, 98f
+
+/* rt_sigprocmask (SIG_SETMASK, &ucp->uc_sigmask, NULL, _NSIG8) */
+	li	a3, _NSIG8
+	move	a2, zero
+	add     a1, a0, UCONTEXT_SIGMASK
+	li	a0, SIG_SETMASK
+
+	li	v0, SYS_ify (rt_sigprocmask)
+	syscall
+
+	REG_L   v0, 0(sp)
+	addi    sp, sp, SZREG
+	bnez	a3, 99f
+
+#ifdef __riscv_hard_float
+	lw	v1, MCONTEXT_FSR(v0)
+
+	fld	fs0, (20 * 8 + MCONTEXT_FPREGS)(v0)
+	fld	fs1, (21 * 8 + MCONTEXT_FPREGS)(v0)
+	fld	fs2, (22 * 8 + MCONTEXT_FPREGS)(v0)
+	fld	fs3, (23 * 8 + MCONTEXT_FPREGS)(v0)
+	fld	fs4, (24 * 8 + MCONTEXT_FPREGS)(v0)
+	fld	fs5, (25 * 8 + MCONTEXT_FPREGS)(v0)
+	fld	fs6, (26 * 8 + MCONTEXT_FPREGS)(v0)
+	fld	fs7, (27 * 8 + MCONTEXT_FPREGS)(v0)
+	fld	fs8, (28 * 8 + MCONTEXT_FPREGS)(v0)
+	fld	fs9, (29 * 8 + MCONTEXT_FPREGS)(v0)
+
+	mtfsr	v1
+#endif /* __mips_hard_float */
+
+	/* Note the contents of argument registers will be random
+	   unless makecontext() has been called.  */
+	REG_L	ra, (1 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	a0, (4 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	a1, (5 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	a2, (6 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	a3, (7 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	a4, (8 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	a5, (9 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	a6, (10 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	a7, (11 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	s0, (20 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	s1, (21 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	s2, (22 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	s3, (23 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	s4, (24 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	s5, (25 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	s6, (26 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	s7, (27 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	s8, (28 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	s9, (29 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	sp, (30 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	tp, (31 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	t7, MCONTEXT_PC(v0)
+	addi    sp, sp, SZREG
+
+	move	v0, zero
+	jr	t7
+
+98:
+	/* This is a context obtained from a signal handler.
+	   Perform a full restore by pushing the context
+	   passed onto a simulated signal frame on the stack
+	   and call the signal return syscall as if a signal
+	   handler exited normally.  */
+	addi    sp, sp, -((RT_SIGFRAME_SIZE + ALSZ) & ALMASK)
+
+	/* Only ucontext is referred to from rt_sigreturn,
+	   copy it.  */
+	addi    t1, sp, RT_SIGFRAME_UCONTEXT
+	li	t3, ((UCONTEXT_SIZE + SZREG - 1) / SZREG) - 1
+0:
+	REG_L	t2, (a0)
+	addi	t3, t3, -1
+	addi    t1, t1, SZREG
+	addi    a0, a0, SZREG
+	REG_S	t2, -SZREG(t1)
+	bgez	t3, 0b
+
+/* rt_sigreturn () -- no arguments, sp points to struct rt_sigframe.  */
+	li	v0, SYS_ify (rt_sigreturn)
+	syscall
+
+	/* Restore the stack and fall through to the error
+	   path.  Successful rt_sigreturn never returns to
+	   its calling place.  */
+	addi    sp, sp, ((RT_SIGFRAME_SIZE + ALSZ) & ALMASK)
+
+99:	PIC_J(__syscall_error)
+
+PSEUDO_END (__setcontext)
+
+weak_alias (__setcontext, setcontext)
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/sigaction.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sigaction.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/sigaction.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sigaction.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,192 @@
+/* Copyright (C) 1997,1998,1999,2000,2002,2003,2004,2006
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sgidefs.h>
+#include <signal.h>
+#include <string.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+
+#include <sgidefs.h>
+
+#include <kernel-features.h>
+
+/* The difference here is that the sigaction structure used in the
+   kernel is not the same as we use in the libc.  Therefore we must
+   translate it here.  */
+#include <kernel_sigaction.h>
+
+#if __ASSUME_REALTIME_SIGNALS == 0
+/* The variable is shared between all wrappers around signal handling
+   functions which have RT equivalents.	 This is the definition.  */
+int __libc_missing_rt_sigs;
+
+#endif
+
+#if _RISCV_SIM != _ABIO32
+
+# ifdef __NR_rt_sigreturn
+static void restore_rt (void) asm ("__restore_rt");
+# endif
+# ifdef __NR_sigreturn
+static void restore (void) asm ("__restore");
+# endif
+#endif
+
+/* If ACT is not NULL, change the action for SIG to *ACT.
+   If OACT is not NULL, put the old action for SIG in *OACT.  */
+int
+__libc_sigaction (sig, act, oact)
+     int sig;
+     const struct sigaction *act;
+     struct sigaction *oact;
+{
+#if __ASSUME_REALTIME_SIGNALS == 0
+  struct old_kernel_sigaction k_sigact, k_osigact;
+#endif
+  int result;
+
+#if defined __NR_rt_sigaction || __ASSUME_REALTIME_SIGNALS > 0
+  /* First try the RT signals.	*/
+# if __ASSUME_REALTIME_SIGNALS == 0
+  if (!__libc_missing_rt_sigs)
+# endif
+    {
+      struct kernel_sigaction kact, koact;
+      /* Save the current error value for later.  We need not do this
+	 if we are guaranteed to have realtime signals.	 */
+# if __ASSUME_REALTIME_SIGNALS == 0
+      int saved_errno = errno;
+# endif
+
+      if (act)
+	{
+	  kact.k_sa_handler = act->sa_handler;
+	  memcpy (&kact.sa_mask, &act->sa_mask, sizeof (kernel_sigset_t));
+	  kact.sa_flags = act->sa_flags;
+# ifdef HAVE_SA_RESTORER
+#  if _RISCV_SIM == _ABIO32
+	  kact.sa_restorer = act->sa_restorer;
+#  else
+	  kact.sa_restorer = &restore_rt;
+#  endif
+# endif
+	}
+
+      /* XXX The size argument hopefully will have to be changed to the
+	 real size of the user-level sigset_t.	*/
+      result = INLINE_SYSCALL (rt_sigaction, 4, sig,
+			       act ? __ptrvalue (&kact) : NULL,
+			       oact ? __ptrvalue (&koact) : NULL,
+			       sizeof (kernel_sigset_t));
+
+# if __ASSUME_REALTIME_SIGNALS == 0
+      if (result >= 0 || errno != ENOSYS)
+# endif
+	{
+	  if (oact && result >= 0)
+	    {
+	      oact->sa_handler = koact.k_sa_handler;
+	      memcpy (&oact->sa_mask, &koact.sa_mask,
+				sizeof (kernel_sigset_t));
+	      oact->sa_flags = koact.sa_flags;
+# ifdef HAVE_SA_RESTORER
+	      oact->sa_restorer = koact.sa_restorer;
+# endif
+	    }
+	  return result;
+	}
+
+# if __ASSUME_REALTIME_SIGNALS == 0
+      __set_errno (saved_errno);
+      __libc_missing_rt_sigs = 1;
+# endif
+    }
+#endif
+
+#if __ASSUME_REALTIME_SIGNALS == 0
+  if (act)
+    {
+      k_sigact.k_sa_handler = act->sa_handler;
+      k_sigact.sa_mask = act->sa_mask.__val[0];
+      k_sigact.sa_flags = act->sa_flags;
+# ifdef HAVE_SA_RESTORER
+      k_sigact.sa_restorer = act->sa_restorer;
+# endif
+    }
+  result = INLINE_SYSCALL (sigaction, 3, sig,
+			   act ? __ptrvalue (&k_sigact) : NULL,
+			   oact ? __ptrvalue (&k_osigact) : NULL);
+  if (oact && result >= 0)
+    {
+      oact->sa_handler = k_osigact.k_sa_handler;
+      oact->sa_mask.__val[0] = k_osigact.sa_mask;
+      oact->sa_flags = k_osigact.sa_flags;
+# ifdef HAVE_SA_RESTORER
+#  if _RISCV_SIM == _ABIO32
+      oact->sa_restorer = k_osigact.sa_restorer;
+#  else
+      oact->sa_restorer = &restore;
+#  endif
+# endif
+    }
+  return result;
+#endif
+}
+libc_hidden_def (__libc_sigaction)
+
+#ifdef WRAPPER_INCLUDE
+# include WRAPPER_INCLUDE
+#endif
+
+#ifndef LIBC_SIGACTION
+weak_alias (__libc_sigaction, __sigaction)
+libc_hidden_weak (__sigaction)
+weak_alias (__libc_sigaction, sigaction)
+#endif
+
+/* NOTE: Please think twice before making any changes to the bits of
+   code below.  GDB needs some intimate knowledge about it to
+   recognize them as signal trampolines, and make backtraces through
+   signal handlers work right.  Important are both the names
+   (__restore_rt) and the exact instruction sequence.
+   If you ever feel the need to make any changes, please notify the
+   appropriate GDB maintainer.  */
+
+#define RESTORE(name, syscall) RESTORE2 (name, syscall)
+#define RESTORE2(name, syscall) \
+asm						\
+  (						\
+   ".align 4\n"					\
+   "__" #name ":\n"				\
+   "	li v0, " #syscall "\n"			\
+   "	syscall\n"				\
+   );
+
+/* The return code for realtime-signals.  */
+#if _RISCV_SIM != _ABIO32
+# ifdef __NR_rt_sigreturn
+RESTORE (restore_rt, __NR_rt_sigreturn)
+# endif
+# ifdef __NR_sigreturn
+RESTORE (restore, __NR_sigreturn)
+# endif
+#endif
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/sigcontextinfo.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sigcontextinfo.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/sigcontextinfo.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sigcontextinfo.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,43 @@
+/* Copyright (C) 2000, 2001, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+
+#include <sgidefs.h>
+
+#if _RISCV_SIM == _ABIO32
+
+#define SIGCONTEXT unsigned long _code, struct sigcontext *
+#define SIGCONTEXT_EXTRA_ARGS _code,
+#define GET_PC(ctx)	((void *) ctx->sc_pc)
+#define GET_FRAME(ctx)	((void *) ctx->sc_regs[30])
+#define GET_STACK(ctx)	((void *) ctx->sc_regs[29])
+#define CALL_SIGHANDLER(handler, signo, ctx) \
+  (handler)((signo), SIGCONTEXT_EXTRA_ARGS (ctx))
+
+#else
+
+#define SIGCONTEXT unsigned long _code, ucontext_t *
+#define SIGCONTEXT_EXTRA_ARGS _code,
+#define GET_PC(ctx)	((void *) ctx->uc_mcontext.pc)
+#define GET_FRAME(ctx)	((void *) ctx->uc_mcontext.gregs[30])
+#define GET_STACK(ctx)	((void *) ctx->uc_mcontext.gregs[29])
+#define CALL_SIGHANDLER(handler, signo, ctx) \
+  (handler)((signo), SIGCONTEXT_EXTRA_ARGS (ctx))
+
+#endif
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/socket.S glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/socket.S
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/socket.S	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/socket.S	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,91 @@
+/* Copyright (C) 1997, 1998, 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Miguel de Icaza <miguel@gnu.ai.mit.edu>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep-cancel.h>
+#include <socketcall.h>
+
+#define P(a, b) P2(a, b)
+#define P2(a, b) a##b
+
+#ifndef NARGS
+#ifdef socket
+#error NARGS not defined
+#endif
+#define NARGS 3
+#endif
+
+	.text
+/* The socket-oriented system calls are handled unusually in Linux.
+   They are all gated through the single `socketcall' system call number.
+   `socketcall' takes two arguments: the first is the subcode, specifying
+   which socket function is being called; and the second is a pointer to
+   the arguments to the specific function.
+
+   The .S files for the other calls just #define socket and #include this.  */
+
+#ifndef __socket
+# ifndef NO_WEAK_ALIAS
+#  define __socket P(__,socket)
+# else
+#  define __socket socket
+# endif
+#endif
+
+LEAF (__socket)
+
+	addi  sp, sp, -SZREG*NARGS
+
+	REG_S a0, 0*SZREG(sp)
+	REG_S a1, 1*SZREG(sp)
+#if NARGS > 2
+	REG_S a2, 2*SZREG(sp)
+#if NARGS > 3
+	REG_S a3, 3*SZREG(sp)
+#if NARGS > 4
+	REG_S a4, 4*SZREG(sp)
+#if NARGS > 5
+	REG_S a5, 5*SZREG(sp)
+#endif
+#endif
+#endif
+#endif
+
+#if defined NEED_CANCELLATION && defined CENABLE
+	SINGLE_THREAD_P(t0)
+	bnez  t0, 1f
+#endif
+	li    a0, P(SOCKOP_,socket)   /* arg 1: socket subfunction */
+	move  a1, sp			/* arg 2: parameter block */
+	li    v0, SYS_ify (rt_sigprocmask)
+	syscall
+
+	addi  sp, sp, SZREG*NARGS
+	bnez	a3, 99f
+
+#if defined NEED_CANCELLATION && defined CENABLE
+1:unimp
+#endif
+
+99: PIC_J(__syscall_error)
+
+END (__socket)
+
+#ifndef NO_WEAK_ALIAS
+weak_alias (__socket, socket)
+#endif
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/__start_context.S glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/__start_context.S
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/__start_context.S	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/__start_context.S	2011-10-27 22:24:01.000000000 -0700
@@ -0,0 +1,39 @@
+/* Modify saved context.
+   Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Maciej W. Rozycki <macro@codesourcery.com>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#include <sysdep.h>
+#include <sys/asm.h>
+
+#include "ucontext_i.h"
+
+	.text
+LEAF (__start_context)
+	SETUP_GP64(s8, __start_context)
+	move	a0, zero
+	beqz	s0, 1f
+
+	/* setcontext (ucp) */
+	move	a0, s0
+	PIC_JAL(s8, __setcontext)
+	move	a0, v0
+
+1:	PIC_JAL(s8, HIDDEN_JUMPTARGET (exit))
+
+PSEUDO_END (__start_context)
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/swapcontext.S glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/swapcontext.S
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/swapcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/swapcontext.S	2011-11-02 01:25:30.000000000 -0700
@@ -0,0 +1,131 @@
+/* Save and set current context.
+   Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Maciej W. Rozycki <macro@codesourcery.com>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#include <sysdep.h>
+#include <sys/asm.h>
+
+#include "ucontext_i.h"
+
+/* int swapcontext (ucontext_t *oucp, const ucontext_t *ucp) */
+
+LEAF (__swapcontext)
+	/* Store a magic flag.	*/
+	li	v1, 1
+	REG_S	v1, ( 0 * SZREG + MCONTEXT_GREGS)(a0)	/* zero */
+
+	REG_S	ra, MCONTEXT_PC(a0)
+	REG_S	ra, ( 1 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s0, (20 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s1, (21 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s2, (22 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s3, (23 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s4, (24 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s5, (25 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s6, (26 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s7, (27 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s8, (28 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s9, (29 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	sp, (30 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	tp, (31 * SZREG + MCONTEXT_GREGS)(a0)
+
+#ifdef __riscv_hard_float
+  mffsr v1
+
+	fsd	fs0, (20 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs1, (21 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs2, (22 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs3, (23 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs4, (24 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs5, (25 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs6, (26 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs7, (27 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs8, (28 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs9, (29 * 8 + MCONTEXT_FPREGS)(a0)
+
+	sw	v1, MCONTEXT_FSR(a0)
+#endif /* __mips_hard_float */
+
+	addi    sp, sp, -SZREG
+	REG_S	a1, 0(sp)
+
+/* rt_sigprocmask (SIG_SETMASK, &ucp->uc_sigmask, NULL, _NSIG8) */
+	li	a3, _NSIG8
+	add	a2, a0, UCONTEXT_SIGMASK
+	add     a1, a1, UCONTEXT_SIGMASK
+	li	a0, SIG_SETMASK
+
+	li	v0, SYS_ify (rt_sigprocmask)
+	syscall
+
+	REG_L   v0, 0(sp)
+	addi    sp, sp, SZREG
+	bnez	a3, 99f
+
+#ifdef __riscv_hard_float
+	lw	v1, MCONTEXT_FSR(v0)
+
+	fld	fs0, (20 * 8 + MCONTEXT_FPREGS)(v0)
+	fld	fs1, (21 * 8 + MCONTEXT_FPREGS)(v0)
+	fld	fs2, (22 * 8 + MCONTEXT_FPREGS)(v0)
+	fld	fs3, (23 * 8 + MCONTEXT_FPREGS)(v0)
+	fld	fs4, (24 * 8 + MCONTEXT_FPREGS)(v0)
+	fld	fs5, (25 * 8 + MCONTEXT_FPREGS)(v0)
+	fld	fs6, (26 * 8 + MCONTEXT_FPREGS)(v0)
+	fld	fs7, (27 * 8 + MCONTEXT_FPREGS)(v0)
+	fld	fs8, (28 * 8 + MCONTEXT_FPREGS)(v0)
+	fld	fs9, (29 * 8 + MCONTEXT_FPREGS)(v0)
+
+	mtfsr	v1
+#endif /* __mips_hard_float */
+
+	/* Note the contents of argument registers will be random
+	   unless makecontext() has been called.  */
+	REG_L	ra, (1 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	a0, (4 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	a1, (5 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	a2, (6 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	a3, (7 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	a4, (8 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	a5, (9 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	a6, (10 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	a7, (11 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	s0, (20 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	s1, (21 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	s2, (22 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	s3, (23 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	s4, (24 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	s5, (25 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	s6, (26 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	s7, (27 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	s8, (28 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	s9, (29 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	sp, (30 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	tp, (31 * SZREG + MCONTEXT_GREGS)(v0)
+	REG_L	t7, MCONTEXT_PC(v0)
+	addi    sp, sp, SZREG
+
+	move	v0, zero
+	jr	t7
+
+99:	PIC_J(__syscall_error)
+
+PSEUDO_END (__swapcontext)
+
+weak_alias (__swapcontext, swapcontext)
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/sys/cachectl.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/cachectl.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/sys/cachectl.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/cachectl.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,42 @@
+/* Copyright (C) 1995, 1996, 1997, 2000, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_CACHECTL_H
+#define _SYS_CACHECTL_H 1
+
+#include <features.h>
+
+/*
+ * Get the kernel definition for the op bits.
+ */
+#include <asm/cachectl.h>
+
+__BEGIN_DECLS
+
+#ifdef __USE_MISC
+extern int cachectl (void *__addr, __const int __nbytes, __const int __op) __THROW;
+#endif
+extern int __cachectl (void *__addr, __const int __nbytes, __const int __op) __THROW;
+#ifdef __USE_MISC
+extern int cacheflush (void *__addr, __const int __nbytes, __const int __op) __THROW;
+#endif
+extern int _flush_cache (char *__addr, __const int __nbytes, __const int __op) __THROW;
+
+__END_DECLS
+
+#endif /* sys/cachectl.h */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/sys/epoll.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/epoll.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/sys/epoll.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/epoll.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,144 @@
+/* Copyright (C) 2002-2006, 2007, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_SYS_EPOLL_H
+#define	_SYS_EPOLL_H	1
+
+#include <stdint.h>
+#include <sys/types.h>
+
+/* Get __sigset_t.  */
+#include <bits/sigset.h>
+
+#ifndef __sigset_t_defined
+# define __sigset_t_defined
+typedef __sigset_t sigset_t;
+#endif
+
+
+/* Flags to be passed to epoll_create1.  */
+enum
+  {
+    EPOLL_CLOEXEC = 02000000,
+#define EPOLL_CLOEXEC EPOLL_CLOEXEC
+    EPOLL_NONBLOCK = 0200
+#define EPOLL_NONBLOCK EPOLL_NONBLOCK
+  };
+
+
+enum EPOLL_EVENTS
+  {
+    EPOLLIN = 0x001,
+#define EPOLLIN EPOLLIN
+    EPOLLPRI = 0x002,
+#define EPOLLPRI EPOLLPRI
+    EPOLLOUT = 0x004,
+#define EPOLLOUT EPOLLOUT
+    EPOLLRDNORM = 0x040,
+#define EPOLLRDNORM EPOLLRDNORM
+    EPOLLRDBAND = 0x080,
+#define EPOLLRDBAND EPOLLRDBAND
+    EPOLLWRNORM = 0x100,
+#define EPOLLWRNORM EPOLLWRNORM
+    EPOLLWRBAND = 0x200,
+#define EPOLLWRBAND EPOLLWRBAND
+    EPOLLMSG = 0x400,
+#define EPOLLMSG EPOLLMSG
+    EPOLLERR = 0x008,
+#define EPOLLERR EPOLLERR
+    EPOLLHUP = 0x010,
+#define EPOLLHUP EPOLLHUP
+    EPOLLRDHUP = 0x2000,
+#define EPOLLRDHUP EPOLLRDHUP
+    EPOLLONESHOT = (1 << 30),
+#define EPOLLONESHOT EPOLLONESHOT
+    EPOLLET = (1 << 31)
+#define EPOLLET EPOLLET
+  };
+
+
+/* Valid opcodes ( "op" parameter ) to issue to epoll_ctl().  */
+#define EPOLL_CTL_ADD 1	/* Add a file descriptor to the interface.  */
+#define EPOLL_CTL_DEL 2	/* Remove a file descriptor from the interface.  */
+#define EPOLL_CTL_MOD 3	/* Change file descriptor epoll_event structure.  */
+
+
+typedef union epoll_data
+{
+  void *ptr;
+  int fd;
+  uint32_t u32;
+  uint64_t u64;
+} epoll_data_t;
+
+struct epoll_event
+{
+  uint32_t events;	/* Epoll events */
+  epoll_data_t data;	/* User data variable */
+};
+
+
+__BEGIN_DECLS
+
+/* Creates an epoll instance.  Returns an fd for the new instance.
+   The "size" parameter is a hint specifying the number of file
+   descriptors to be associated with the new instance.  The fd
+   returned by epoll_create() should be closed with close().  */
+extern int epoll_create (int __size) __THROW;
+
+/* Same as epoll_create but with an FLAGS parameter.  The unused SIZE
+   parameter has been dropped.  */
+extern int epoll_create1 (int __flags) __THROW;
+
+
+/* Manipulate an epoll instance "epfd". Returns 0 in case of success,
+   -1 in case of error ( the "errno" variable will contain the
+   specific error code ) The "op" parameter is one of the EPOLL_CTL_*
+   constants defined above. The "fd" parameter is the target of the
+   operation. The "event" parameter describes which events the caller
+   is interested in and any associated user data.  */
+extern int epoll_ctl (int __epfd, int __op, int __fd,
+		      struct epoll_event *__event) __THROW;
+
+
+/* Wait for events on an epoll instance "epfd". Returns the number of
+   triggered events returned in "events" buffer. Or -1 in case of
+   error with the "errno" variable set to the specific error code. The
+   "events" parameter is a buffer that will contain triggered
+   events. The "maxevents" is the maximum number of events to be
+   returned ( usually size of "events" ). The "timeout" parameter
+   specifies the maximum wait time in milliseconds (-1 == infinite).
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int epoll_wait (int __epfd, struct epoll_event *__events,
+		       int __maxevents, int __timeout);
+
+
+/* Same as epoll_wait, but the thread's signal mask is temporarily
+   and atomically replaced with the one provided as parameter.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int epoll_pwait (int __epfd, struct epoll_event *__events,
+			int __maxevents, int __timeout,
+			__const __sigset_t *__ss);
+
+__END_DECLS
+
+#endif /* sys/epoll.h */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/sys/eventfd.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/eventfd.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/sys/eventfd.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/eventfd.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,54 @@
+/* Copyright (C) 2007, 2008, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_SYS_EVENTFD_H
+#define	_SYS_EVENTFD_H	1
+
+#include <stdint.h>
+
+
+/* Type for event counter.  */
+typedef uint64_t eventfd_t;
+
+/* Flags for signalfd.  */
+enum
+  {
+    EFD_SEMAPHORE = 1,
+#define EFD_SEMAPHORE EFD_SEMAPHORE
+    EFD_CLOEXEC = 02000000,
+#define EFD_CLOEXEC EFD_CLOEXEC
+    EFD_NONBLOCK = 0200
+#define EFD_NONBLOCK EFD_NONBLOCK
+  };
+
+
+__BEGIN_DECLS
+
+/* Return file descriptor for generic event channel.  Set initial
+   value to COUNT.  */
+extern int eventfd (int __count, int __flags) __THROW;
+
+/* Read event counter and possibly wait for events.  */
+extern int eventfd_read (int __fd, eventfd_t *__value);
+
+/* Increment event counter.  */
+extern int eventfd_write (int __fd, eventfd_t __value);
+
+__END_DECLS
+
+#endif /* sys/eventfd.h */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/sys/inotify.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/inotify.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/sys/inotify.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/inotify.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,107 @@
+/* Copyright (C) 2005, 2006, 2008, 2009, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_SYS_INOTIFY_H
+#define	_SYS_INOTIFY_H	1
+
+#include <stdint.h>
+
+
+/* Flags for the parameter of inotify_init1.  */
+enum
+  {
+    IN_CLOEXEC = 02000000,
+#define IN_CLOEXEC IN_CLOEXEC
+    IN_NONBLOCK = 0200
+#define IN_NONBLOCK IN_NONBLOCK
+  };
+
+
+/* Structure describing an inotify event.  */
+struct inotify_event
+{
+  int wd;		/* Watch descriptor.  */
+  uint32_t mask;	/* Watch mask.  */
+  uint32_t cookie;	/* Cookie to synchronize two events.  */
+  uint32_t len;		/* Length (including NULs) of name.  */
+  char name __flexarr;	/* Name.  */
+};
+
+
+/* Supported events suitable for MASK parameter of INOTIFY_ADD_WATCH.  */
+#define IN_ACCESS	 0x00000001	/* File was accessed.  */
+#define IN_MODIFY	 0x00000002	/* File was modified.  */
+#define IN_ATTRIB	 0x00000004	/* Metadata changed.  */
+#define IN_CLOSE_WRITE	 0x00000008	/* Writtable file was closed.  */
+#define IN_CLOSE_NOWRITE 0x00000010	/* Unwrittable file closed.  */
+#define IN_CLOSE	 (IN_CLOSE_WRITE | IN_CLOSE_NOWRITE) /* Close.  */
+#define IN_OPEN		 0x00000020	/* File was opened.  */
+#define IN_MOVED_FROM	 0x00000040	/* File was moved from X.  */
+#define IN_MOVED_TO      0x00000080	/* File was moved to Y.  */
+#define IN_MOVE		 (IN_MOVED_FROM | IN_MOVED_TO) /* Moves.  */
+#define IN_CREATE	 0x00000100	/* Subfile was created.  */
+#define IN_DELETE	 0x00000200	/* Subfile was deleted.  */
+#define IN_DELETE_SELF	 0x00000400	/* Self was deleted.  */
+#define IN_MOVE_SELF	 0x00000800	/* Self was moved.  */
+
+/* Events sent by the kernel.  */
+#define IN_UNMOUNT	 0x00002000	/* Backing fs was unmounted.  */
+#define IN_Q_OVERFLOW	 0x00004000	/* Event queued overflowed.  */
+#define IN_IGNORED	 0x00008000	/* File was ignored.  */
+
+/* Helper events.  */
+#define IN_CLOSE	 (IN_CLOSE_WRITE | IN_CLOSE_NOWRITE)	/* Close.  */
+#define IN_MOVE		 (IN_MOVED_FROM | IN_MOVED_TO)		/* Moves.  */
+
+/* Special flags.  */
+#define IN_ONLYDIR	 0x01000000	/* Only watch the path if it is a
+					   directory.  */
+#define IN_DONT_FOLLOW	 0x02000000	/* Do not follow a sym link.  */
+#define IN_EXCL_UNLINK	 0x04000000	/* Exclude events on unlinked
+					   objects.  */
+#define IN_MASK_ADD	 0x20000000	/* Add to the mask of an already
+					   existing watch.  */
+#define IN_ISDIR	 0x40000000	/* Event occurred against dir.  */
+#define IN_ONESHOT	 0x80000000	/* Only send event once.  */
+
+/* All events which a program can wait on.  */
+#define IN_ALL_EVENTS	 (IN_ACCESS | IN_MODIFY | IN_ATTRIB | IN_CLOSE_WRITE  \
+			  | IN_CLOSE_NOWRITE | IN_OPEN | IN_MOVED_FROM	      \
+			  | IN_MOVED_TO | IN_CREATE | IN_DELETE		      \
+			  | IN_DELETE_SELF | IN_MOVE_SELF)
+
+
+__BEGIN_DECLS
+
+/* Create and initialize inotify instance.  */
+extern int inotify_init (void) __THROW;
+
+/* Create and initialize inotify instance.  */
+extern int inotify_init1 (int __flags) __THROW;
+
+/* Add watch of object NAME to inotify instance FD.  Notify about
+   events specified by MASK.  */
+extern int inotify_add_watch (int __fd, const char *__name, uint32_t __mask)
+  __THROW;
+
+/* Remove the watch specified by WD from the inotify instance FD.  */
+extern int inotify_rm_watch (int __fd, int __wd) __THROW;
+
+__END_DECLS
+
+#endif /* sys/inotify.h */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/sys/procfs.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/procfs.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/sys/procfs.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/procfs.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,128 @@
+/* Copyright (C) 1996, 1997, 1999, 2000, 2002, 2003, 2004
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_PROCFS_H
+#define _SYS_PROCFS_H	1
+
+/* This is somehow modelled after the file of the same name on SysVr4
+   systems.  It provides a definition of the core file format for ELF
+   used on Linux.  */
+
+#include <features.h>
+#include <sgidefs.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/user.h>
+#include <sgidefs.h>
+
+/* ELF register definitions */
+#define ELF_NGREG	45
+#define ELF_NFPREG	33
+
+#if _RISCV_SIM == _ABIN32
+__extension__ typedef unsigned long long elf_greg_t;
+#else
+typedef unsigned long elf_greg_t;
+#endif
+typedef elf_greg_t elf_gregset_t[ELF_NGREG];
+
+typedef double elf_fpreg_t;
+typedef elf_fpreg_t elf_fpregset_t[ELF_NFPREG];
+
+__BEGIN_DECLS
+
+struct elf_siginfo
+  {
+    int si_signo;			/* Signal number.  */
+    int si_code;			/* Extra code.  */
+    int si_errno;			/* Errno.  */
+  };
+
+
+/* Definitions to generate Intel SVR4-like core files.  These mostly
+   have the same names as the SVR4 types with "elf_" tacked on the
+   front to prevent clashes with linux definitions, and the typedef
+   forms have been avoided.  This is mostly like the SVR4 structure,
+   but more Linuxy, with things that Linux does not support and which
+   gdb doesn't really use excluded.  Fields present but not used are
+   marked with "XXX".  */
+struct elf_prstatus
+  {
+    struct elf_siginfo pr_info;		/* Info associated with signal.  */
+    short int pr_cursig;		/* Current signal.  */
+#if _RISCV_SIM == _ABIN32
+    __extension__ unsigned long long int pr_sigpend;
+    __extension__ unsigned long long int pr_sighold;
+#else
+    unsigned long int pr_sigpend;	/* Set of pending signals.  */
+    unsigned long int pr_sighold;	/* Set of held signals.  */
+#endif
+    __pid_t pr_pid;
+    __pid_t pr_ppid;
+    __pid_t pr_pgrp;
+    __pid_t pr_sid;
+    struct timeval pr_utime;		/* User time.  */
+    struct timeval pr_stime;		/* System time.  */
+    struct timeval pr_cutime;		/* Cumulative user time.  */
+    struct timeval pr_cstime;		/* Cumulative system time.  */
+    elf_gregset_t pr_reg;		/* GP registers.  */
+    int pr_fpvalid;			/* True if math copro being used.  */
+  };
+
+
+#define ELF_PRARGSZ     (80)    /* Number of chars for args */
+
+struct elf_prpsinfo
+  {
+    char pr_state;			/* Numeric process state.  */
+    char pr_sname;			/* Char for pr_state.  */
+    char pr_zomb;			/* Zombie.  */
+    char pr_nice;			/* Nice val.  */
+#if _RISCV_SIM == _ABIN32
+    __extension__ unsigned long long int pr_flag;
+#else
+    unsigned long int pr_flag;		/* Flags.  */
+#endif
+    long pr_uid;
+    long pr_gid;
+    int pr_pid, pr_ppid, pr_pgrp, pr_sid;
+    /* Lots missing */
+    char pr_fname[16];			/* Filename of executable.  */
+    char pr_psargs[ELF_PRARGSZ];	/* Initial part of arg list.  */
+  };
+
+
+/* Addresses.  */
+typedef void *psaddr_t;
+
+/* Register sets.  Linux has different names.  */
+typedef elf_gregset_t prgregset_t;
+typedef elf_fpregset_t prfpregset_t;
+
+/* We don't have any differences between processes and threads,
+   therefore habe only ine PID type.  */
+typedef __pid_t lwpid_t;
+
+
+typedef struct elf_prstatus prstatus_t;
+typedef struct elf_prpsinfo prpsinfo_t;
+
+__END_DECLS
+
+#endif	/* sys/procfs.h */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/sys/signalfd.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/signalfd.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/sys/signalfd.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/signalfd.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,66 @@
+/* Copyright (C) 2007, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_SYS_SIGNALFD_H
+#define	_SYS_SIGNALFD_H	1
+
+#define __need_sigset_t
+#include <signal.h>
+#include <stdint.h>
+
+
+struct signalfd_siginfo
+{
+  uint32_t ssi_signo;
+  int32_t ssi_errno;
+  int32_t ssi_code;
+  uint32_t ssi_pid;
+  uint32_t ssi_uid;
+  int32_t ssi_fd;
+  uint32_t ssi_tid;
+  uint32_t ssi_band;
+  uint32_t ssi_overrun;
+  uint32_t ssi_trapno;
+  int32_t ssi_status;
+  int32_t ssi_int;
+  uint64_t ssi_ptr;
+  uint64_t ssi_utime;
+  uint64_t ssi_stime;
+  uint64_t ssi_addr;
+  uint8_t __pad[48];
+};
+
+/* Flags for signalfd.  */
+enum
+  {
+    SFD_CLOEXEC = 02000000,
+#define SFD_CLOEXEC SFD_CLOEXEC
+    SFD_NONBLOCK = 0200
+#define SFD_NONBLOCK SFD_NONBLOCK
+  };
+
+__BEGIN_DECLS
+
+/* Request notification for delivery of signals in MASK to be
+   performed using descriptor FD.*/
+extern int signalfd (int __fd, const sigset_t *__mask, int __flags)
+  __THROW __nonnull ((2));
+
+__END_DECLS
+
+#endif /* sys/signalfd.h */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/sys/syscall.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/syscall.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/sys/syscall.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/syscall.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,35 @@
+/* Copyright (C) 1995, 1996, 1997, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYSCALL_H
+#define _SYSCALL_H	1
+
+/* This file should list the numbers of the system the system knows.
+   But instead of duplicating this we use the information available
+   from the kernel sources.  */
+#include <asm/unistd.h>
+
+#ifndef _LIBC
+/* The Linux kernel header file defines macros `__NR_<name>', but some
+   programs expect the traditional form `SYS_<name>'.  So in building libc
+   we scan the kernel's list and produce <bits/syscall.h> with macros for
+   all the `SYS_' names.  */
+# include <bits/syscall.h>
+#endif
+
+#endif
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/sys/sysmips.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/sysmips.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/sys/sysmips.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/sysmips.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,43 @@
+/* Copyright (C) 1995, 1997, 2000, 2001, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_SYSMIPS_H
+#define _SYS_SYSMIPS_H 1
+
+#include <features.h>
+
+/*
+ * Commands for the sysmips(2) call
+ *
+ * sysmips(2) is deprecated - though some existing software uses it.
+ * We only support the following commands.  Sysmips exists for compatibility
+ * purposes only so new software should avoid it.
+ */
+#define SETNAME                   1	/* set hostname                  */
+#define FLUSH_CACHE		   3	/* writeback and invalidate caches */
+#define MIPS_FIXADE               7	/* control address error fixing  */
+#define MIPS_RDNVRAM              10	/* read NVRAM			 */
+#define MIPS_ATOMIC_SET		2001	/* atomically set variable       */
+
+__BEGIN_DECLS
+
+extern int sysmips (__const int __cmd, ...) __THROW;
+
+__END_DECLS
+
+#endif /* sys/sysmips.h */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/sys/tas.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/tas.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/sys/tas.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/tas.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,51 @@
+/* Copyright (C) 2000, 2002, 2003, 2004, 2007, 2009
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Maciej W. Rozycki <macro@ds2.pg.gda.pl>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_TAS_H
+#define _SYS_TAS_H 1
+
+#include <features.h>
+#include <sgidefs.h>
+
+__BEGIN_DECLS
+
+extern int _test_and_set (int *__p, int __v) __THROW;
+
+#ifdef __USE_EXTERN_INLINES
+
+# ifndef _EXTERN_INLINE
+#  define _EXTERN_INLINE __extern_inline
+# endif
+
+_EXTERN_INLINE int
+__NTH (_test_and_set (int *__p, int __v))
+{
+  int __r = __sync_lock_test_and_set(__p, __v);
+
+  __sync_synchronize();
+
+  return __r;
+}
+
+#endif /* __USE_EXTERN_INLINES */
+
+__END_DECLS
+
+#endif /* sys/tas.h */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/sys/timerfd.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/timerfd.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/sys/timerfd.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/timerfd.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,60 @@
+/* Copyright (C) 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_SYS_TIMERFD_H
+#define	_SYS_TIMERFD_H	1
+
+#include <time.h>
+
+
+/* Bits to be set in the FLAGS parameter of `timerfd_create'.  */
+enum
+  {
+    TFD_CLOEXEC = 02000000,
+#define TFD_CLOEXEC TFD_CLOEXEC
+    TFD_NONBLOCK = 0200
+#define TFD_NONBLOCK TFD_NONBLOCK
+  };
+
+
+/* Bits to be set in the FLAGS parameter of `timerfd_settime'.  */
+enum
+  {
+    TFD_TIMER_ABSTIME = 1 << 0
+#define TFD_TIMER_ABSTIME TFD_TIMER_ABSTIME
+  };
+
+
+__BEGIN_DECLS
+
+/* Return file descriptor for new interval timer source.  */
+extern int timerfd_create (clockid_t __clock_id, int __flags) __THROW;
+
+/* Set next expiration time of interval timer source UFD to UTMR.  If
+   FLAGS has the TFD_TIMER_ABSTIME flag set the timeout value is
+   absolute.  Optionally return the old expiration time in OTMR.  */
+extern int timerfd_settime (int __ufd, int __flags,
+			    __const struct itimerspec *__utmr,
+			    struct itimerspec *__otmr) __THROW;
+
+/* Return the next expiration time of UFD.  */
+extern int timerfd_gettime (int __ufd, struct itimerspec *__otmr) __THROW;
+
+__END_DECLS
+
+#endif /* sys/timerfd.h */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/sys/ucontext.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/ucontext.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/sys/ucontext.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/ucontext.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,69 @@
+/* Copyright (C) 1997, 1998, 2000, 2003, 2004, 2006, 2009 Free Software
+   Foundation, Inc.  This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Don't rely on this, the interface is currently messed up and may need to
+   be broken to be fixed.  */
+#ifndef _SYS_UCONTEXT_H
+#define _SYS_UCONTEXT_H	1
+
+#include <features.h>
+#include <sgidefs.h>
+#include <signal.h>
+
+/* We need the signal context definitions even if they are not used
+   included in <signal.h>.  */
+#include <bits/sigcontext.h>
+
+/* Type for general register.  Even in o32 we assume 64-bit registers,
+   like the kernel.  */
+__extension__ typedef unsigned long long int greg_t;
+
+/* Number of general registers.  */
+#define NGREG	32
+#define NFPREG	32
+
+/* Container for all general registers.  */
+typedef greg_t gregset_t[NGREG];
+
+/* Container for all FPU registers.  */
+typedef double fpregset_t[NFPREG];
+
+
+/* Context to describe whole processor state.  */
+typedef struct
+  {
+    gregset_t gregs;
+    fpregset_t fpregs;
+    greg_t pc;
+    unsigned int fsr;
+    unsigned int used_math;
+    unsigned int dsp;
+    unsigned int reserved;
+  } mcontext_t;
+
+/* Userlevel context.  */
+typedef struct ucontext
+  {
+    unsigned long int uc_flags;
+    struct ucontext *uc_link;
+    stack_t uc_stack;
+    mcontext_t uc_mcontext;
+    __sigset_t uc_sigmask;
+  } ucontext_t;
+
+#endif /* sys/ucontext.h */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/sys/user.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/user.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/sys/user.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sys/user.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,219 @@
+/* Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_USER_H
+#define _SYS_USER_H	1
+
+#include <sgidefs.h>
+
+/* The whole purpose of this file is for GDB and GDB only.  Don't read
+   too much into it.  Don't use it for anything other than GDB unless
+   you know what you are doing.  */
+
+/* #include <asm/reg.h> */
+/* Instead of including the kernel header, that will vary depending on
+   whether the 32- or the 64-bit kernel is installed, we paste its
+   contents here.  Note that the fact that the file is inline here,
+   instead of included separately, doesn't change in any way the
+   licensing status of a program that includes user.h.  Since this is
+   for gdb alone, and gdb is GPLed, no surprises here.  */
+#if _RISCV_SIM == _ABIO32
+/*
+ * Various register offset definitions for debuggers, core file
+ * examiners and whatnot.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1995, 1999 by Ralf Baechle
+ */
+#ifndef __ASM_MIPS_REG_H
+#define __ASM_MIPS_REG_H
+
+/*
+ * This defines/structures correspond to the register layout on stack -
+ * if the order here is changed, it needs to be updated in
+ * include/asm-mips/stackframe.h
+ */
+#define EF_REG0			6
+#define EF_REG1			7
+#define EF_REG2			8
+#define EF_REG3			9
+#define EF_REG4			10
+#define EF_REG5			11
+#define EF_REG6			12
+#define EF_REG7			13
+#define EF_REG8			14
+#define EF_REG9			15
+#define EF_REG10		16
+#define EF_REG11		17
+#define EF_REG12		18
+#define EF_REG13		19
+#define EF_REG14		20
+#define EF_REG15		21
+#define EF_REG16		22
+#define EF_REG17		23
+#define EF_REG18		24
+#define EF_REG19		25
+#define EF_REG20		26
+#define EF_REG21		27
+#define EF_REG22		28
+#define EF_REG23		29
+#define EF_REG24		30
+#define EF_REG25		31
+/*
+ * k0/k1 unsaved
+ */
+#define EF_REG28		34
+#define EF_REG29		35
+#define EF_REG30		36
+#define EF_REG31		37
+
+/*
+ * Saved special registers
+ */
+#define EF_LO			38
+#define EF_HI			39
+
+#define EF_CP0_EPC		40
+#define EF_CP0_BADVADDR		41
+#define EF_CP0_STATUS		42
+#define EF_CP0_CAUSE		43
+
+#define EF_SIZE			180	/* size in bytes */
+
+#endif /* __ASM_MIPS_REG_H */
+
+#else /* _RISCV_SIM != _ABIO32 */
+
+/*
+ * Various register offset definitions for debuggers, core file
+ * examiners and whatnot.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1995, 1999 Ralf Baechle
+ * Copyright (C) 1995, 1999 Silicon Graphics
+ */
+#ifndef _ASM_REG_H
+#define _ASM_REG_H
+
+/*
+ * This defines/structures correspond to the register layout on stack -
+ * if the order here is changed, it needs to be updated in
+ * include/asm-mips/stackframe.h
+ */
+#define EF_REG0			 0
+#define EF_REG1			 1
+#define EF_REG2			 2
+#define EF_REG3			 3
+#define EF_REG4			 4
+#define EF_REG5			 5
+#define EF_REG6			 6
+#define EF_REG7			 7
+#define EF_REG8			 8
+#define EF_REG9			 9
+#define EF_REG10		10
+#define EF_REG11		11
+#define EF_REG12		12
+#define EF_REG13		13
+#define EF_REG14		14
+#define EF_REG15		15
+#define EF_REG16		16
+#define EF_REG17		17
+#define EF_REG18		18
+#define EF_REG19		19
+#define EF_REG20		20
+#define EF_REG21		21
+#define EF_REG22		22
+#define EF_REG23		23
+#define EF_REG24		24
+#define EF_REG25		25
+/*
+ * k0/k1 unsaved
+ */
+#define EF_REG28		28
+#define EF_REG29		29
+#define EF_REG30		30
+#define EF_REG31		31
+
+/*
+ * Saved special registers
+ */
+#define EF_LO			32
+#define EF_HI			33
+
+#define EF_CP0_EPC		34
+#define EF_CP0_BADVADDR		35
+#define EF_CP0_STATUS		36
+#define EF_CP0_CAUSE		37
+
+#define EF_SIZE			304	/* size in bytes */
+
+#endif /* _ASM_REG_H */
+
+#endif /* _RISCV_SIM != _ABIO32 */
+
+#if _RISCV_SIM == _ABIO32
+
+struct user
+{
+  unsigned long	regs[EF_SIZE/4+64];	/* integer and fp regs */
+  size_t	u_tsize;		/* text size (pages) */
+  size_t	u_dsize;		/* data size (pages) */
+  size_t	u_ssize;		/* stack size (pages) */
+  unsigned long	start_code;		/* text starting address */
+  unsigned long	start_data;		/* data starting address */
+  unsigned long	start_stack;		/* stack starting address */
+  long int	signal;			/* signal causing core dump */
+  void*		u_ar0;			/* help gdb find registers */
+  unsigned long	magic;			/* identifies a core file */
+  char		u_comm[32];		/* user command name */
+};
+
+#else
+
+struct user {
+  __extension__ unsigned long	regs[EF_SIZE/8+64]; /* integer and fp regs */
+  __extension__ unsigned long	u_tsize;	/* text size (pages) */
+  __extension__ unsigned long	u_dsize;	/* data size (pages) */
+  __extension__ unsigned long	u_ssize;	/* stack size (pages) */
+  __extension__ unsigned long long start_code;	/* text starting address */
+  __extension__ unsigned long long start_data;	/* data starting address */
+  __extension__ unsigned long long start_stack;	/* stack starting address */
+  __extension__ long long	signal;		/* signal causing core dump */
+  __extension__ unsigned long long u_ar0;	/* help gdb find registers */
+  __extension__ unsigned long long magic;	/* identifies a core file */
+  char		u_comm[32];		/* user command name */
+};
+
+#endif
+
+#define PAGE_SHIFT		12
+#define PAGE_SIZE		(1UL << PAGE_SHIFT)
+#define PAGE_MASK		(~(PAGE_SIZE-1))
+#define NBPG			PAGE_SIZE
+#define UPAGES			1
+#define HOST_TEXT_START_ADDR	(u.start_code)
+#define HOST_DATA_START_ADDR	(u.start_data)
+#define HOST_STACK_END_ADDR	(u.start_stack + u.u_ssize * NBPG)
+
+#endif	/* _SYS_USER_H */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/syscall.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/syscall.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/syscall.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/syscall.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,36 @@
+/* Copyright (C) 2001, 2002, 2003, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+long syscall (long syscall_number, long arg1, long arg2, long arg3,
+	      long arg4, long arg5, long arg6, long arg7)
+{
+  long ret, err; 
+
+  ret = INTERNAL_SYSCALL_NCS(syscall_number, err, 7, arg1, arg2, arg3, arg4,
+			     arg5, arg6, arg7);
+
+  if (INTERNAL_SYSCALL_ERROR_P(ret, err))
+  {
+    __set_errno(INTERNAL_SYSCALL_ERRNO(ret, err));
+    ret = -1;
+  }
+
+  return ret;
+}
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/syscalls.list glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/syscalls.list
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/syscalls.list	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/syscalls.list	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,31 @@
+# File name	Caller	Syscall name	Args	Strong name	Weak names
+
+#
+# Calls for compatibility with existing MIPS OS implementations and
+# compilers.
+#
+cachectl	-	cachectl	i:pii	__cachectl	cachectl
+cacheflush	-	cacheflush	i:pii	_flush_cache	cacheflush
+sysmips		-	sysmips		i:iiii	__sysmips	sysmips
+
+#
+# Socket functions; Linux/MIPS doesn't use the socketcall(2) wrapper;
+# it's provided for compatibility, though.
+#
+accept		-	accept		Ci:iBN	__libc_accept	__accept accept
+bind		-	bind		i:ipi	__bind		bind
+connect		-	connect		Ci:ipi	__libc_connect	__connect_internal __connect connect
+getpeername	-	getpeername	i:ipp	__getpeername	getpeername
+getsockname	-	getsockname	i:ipp	__getsockname	getsockname
+getsockopt	-	getsockopt	i:iiiBN	__getsockopt	getsockopt
+listen		-	listen		i:ii	__listen	listen
+recv		-	recv		Ci:ibni	__libc_recv	__recv recv
+recvfrom	-	recvfrom	Ci:ibniBN __libc_recvfrom __recvfrom recvfrom
+recvmsg		-	recvmsg		Ci:ipi	__libc_recvmsg	__recvmsg recvmsg
+send		-	send		Ci:ibni	__libc_send	__send send
+sendmsg		-	sendmsg		Ci:ipi	__libc_sendmsg	__sendmsg sendmsg
+sendto		-	sendto		Ci:ibnibn __libc_sendto	__sendto sendto
+setsockopt	-	setsockopt	i:iiibn	__setsockopt	setsockopt
+shutdown	-	shutdown	i:ii	__shutdown	shutdown
+socket		-	socket		i:iii	__socket	socket
+socketpair	-	socketpair	i:iiif	__socketpair	socketpair
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/sysdep.h glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sysdep.h
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/sysdep.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/sysdep.h	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,259 @@
+/* Copyright (C) 2000, 2002, 2003, 2004, 2005, 2006, 2009
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _LINUX_MIPS_SYSDEP_H
+#define _LINUX_MIPS_SYSDEP_H 1
+
+/* There is some commonality.  */
+#include <sysdeps/unix/riscv/sysdep.h>
+
+#include <tls.h>
+
+/* In order to get __set_errno() definition in INLINE_SYSCALL.  */
+#ifndef __ASSEMBLER__
+#include <errno.h>
+#endif
+
+/* For Linux we can use the system call table in the header file
+	/usr/include/asm/unistd.h
+   of the kernel.  But these symbols do not follow the SYS_* syntax
+   so we have to redefine the `SYS_ify' macro here.  */
+#undef SYS_ify
+#ifdef __STDC__
+# define SYS_ify(syscall_name)	__NR_##syscall_name
+#else
+# define SYS_ify(syscall_name)	__NR_/**/syscall_name
+#endif
+
+#ifdef __ASSEMBLER__
+
+/* We don't want the label for the error handler to be visible in the symbol
+   table when we define it here.  */
+#ifdef __PIC__
+# define SYSCALL_ERROR_LABEL 99b
+#endif
+
+#else   /* ! __ASSEMBLER__ */
+
+/* Define a macro which expands into the inline wrapper code for a system
+   call.  */
+#undef INLINE_SYSCALL
+#define INLINE_SYSCALL(name, nr, args...)			       \
+  ({ INTERNAL_SYSCALL_DECL(err);					\
+     long result_var = INTERNAL_SYSCALL (name, err, nr, args);      	\
+     if ( INTERNAL_SYSCALL_ERROR_P (result_var, err) )  		\
+       {								\
+	 __set_errno (INTERNAL_SYSCALL_ERRNO (result_var, err));      	\
+	 result_var = -1L;			       		\
+       }								\
+     result_var; })
+
+#undef INTERNAL_SYSCALL_DECL
+#define INTERNAL_SYSCALL_DECL(err) long err
+
+#undef INTERNAL_SYSCALL_ERROR_P
+#define INTERNAL_SYSCALL_ERROR_P(val, err)   ((long) (err))
+
+#undef INTERNAL_SYSCALL_ERRNO
+#define INTERNAL_SYSCALL_ERRNO(val, err)     (val)
+
+#undef INTERNAL_SYSCALL
+#define INTERNAL_SYSCALL(name, err, nr, args...) \
+	internal_syscall##nr (SYS_ify (name), err, args)
+
+#undef INTERNAL_SYSCALL_NCS
+#define INTERNAL_SYSCALL_NCS(number, err, nr, args...) \
+	internal_syscall##nr (number, err, args)
+
+#define internal_syscall0(number, err, dummy...)			\
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("v0") = number;				\
+	register long __a3 asm("a3");					\
+	__asm__ volatile ( 						\
+	"syscall\n\t" 							\
+	: "+r" (__v0), "=r" (__a3) 					\
+	: "r" (__v0)							\
+	: __SYSCALL_CLOBBERS); 						\
+	err = __a3;							\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall1(number, err, arg0)				\
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("v0") = number;				\
+	register long __a0 asm("a0") = (long) (arg0); 			\
+	register long __a3 asm("a3");					\
+	__asm__ volatile ( 						\
+	"syscall\n\t" 							\
+	: "+r" (__v0), "=r" (__a3) 					\
+	: "r" (__v0), "r"(__a0)						\
+	: __SYSCALL_CLOBBERS); 						\
+	err = __a3;							\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall2(number, err, arg0, arg1)	    		\
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("v0") = number;				\
+	register long __a0 asm("a0") = (long) (arg0); 			\
+	register long __a1 asm("a1") = (long) (arg1); 			\
+	register long __a3 asm("a3");					\
+	__asm__ volatile ( 						\
+	"syscall\n\t" 							\
+	: "+r" (__v0), "=r" (__a3) 					\
+	: "r" (__v0), "r"(__a0), "r"(__a1)				\
+	: __SYSCALL_CLOBBERS); 						\
+	err = __a3;							\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall3(number, err, arg0, arg1, arg2)      		\
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("v0") = number;				\
+	register long __a0 asm("a0") = (long) (arg0); 			\
+	register long __a1 asm("a1") = (long) (arg1); 			\
+	register long __a2 asm("a2") = (long) (arg2); 			\
+	register long __a3 asm("a3");					\
+	__asm__ volatile ( 						\
+	"syscall\n\t" 							\
+	: "+r" (__v0), "=r" (__a3) 					\
+	: "r" (__v0), "r"(__a0), "r"(__a1), "r"(__a2)			\
+	: __SYSCALL_CLOBBERS); 						\
+	err = __a3;							\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall4(number, err, arg0, arg1, arg2, arg3)	  \
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("v0") = number;				\
+	register long __a0 asm("a0") = (long) (arg0); 			\
+	register long __a1 asm("a1") = (long) (arg1); 			\
+	register long __a2 asm("a2") = (long) (arg2); 			\
+	register long __a3 asm("a3") = (long) (arg3);   		\
+	__asm__ volatile ( 						\
+	"syscall\n\t" 							\
+	: "+r" (__v0), "+r" (__a3) 					\
+	: "r" (__v0), "r"(__a0), "r"(__a1), "r"(__a2), "r"(__a3)	\
+	: __SYSCALL_CLOBBERS); 						\
+	err = __a3;							\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall5(number, err, arg0, arg1, arg2, arg3, arg4)    \
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("v0") = number;				\
+	register long __a0 asm("a0") = (long) (arg0); 			\
+	register long __a1 asm("a1") = (long) (arg1); 			\
+	register long __a2 asm("a2") = (long) (arg2); 			\
+	register long __a3 asm("a3") = (long) (arg3);   		\
+	register long __a4 asm("a4") = (long) (arg4);   		\
+	__asm__ volatile ( 						\
+	"syscall\n\t" 							\
+	: "+r" (__v0), "+r" (__a3) 					\
+	: "r" (__v0), "r"(__a0), "r"(__a1), "r"(__a2), "r"(__a3), "r"(__a4)     \
+	: __SYSCALL_CLOBBERS); 						\
+	err = __a3;							\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall6(number, err, arg0, arg1, arg2, arg3, arg4, arg5) \
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("v0") = number;				\
+	register long __a0 asm("a0") = (long) (arg0); 			\
+	register long __a1 asm("a1") = (long) (arg1); 			\
+	register long __a2 asm("a2") = (long) (arg2); 			\
+	register long __a3 asm("a3") = (long) (arg3);   		\
+	register long __a4 asm("a4") = (long) (arg4);   		\
+	register long __a5 asm("a5") = (long) (arg5);   		\
+	__asm__ volatile ( 						\
+	"syscall\n\t" 							\
+	: "+r" (__v0), "+r" (__a3) 					\
+	: "r" (__v0), "r"(__a0), "r"(__a1), "r"(__a2), "r"(__a3), "r"(__a4), "r"(__a5)     \
+	: __SYSCALL_CLOBBERS); 						\
+	err = __a3;							\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall7(number, err, arg0, arg1, arg2, arg3, arg4, arg5, arg6) \
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __v0 asm("v0") = number;				\
+	register long __a0 asm("a0") = (long) (arg0); 			\
+	register long __a1 asm("a1") = (long) (arg1); 			\
+	register long __a2 asm("a2") = (long) (arg2); 			\
+	register long __a3 asm("a3") = (long) (arg3);   		\
+	register long __a4 asm("a4") = (long) (arg4);   		\
+	register long __a5 asm("a5") = (long) (arg5);   		\
+	register long __a6 asm("a6") = (long) (arg6);   		\
+	__asm__ volatile ( 						\
+	"syscall\n\t" 							\
+	: "+r" (__v0), "+r" (__a3) 					\
+	: "r" (__v0), "r"(__a0), "r"(__a1), "r"(__a2), "r"(__a3), "r"(__a4), "r"(__a5), "r"(__a6)     \
+	: __SYSCALL_CLOBBERS); 						\
+	err = __a3;							\
+	_sys_result = __v0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define __SYSCALL_CLOBBERS "v1", "memory"
+#endif /* __ASSEMBLER__ */
+
+/* Pointer mangling is not supported.  */
+#define PTR_MANGLE(var) (void) (var)
+#define PTR_DEMANGLE(var) (void) (var)
+
+#endif /* linux/mips/sysdep.h */
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/_test_and_set.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/_test_and_set.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/_test_and_set.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/_test_and_set.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,30 @@
+/* Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Maciej W. Rozycki <macro@ds2.pg.gda.pl>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Define the real-function versions of all inline functions
+   defined in sys/tas.h  */
+
+#include <features.h>
+
+#define _EXTERN_INLINE
+#ifndef __USE_EXTERN_INLINES
+# define __USE_EXTERN_INLINES 1
+#endif
+
+#include "sys/tas.h"
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/truncate64.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/truncate64.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/truncate64.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/truncate64.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,76 @@
+/* Copyright (C) 1997,1998,1999,2000,2002,2003,2005,2006
+   	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/types.h>
+#include <endian.h>
+#include <errno.h>
+#include <unistd.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+#include <kernel-features.h>
+
+#ifdef __NR_truncate64
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+/* The variable is shared between all wrappers around *truncate64 calls.  */
+int __have_no_truncate64;
+#endif
+
+/* Truncate the file FD refers to to LENGTH bytes.  */
+int
+truncate64 (const char *path, off64_t length)
+{
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+  if (! __have_no_truncate64)
+#endif
+    {
+      unsigned int low = length & 0xffffffff;
+      unsigned int high = length >> 32;
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+      int saved_errno = errno;
+#endif
+      int result = INLINE_SYSCALL (truncate64, 4, CHECK_STRING (path), 0,
+				   __LONG_LONG_PAIR (high, low));
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+      if (result != -1 || errno != ENOSYS)
+#endif
+	return result;
+
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+      __set_errno (saved_errno);
+      __have_no_truncate64 = 1;
+#endif
+    }
+
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+  if ((off_t) length != length)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+  return truncate (path, (off_t) length);
+#endif
+}
+
+#else
+/* Use the generic implementation.  */
+# include <misc/truncate64.c>
+#endif
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/ucontext_i.sym glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/ucontext_i.sym
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/ucontext_i.sym	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/ucontext_i.sym	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,43 @@
+#include <inttypes.h>
+#include <signal.h>
+#include <stddef.h>
+#include <sys/ucontext.h>
+
+#include <kernel_rt_sigframe.h>
+
+-- Constants used by the rt_sigprocmask call.
+
+SIG_BLOCK
+SIG_SETMASK
+
+_NSIG8				(_NSIG / 8)
+
+-- Offsets of the fields in the kernel rt_sigframe_t structure.
+#define rt_sigframe(member)	offsetof (kernel_rt_sigframe_t, member)
+
+RT_SIGFRAME_UCONTEXT		rt_sigframe (rs_uc)
+
+RT_SIGFRAME_SIZE		sizeof (kernel_rt_sigframe_t)
+
+-- Offsets of the fields in the ucontext_t structure.
+#define ucontext(member)	offsetof (ucontext_t, member)
+#define stack(member)		ucontext (uc_stack.member)
+#define mcontext(member)	ucontext (uc_mcontext.member)
+
+UCONTEXT_FLAGS			ucontext (uc_flags)
+UCONTEXT_LINK			ucontext (uc_link)
+UCONTEXT_STACK			ucontext (uc_stack)
+UCONTEXT_MCONTEXT		ucontext (uc_mcontext)
+UCONTEXT_SIGMASK		ucontext (uc_sigmask)
+
+STACK_SP			stack (ss_sp)
+STACK_SIZE			stack (ss_size)
+STACK_FLAGS			stack (ss_flags)
+
+MCONTEXT_GREGS			mcontext (gregs)
+MCONTEXT_FPREGS			mcontext (fpregs)
+MCONTEXT_PC			mcontext (pc)
+MCONTEXT_FSR		mcontext (fsr)
+MCONTEXT_USED_MATH		mcontext (used_math)
+
+UCONTEXT_SIZE			sizeof (ucontext_t)
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/ustat.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/ustat.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/ustat.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/ustat.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,37 @@
+/* Copyright (C) 1997, 1998, 2000, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sys/ustat.h>
+#include <sys/sysmacros.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+int
+ustat (dev_t dev, struct ustat *ubuf)
+{
+  unsigned long k_dev;
+
+  /* We must convert the value to dev_t type used by the kernel.  */
+  k_dev = ((major (dev) & 0xff) << 8) | (minor (dev) & 0xff);
+
+  return INLINE_SYSCALL (ustat, 2, k_dev, CHECK_1 (ubuf));
+}
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/Versions glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/Versions
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/Versions	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/Versions	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,40 @@
+ld {
+  GLIBC_PRIVATE {
+    # used for loading by static libraries
+    _dl_var_init;
+  }
+}
+libc {
+  # The comment lines with "#errlist-compat" are magic; see errlist-compat.awk.
+  # When you get an error from errlist-compat.awk, you need to add a new
+  # version here.  Don't do this blindly, since this means changing the ABI
+  # for all GNU/Linux configurations.
+
+  GLIBC_2.0 {
+    #errlist-compat	123
+    _sys_errlist; sys_errlist; _sys_nerr; sys_nerr;
+
+    # Exception handling support functions from libgcc
+    __register_frame; __register_frame_table; __deregister_frame;
+    __frame_state_for; __register_frame_info_table;
+
+    # Needed by gcc:
+    _flush_cache;
+
+    # c*
+    cachectl; cacheflush;
+
+    # s*
+    sysmips;
+  }
+  GLIBC_2.2 {
+    #errlist-compat	1134
+    _sys_errlist; sys_errlist; _sys_nerr; sys_nerr;
+
+    # _*
+    _test_and_set;
+  }
+  GLIBC_2.11 {
+    fallocate64;
+  }
+}
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/vfork.S glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/vfork.S
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/vfork.S	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/vfork.S	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,65 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* vfork() is just a special case of clone().  */
+
+#include <sys/asm.h>
+#include <sysdep.h>
+#include <asm/unistd.h>
+#include <sgidefs.h>
+
+#ifndef SAVE_PID
+#define SAVE_PID
+#endif
+
+#ifndef RESTORE_PID
+#define RESTORE_PID
+#endif
+
+
+/* int vfork() */
+
+	.text
+LEAF(__vfork)
+
+	SAVE_PID
+
+	li		a0, 0x4112	/* CLONE_VM | CLONE_VFORK | SIGCHLD */
+	move		a1, sp
+	li		a2, 0
+	li		a3, 0
+	li		a4, 0
+
+	/* Do the system call */
+	li		v0,__NR_clone
+	syscall
+
+	RESTORE_PID
+
+	bnez		a3,L(error)
+
+	ret
+
+	/* Something bad happened -- no child created.  */
+L(error):
+	PIC_J(__syscall_error)
+
+	END(__vfork)
+
+libc_hidden_def(__vfork)
+weak_alias (__vfork, vfork)
diff -x manual -x po -x autom4te.cache -ruN ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/xstatconv.c glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/xstatconv.c
--- ../glibc-2.14.1-orig/sysdeps/unix/sysv/linux/riscv/xstatconv.c	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.14.1/sysdeps/unix/sysv/linux/riscv/xstatconv.c	2011-10-25 02:48:44.000000000 -0700
@@ -0,0 +1,202 @@
+/* Convert between the kernel's `struct stat' format, and libc's.
+   Copyright (C) 1991,1995,1996,1997,1998,2000,2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sys/stat.h>
+#include <kernel_stat.h>
+
+#include <string.h>
+
+int
+__xstat_conv (int vers, struct kernel_stat *kbuf, void *ubuf)
+{
+  switch (vers)
+    {
+    case _STAT_VER_KERNEL:
+      /* Nothing to do.  The struct is in the form the kernel expects.
+	 We should have short-circuted before we got here, but for
+	 completeness... */
+      *(struct kernel_stat *) ubuf = *kbuf;
+      break;
+
+    case _STAT_VER_LINUX:
+      {
+	struct stat *buf = ubuf;
+
+	/* Convert to current kernel version of `struct stat'.  */
+	buf->st_dev = kbuf->st_dev;
+	memset (&buf->st_pad1, 0, sizeof (buf->st_pad1));
+	buf->st_ino = kbuf->st_ino;
+	/* Check for overflow.  */
+	if (buf->st_ino != kbuf->st_ino)
+	  {
+	    __set_errno (EOVERFLOW);
+	    return -1;
+	  }
+	buf->st_mode = kbuf->st_mode;
+	buf->st_nlink = kbuf->st_nlink;
+	buf->st_uid = kbuf->st_uid;
+	buf->st_gid = kbuf->st_gid;
+	buf->st_rdev = kbuf->st_rdev;
+	memset (&buf->st_pad2, 0, sizeof (buf->st_pad2));
+	buf->st_size = kbuf->st_size;
+	/* Check for overflow.  */
+	if (buf->st_size != kbuf->st_size)
+	  {
+	    __set_errno (EOVERFLOW);
+	    return -1;
+	  }
+	buf->st_pad3 = 0;
+	buf->st_atim.tv_sec = kbuf->st_atime_sec;
+	buf->st_atim.tv_nsec = kbuf->st_atime_nsec;
+	buf->st_mtim.tv_sec = kbuf->st_mtime_sec;
+	buf->st_mtim.tv_nsec = kbuf->st_mtime_nsec;
+	buf->st_ctim.tv_sec = kbuf->st_ctime_sec;
+	buf->st_ctim.tv_nsec = kbuf->st_ctime_nsec;
+	buf->st_blksize = kbuf->st_blksize;
+	buf->st_blocks = kbuf->st_blocks;
+	/* Check for overflow.  */
+	if (buf->st_blocks != kbuf->st_blocks)
+	  {
+	    __set_errno (EOVERFLOW);
+	    return -1;
+	  }
+	memset (&buf->st_pad5, 0, sizeof (buf->st_pad5));
+      }
+      break;
+
+    default:
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  return 0;
+}
+
+int
+__xstat64_conv (int vers, struct kernel_stat *kbuf, void *ubuf)
+{
+#ifdef XSTAT_IS_XSTAT64
+  return xstat_conv (vers, kbuf, ubuf);
+#else
+  switch (vers)
+    {
+    case _STAT_VER_LINUX:
+      {
+	struct stat64 *buf = ubuf;
+
+	buf->st_dev = kbuf->st_dev;
+	memset (&buf->st_pad1, 0, sizeof (buf->st_pad1));
+	buf->st_ino = kbuf->st_ino;
+	buf->st_mode = kbuf->st_mode;
+	buf->st_nlink = kbuf->st_nlink;
+	buf->st_uid = kbuf->st_uid;
+	buf->st_gid = kbuf->st_gid;
+	buf->st_rdev = kbuf->st_rdev;
+	memset (&buf->st_pad2, 0, sizeof (buf->st_pad2));
+	buf->st_pad3 = 0;
+	buf->st_size = kbuf->st_size;
+	buf->st_blksize = kbuf->st_blksize;
+	buf->st_blocks = kbuf->st_blocks;
+
+	buf->st_atim.tv_sec = kbuf->st_atime_sec;
+	buf->st_atim.tv_nsec = kbuf->st_atime_nsec;
+	buf->st_mtim.tv_sec = kbuf->st_mtime_sec;
+	buf->st_mtim.tv_nsec = kbuf->st_mtime_nsec;
+	buf->st_ctim.tv_sec = kbuf->st_ctime_sec;
+	buf->st_ctim.tv_nsec = kbuf->st_ctime_nsec;
+
+	memset (&buf->st_pad4, 0, sizeof (buf->st_pad4));
+      }
+      break;
+
+      /* If struct stat64 is different from struct stat then
+	 _STAT_VER_KERNEL does not make sense.  */
+    case _STAT_VER_KERNEL:
+    default:
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  return 0;
+#endif
+}
+
+#if _RISCV_SIM == _ABIO32
+int
+__xstat32_conv (int vers, struct stat64 *kbuf, struct stat *buf)
+{
+  switch (vers)
+    {
+    case _STAT_VER_LINUX:
+      /* Convert current kernel version of `struct stat64' to
+	 `struct stat'.  The layout of the fields in the kernel's
+	 stat64 is the same as that in the user stat64; the only
+	 difference is that the latter has more trailing padding.  */
+      buf->st_dev = kbuf->st_dev;
+      memset (&buf->st_pad1, 0, sizeof (buf->st_pad1));
+      buf->st_ino = kbuf->st_ino;
+      /* Check for overflow.  */
+      if (buf->st_ino != kbuf->st_ino)
+	{
+	  __set_errno (EOVERFLOW);
+	  return -1;
+	}
+      buf->st_mode = kbuf->st_mode;
+      buf->st_nlink = kbuf->st_nlink;
+      buf->st_uid = kbuf->st_uid;
+      buf->st_gid = kbuf->st_gid;
+      buf->st_rdev = kbuf->st_rdev;
+      memset (&buf->st_pad2, 0, sizeof (buf->st_pad2));
+      buf->st_size = kbuf->st_size;
+      /* Check for overflow.  */
+      if (buf->st_size != kbuf->st_size)
+	{
+	  __set_errno (EOVERFLOW);
+	  return -1;
+	}
+      buf->st_pad3 = 0;
+      buf->st_atim.tv_sec = kbuf->st_atim.tv_sec;
+      buf->st_atim.tv_nsec = kbuf->st_atim.tv_nsec;
+      buf->st_mtim.tv_sec = kbuf->st_mtim.tv_sec;
+      buf->st_mtim.tv_nsec = kbuf->st_mtim.tv_nsec;
+      buf->st_ctim.tv_sec = kbuf->st_ctim.tv_sec;
+      buf->st_ctim.tv_nsec = kbuf->st_ctim.tv_nsec;
+      buf->st_blksize = kbuf->st_blksize;
+      buf->st_blocks = kbuf->st_blocks;
+      /* Check for overflow.  */
+      if (buf->st_blocks != kbuf->st_blocks)
+	{
+	  __set_errno (EOVERFLOW);
+	  return -1;
+	}
+      memset (&buf->st_pad5, 0, sizeof (buf->st_pad5));
+      break;
+
+      /* If struct stat64 is different from struct stat then
+	 _STAT_VER_KERNEL does not make sense.  */
+    case _STAT_VER_KERNEL:
+    default:
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  return 0;
+}
+#endif /* _RISCV_SIM == _ABIO32 */
