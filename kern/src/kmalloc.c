/* Copyright (c) 2009 The Regents of the University of California. 
 * See the COPYRIGHT files at the top of this source tree for full 
 * license information.
 * 
 * Kevin Klues <klueska@cs.berkeley.edu>    
 */

#ifdef __SHARC__
#pragma nosharc
#endif

#include <ros/common.h>
#include <ros/error.h>
#include <pmap.h>
#include <kmalloc.h>
#include <stdio.h>

#define kmallocdebug(args...)  //printk(args)

char*BND(end, maxaddrpa_ptr + IVY_KERNBASE) boot_freemem;
static page_list_t pages_list;	//List of physical pages used by kmalloc

/*
 * Allocate n bytes of physical memory aligned on an 
 * align-byte boundary.  Align must be a power of two.
 * Return kernel virtual address.  Returned memory is uninitialized.
 *
 * If we're out of memory, boot_alloc should panic.
 * This function may ONLY be used during initialization,
 * before the page_free_list has been set up.
 */
void* boot_alloc(uint32_t n, uint32_t align)
{
	extern char (SNT end)[];
	void *v;

	// Initialize boot_freemem if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment -
	// i.e., the first virtual address that the linker
	// did _not_ assign to any kernel code or global variables.
	if (boot_freemem == 0) {
		boot_freemem = TC(end);
	}

	//	Step 1: round boot_freemem up to be aligned properly
	boot_freemem = PTRROUNDUP(boot_freemem, align);

	//	Step 2: save current value of boot_freemem as allocated chunk
	v = boot_freemem;
	//  Step 2.5: check if we can alloc
	if (PADDR(boot_freemem + n) > maxaddrpa)
		panic("Out of memory in boot alloc, you fool!\n");
	//	Step 3: increase boot_freemem to record allocation
	boot_freemem += n;	
	//	Step 4: return allocated chunk
	return v;
}

void* boot_calloc(uint32_t _n, size_t sz, uint32_t align)
{
	extern char (SNT end)[];
	uint32_t n = _n *sz;
	void *v;

	// Initialize boot_freemem if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment -
	// i.e., the first virtual address that the linker
	// did _not_ assign to any kernel code or global variables.
	if (boot_freemem == 0)
		boot_freemem = TC(end);

	//	Step 1: round boot_freemem up to be aligned properly
	boot_freemem = PTRROUNDUP(boot_freemem, align);

	//	Step 2: save current value of boot_freemem as allocated chunk
	v = boot_freemem;
	//  Step 2.5: check if we can alloc
	if (PADDR(boot_freemem + n) > maxaddrpa)
		panic("Out of memory in boot alloc, you fool!\n");
	//	Step 3: increase boot_freemem to record allocation
	boot_freemem += n;
	//  Step 4: zero allocated chunk
	memset(v,0,n);
	//	Step 5: return allocated chunk
	return v;
}

void kmalloc_init() 
{
	LIST_INIT(&pages_list);
}

void* kmalloc(size_t size, int flags) 
{
	if (size == 0)
		return NULL;

	int npages = ROUNDUP(size, PGSIZE) / PGSIZE;
	
	// Find 'npages' free consecutive pages
	int first = -1;
	kmallocdebug("naddrpages: %u\n", naddrpages);
	kmallocdebug("npages: %u\n", npages);
	for(int i=(naddrpages-1); i>=(npages-1); i--) {
		int j;
		for(j=i; j>=(i-(npages-1)); j--) {
			if( !page_is_free(j) )
				break;
		}
		if( j == (i-(npages-1)-1)) {
			first = j+1;
			break;
		}
	}
	//If we couldn't find them, return NULL
	if( first == -1 )
		return NULL;
		
	//Otherwise go ahead and allocate them to ourselves now
	for(int i=0; i<npages; i++) {
		page_t* page;
		page_alloc_specific(&page, first+i);
		// Kevin doesn't like this next line 
		page_incref(page); 
		page->num_cons_links = npages-i;
		LIST_INSERT_HEAD(&pages_list, page, page_link);
		kmallocdebug("mallocing page: %u\n", first+i);
		kmallocdebug("at addr: %p\n", ppn2kva(first+i));
	}
	//And return the address of the first one
	return ppn2kva(first);
}

void kfree(void *addr)
{
	kmallocdebug("incoming address: %p\n", addr);
	page_t* page = kva2page(addr);
	int num_links = page->num_cons_links;
	kmallocdebug("getting page: %u\n", page2ppn(page));
	for(int i=0; i<num_links; i++) {
		page_t* p = ppn2page((page2ppn(page) + i));
		LIST_REMOVE(p, page_link);
		page_free(p);
		kmallocdebug("freeing page: %d\n", page2ppn(p));
	}
}

