# Makefile fragment for ROS kernel.
# This is NOT a complete makefile;
# you must run GNU make in the top-level directory
# where the GNUmakefile is located.
#

KERN_SRC_DIR = $(KERN_DIR)/src
OBJDIRS += $(KERN_SRC_DIR)

# entry.S must be first, so that it's the first code in the text segment!!!
#
# We also snatch the use of a couple handy source files
# from the lib directory, to avoid gratuitous code duplication.
KERN_SRCFILES := $(KERN_SRC_DIR)/entry.S \
                 $(KERN_SRC_DIR)/smp_entry.S \
                 $(KERN_SRC_DIR)/init.c \
                 $(KERN_SRC_DIR)/console.c \
                 $(KERN_SRC_DIR)/monitor.c \
                 $(KERN_SRC_DIR)/pmap.c \
                 $(KERN_SRC_DIR)/env.c \
                 $(KERN_SRC_DIR)/kclock.c \
                 $(KERN_SRC_DIR)/picirq.c \
                 $(KERN_SRC_DIR)/printf.c \
                 $(KERN_SRC_DIR)/trap.c \
                 $(KERN_SRC_DIR)/trapentry.S \
                 $(KERN_SRC_DIR)/sched.c \
                 $(KERN_SRC_DIR)/syscall.c \
                 $(KERN_SRC_DIR)/kdebug.c \
                 $(KERN_SRC_DIR)/apic.c \
                 $(KERN_SRC_DIR)/testing.c \
                 $(KERN_SRC_DIR)/workqueue.c \
                 $(KERN_SRC_DIR)/manager.c \
                 $(KERN_SRC_DIR)/atomic.c \
                 $(KERN_SRC_DIR)/smp.c \
                 $(KERN_SRC_DIR)/printfmt.c \
                 $(KERN_SRC_DIR)/readline.c \
                 $(KERN_SRC_DIR)/string.c \
                 $(KERN_SRC_DIR)/timer.c
# Only build files if they exist.
KERN_SRCFILES := $(wildcard $(KERN_SRCFILES))

KERN_APPFILES :=  	$(USER_APPS_PARLIB_DIR)/matrix 
#                    $(USER_APPS_PARLIB_DIR)/open_read \
#                    $(USER_APPS_ROSLIB_DIR)/null
#					$(USER_APPS_ROSLIB_DIR)/hello \
#					apps/hello \
#					apps_newlib/null \
#   				apps/hello \
#   				apps/buggyhello \
#   				apps/evilhello \
#   				apps/testbss \
#   				apps/divzero \
#   				apps/breakpoint \
#   				apps/softint \
#   				apps/badsegment \
#   				apps/faultread \
#   				apps/faultreadkernel \
#   				apps/faultwrite \
#   				apps/faultwritekernel \
#   				apps_newlib/null \

KERN_LDFLAGS   := $(KERN_LDFLAGS) -L$(OBJDIR)/$(KERN_DIR) \
                  -T $(KERN_DIR)/kernel.ld

KERN_OBJFILES  := $(patsubst $(KERN_SRC_DIR)/%.c, \
                             $(OBJDIR)/$(KERN_DIR)/%.o, \
                             $(KERN_SRCFILES))
KERN_OBJFILES  := $(patsubst $(KERN_SRC_DIR)/%.S, \
                             $(OBJDIR)/$(KERN_DIR)/%.o, \
                             $(KERN_OBJFILES))

KERN_APPFILES  := $(patsubst %, $(OBJDIR)/%, $(KERN_APPFILES))

KERN_LDDEPENDS := $(KERN_OBJFILES) $(KERN_APPFILES) $(KERN_DIR)/kernel.ld \
                  $(OBJDIR)/$(KERN_DIR)/libivykern.a

KERN_LDLIBS    := -livykern

KERN_GCC_LIB   := $(GCC_LIB)

$(OBJDIR)/$(KERN_DIR)/%.o: $(KERN_SRC_DIR)/%.c
	@echo + cc [KERN] $<
	@mkdir -p $(@D)
	$(V)$(CC) $(KERN_CFLAGS) -c -o $@ $<

$(OBJDIR)/$(KERN_DIR)/%.o: $(KERN_SRC_DIR)/%.S
	@echo + as [KERN] $<
	@mkdir -p $(@D)
	$(V)$(CC) $(KERN_CFLAGS) -c -o $@ $<

$(OBJDIR)/$(KERN_DIR)/kernel: $(KERN_LDDEPENDS)
	@echo + ld [KERN] $@
	$(V)$(LD) -o $@ $(KERN_LDFLAGS) $(KERN_OBJFILES) $(KERN_LDLIBS) \
	                $(KERN_GCC_LIB) -b binary $(KERN_APPFILES)
	$(V)$(OBJDUMP) -S $@ > $@.asm
	$(V)$(NM) -n $@ > $@.sym

$(OBJDIR)/$(KERN_DIR)/bochs.img: $(OBJDIR)/$(KERN_DIR)/kernel $(OBJDIR)/$(KERN_DIR)/boot
	@echo + mk [KERN] $@
	$(V)dd if=/dev/zero of=$(OBJDIR)/$(KERN_DIR)/bochs.img~ count=10000 2>/dev/null
	$(V)dd if=$(OBJDIR)/$(KERN_DIR)/boot of=$(OBJDIR)/$(KERN_DIR)/bochs.img~ conv=notrunc 2>/dev/null
	$(V)dd if=$(OBJDIR)/$(KERN_DIR)/kernel of=$(OBJDIR)/$(KERN_DIR)/bochs.img~ seek=1 conv=notrunc 2>/dev/null
	$(V)mv $(OBJDIR)/kern/bochs.img~ $(OBJDIR)/kern/bochs.img

all: $(OBJDIR)/$(KERN_DIR)/bochs.img

